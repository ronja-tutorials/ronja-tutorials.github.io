<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>Triplanar Mapping</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="Ronja Böhringer">

<meta name="description" content="Summary I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and bre..." />





<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="Triplanar Mapping">
<meta itemprop="description" content="Summary I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and bre...">

  <meta itemprop="image" content="https://www.ronja-tutorials.com/assets/images/posts/010/Result.gif">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="Triplanar Mapping">
<meta name="twitter:description" content="Summary I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and bre...">


  <meta name="twitter:creator" content="@TotallyRonja">


<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="https://www.ronja-tutorials.com/assets/images/posts/010/Result.gif">
  <meta property="twitter:image" content="https://www.ronja-tutorials.com/assets/images/posts/010/Result.gif">

<meta property="twitter:url" content="https://www.ronja-tutorials.com/2018/05/11/triplanar-mapping.html">

<!-- Open Graph data -->
<meta property="og:title" content="Triplanar Mapping" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/2018/05/11/triplanar-mapping.html" />

  <meta property="og:image" content="https://www.ronja-tutorials.com/assets/images/posts/010/Result.gif" />

<meta property="og:description" content="Summary I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and bre..." />
<meta property="og:site_name" content="Ronja's Shader Tutorials" />

  <meta property="article:published_time" content="2018-05-11T00:00:00+02:00" />














  





  




    

    <link rel="canonical" href="https://www.ronja-tutorials.com/2018/05/11/triplanar-mapping.html">

    

    <!-- <link rel="shortcut icon" href="https://www.ronja-tutorials.com/favicon.ico"> -->
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">Ronja&#39;s Shader Tutorials</a>
    
    <!-- SVG icons from https://iconmonstr.com -->

    <!-- Twitter icon -->
    <span class="my-span-icon">
        <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
          <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
        </a>
      </span>

      <!-- RSS icon -->
      
        <span class="my-span-icon">
          <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
          </a>
        </span>
      
      <!-- Contact icon -->
      
      
        <span class="my-span-icon">
          <a href="/about.html" aria-label="Contact" title="Contact ">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
          </a>
        </span>
      

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">Triplanar Mapping</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2018-05-11T00:00:00+02:00" itemprop="datePublished">
          
          May 11, 2018
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ronja Böhringer</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Triplanar Mapping</h1>
    <p class="post-meta">
      <time datetime="2018-05-11T00:00:00+02:00" itemprop="datePublished">
        
        May 11, 2018
      </time>
      </p>
  </header> -->

  
<ul>
  <li><a href="#summary">Summary</a></li>
  <li><a href="#calculate-projection-planes">Calculate Projection Planes</a></li>
  <li><a href="#normals">Normals</a></li>
</ul>

  <div itemprop="articleBody">
    <h2 id="summary">Summary</h2>
<p>I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and breaks when the surface we’re drawing isn’t oriented towards the direction we’re mapping from (up in the previous example). A way to improve automatic uv generation is that we do the mapping three times from different directions and blend between those three colors.</p>

<p>This tutorial will build upon the <a href="/2018/04/23/planar-mapping.html">planar mapping shader</a> which is a unlit shader, but you can use the technique with many shaders, including surface shaders.
<img src="/assets/images/posts/010/Result.gif" alt="Result" /></p>

<h2 id="calculate-projection-planes">Calculate Projection Planes</h2>
<p>To generate three different sets of UV coordinates, we start by changing the way we get the UV coordinates. Instead of returning the transformed uv coordinates from the vertex shader we return the world position and then generate the UV coordinates in the fragment shader.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
    <span class="c1">//calculate the position in clip space to render the object</span>
    <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="c1">//calculate world position of vertex</span>
    <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We use transform tex to apply the tiling and offset of the texture like we’re used to. In my shader I use xy and zy so the world up axis is mapped to the y axis of the texture for both textures, not rotating them in relation to each other, but you can play around with the way use use those values (the way the top UVs are mapped is arbitrary).</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="c1">//calculate UV coordinates for three projections</span>
    <span class="n">float2</span> <span class="n">uv_front</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">uv_side</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">zy</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">uv_top</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
</code></pre></div></div>

<p>After obtaining the correct coordinates, we read the texture at those coordinates, add the three colors and divide the result by 3 (adding three colors without dividing by the number of colors would just be very bright).</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//read texture at uv position of the three projections</span>
<span class="n">fixed4</span> <span class="n">col_front</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">uv_front</span><span class="p">);</span>
<span class="n">fixed4</span> <span class="n">col_side</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">uv_side</span><span class="p">);</span>
<span class="n">fixed4</span> <span class="n">col_top</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">uv_top</span><span class="p">);</span>

<span class="c1">//combine the projected colors</span>
<span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">col_front</span> <span class="o">+</span> <span class="n">col_side</span> <span class="o">+</span> <span class="n">col_top</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>

<span class="c1">//multiply texture color with tint color</span>
<span class="n">col</span> <span class="o">*=</span> <span class="n">_Color</span><span class="p">;</span>
<span class="k">return</span> <span class="n">col</span><span class="p">;</span>
</code></pre></div></div>
<p><img src="/assets/images/posts/010/AllSides.png" alt="Add projections from all sides together" /></p>

<h2 id="normals">Normals</h2>
<p>Having done that our material looks really weird. That’s because we display the average of the three projections. To fix that we have to show different projections based on the direction the surface is facing. The facing direction of the surface is also called “normal” and it’s saved in the object files, just like the position of the vertices.</p>

<p>So what we do is get the normals in our input struct, convert them to worldspace normals in the vertex shader (because our projection is in worldspace, if we used object space projection we’d keep the normals in object space).</p>

<p>For the conversion of the normal from object space to world space, we have to multiply it with the inverse transposed matrix. It’s not important to understand how that works exactly (matrix multiplication is complicated), but I’d like to explain why we can’t just multiply it with the object to world matrix like we do with the position. The normals are orthogonal to the surface, so when we scale the surface only along the X axis and not the Y axis the surface gets steeper, but when we do the same to our normal, it also points more upwards than previously and isn’t orthogonal to the surface anymore. Instead we have to make the normal more flat the steeper the surface gets and the inverse transpose matrix does that for us. Then we also convert the matrix to a 3x3 matrix, discarding the parts that would move the normals. (we don’t want to move the normals because they represent directions instead of positions)</p>

<p>The way we use the inverse transpose object to world matrix is that we multiply the normal with the world to object matrix (previously we multiplied the matrix with the vector, order is important here).</p>

<p><img src="/assets/images/posts/010/NormalScaling.png" alt="Why we have to scale the normal with the inverse matrix instead of the regular one" /></p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
    <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
    <span class="c1">//calculate the position in clip space to render the object</span>
    <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="c1">//calculate world position of vertex</span>
    <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="c1">//calculate world normal</span>
    <span class="n">float3</span> <span class="n">worldNormal</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="p">(</span><span class="n">float3x3</span><span class="p">)</span><span class="n">unity_WorldToObject</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">worldNormal</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To check our normals, we can now just return them in our fragment shader and see the different axis as colors.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="err">}</span>
</code></pre></div></div>
<p><img src="/assets/images/posts/010/Normals.png" alt="The normals as colors" /></p>

<p>To convert the normals to weights for the different projections we start by taking the absolute value of the normal. That’s because the normals go in the positive and negative directions. That’s also why in our debug view the “backside” of our object, where the axes go towards the negative direction, is black.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float3</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">;</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>
</code></pre></div></div>

<p>After that we can multiply the different projections with the weights, making them only appear on the side we’re projecting it on, not the others where the texture looks stretched. We multiply the projection from the xy plane to the z weight because towards that axis it doesn’t stetch and we do a smiliar thing to the other axes.</p>

<p>We also remove the division by 3 because we don’t add them all together anymore.</p>

<p><img src="/assets/images/posts/010/ZPlane.png" alt="Illustration of a plane based on asurface normal" /></p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//generate weights from world normals</span>
<span class="n">float3</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">;</span>
<span class="c1">//show texture on both sides of the object (positive and negative)</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>

<span class="c1">//combine weights with projected colors</span>
<span class="n">col_front</span> <span class="o">*=</span> <span class="n">weights</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="n">col_side</span> <span class="o">*=</span> <span class="n">weights</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="n">col_top</span> <span class="o">*=</span> <span class="n">weights</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

<span class="c1">//combine the projected colors</span>
<span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">col_front</span> <span class="o">+</span> <span class="n">col_side</span> <span class="o">+</span> <span class="n">col_top</span><span class="p">;</span>

<span class="c1">//multiply texture color with tint color</span>
<span class="n">col</span> <span class="o">*=</span> <span class="n">_Color</span><span class="p">;</span>
<span class="k">return</span> <span class="n">col</span><span class="p">;</span>
</code></pre></div></div>
<p><img src="/assets/images/posts/010/AddPlanes.jpg" alt="the planar projections added based on normals" /></p>

<p>That’s way better already, but now we have the same problem again why we added the division by 3, the components of the normals add up to more than 3 sometimes, making the texture appear brighter than it should be. We can fix that by dividing it by the sum of it’s components, forcing it to add up to 1.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//make it so the sum of all components is 1</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="p">(</span><span class="n">weights</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">weights</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">weights</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</code></pre></div></div>
<p><img src="/assets/images/posts/010/AddPlanesNormalized.jpg" alt="the planar projections added based on normals with normalized blend factors" /></p>

<p>And with that we’re back to the expected brightness.</p>

<p>The last thing we add to this shader is the possibility to make the different directions more distinct, because right now the area where they blend into each other is still pretty big, making the colors look messy. To archieve that we add a new property for the sharpness of the blending. Then, before making the weights sum up to one, we calculate weights to the power of sharpness. Because we only operate in ranges from 0 to 1 that will lower the low values if the sharpness is high, but won’t change the high values by as much. We make the property of the type range to have a nice slider in the UI of the shader.</p>
<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//...</span>

<span class="n">_Sharpness</span><span class="p">(</span><span class="s">"Blend Sharpness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1">//...</span>

<span class="kt">float</span> <span class="n">_Sharpness</span><span class="p">;</span>

<span class="c1">//...</span>

<span class="c1">//make the transition sharper</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">_sharpness</span><span class="p">)</span>

<span class="c1">//...</span>
</code></pre></div></div>
<p><img src="/assets/images/posts/010/BlendSharpness.gif" alt="adjusting the blend sharpness" /></p>

<p>Triplanar Mapping still isn’t perfect, it needs tiling textures to work, it breaks at surfaces that are exactly 45° and it’s obviously more expensive than a single texture sample (though not by that much).</p>

<p>You can use it in surface shaders for albedo, specular, etc. maps, but it doesn’t work perfectly for normalmaps without some changes I won’t go into here.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/010_Triplanar_Mapping"</span><span class="p">{</span>
	<span class="c1">//show values to edit in inspector</span>
	<span class="n">Properties</span><span class="p">{</span>
		<span class="n">_Color</span> <span class="p">(</span><span class="s">"Tint"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">_MainTex</span> <span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
		<span class="n">_Sharpness</span> <span class="p">(</span><span class="s">"Blend sharpness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="n">SubShader</span><span class="p">{</span>
		<span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
		<span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

		<span class="n">Pass</span><span class="p">{</span>
			<span class="n">CGPROGRAM</span>

			<span class="cp">#include "UnityCG.cginc"
</span>
			<span class="cp">#pragma vertex vert
</span>			<span class="cp">#pragma fragment frag
</span>
			<span class="c1">//texture and transforms of the texture</span>
			<span class="kt">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
			<span class="n">float4</span> <span class="n">_MainTex_ST</span><span class="p">;</span>

			<span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>
			<span class="kt">float</span> <span class="n">_Sharpness</span><span class="p">;</span>

			<span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
				<span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
				<span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
			<span class="p">};</span>

			<span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
				<span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
				<span class="n">float3</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
				<span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
			<span class="p">};</span>

			<span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
				<span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
				<span class="c1">//calculate the position in clip space to render the object</span>
				<span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
				<span class="c1">//calculate world position of vertex</span>
				<span class="n">float4</span> <span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
				<span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
				<span class="c1">//calculate world normal</span>
				<span class="n">float3</span> <span class="n">worldNormal</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="p">(</span><span class="n">float3x3</span><span class="p">)</span><span class="n">unity_WorldToObject</span><span class="p">);</span>
				<span class="n">o</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">worldNormal</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
				<span class="c1">//calculate UV coordinates for three projections</span>
				<span class="n">float2</span> <span class="n">uv_front</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
				<span class="n">float2</span> <span class="n">uv_side</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">zy</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
				<span class="n">float2</span> <span class="n">uv_top</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
				
				<span class="c1">//read texture at uv position of the three projections</span>
				<span class="n">fixed4</span> <span class="n">col_front</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">uv_front</span><span class="p">);</span>
				<span class="n">fixed4</span> <span class="n">col_side</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">uv_side</span><span class="p">);</span>
				<span class="n">fixed4</span> <span class="n">col_top</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">uv_top</span><span class="p">);</span>

				<span class="c1">//generate weights from world normals</span>
				<span class="n">float3</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">;</span>
				<span class="c1">//show texture on both sides of the object (positive and negative)</span>
				<span class="n">weights</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>
				<span class="c1">//make the transition sharper</span>
				<span class="n">weights</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">_Sharpness</span><span class="p">);</span>
				<span class="c1">//make it so the sum of all components is 1</span>
				<span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="p">(</span><span class="n">weights</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">weights</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">weights</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>

				<span class="c1">//combine weights with projected colors</span>
				<span class="n">col_front</span> <span class="o">*=</span> <span class="n">weights</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
				<span class="n">col_side</span> <span class="o">*=</span> <span class="n">weights</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
				<span class="n">col_top</span> <span class="o">*=</span> <span class="n">weights</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

				<span class="c1">//combine the projected colors</span>
				<span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">col_front</span> <span class="o">+</span> <span class="n">col_side</span> <span class="o">+</span> <span class="n">col_top</span><span class="p">;</span>

				<span class="c1">//multiply texture color with tint color</span>
				<span class="n">col</span> <span class="o">*=</span> <span class="n">_Color</span><span class="p">;</span>

				<span class="k">return</span> <span class="n">col</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ENDCG</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">FallBack</span> <span class="s">"Standard"</span> <span class="c1">//fallback adds a shadow pass so we get shadows on other objects</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I hope this tutorial helped you understand how to do triplanar texture mapping in unity.</p>

<p>You can also find the source code for this shader here: <a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader</a></p>


    <p>
        You can also find me on twitter at <a href="https://www.twitter.com/totallyRonja">@totallyRonja</a>. If you liked my tutorial and want to support me you can do that on Patreon (<a href="https://www.patreon.com/RonjaTutorials">patreon.com/RonjaTutorials</a>) or Ko-Fi (<a href="https://ko-fi.com/RonjaTutorials">ko-fi.com/RonjaTutorials</a>).
    </p>
  </div>

  
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ronja-tutorials.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  
</article>


      <!-- SVG icons from https://iconmonstr.com -->

      <!-- Twitter icon -->
      <span class="my-span-icon">
          <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>

        <!-- RSS icon -->
        
          <span class="my-span-icon">
            <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
            </a>
          </span>
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact ">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        
    </section>

    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-124040112-1', 'auto');
        ga('send', 'pageview');
      </script>
    
  </body>
</html>
