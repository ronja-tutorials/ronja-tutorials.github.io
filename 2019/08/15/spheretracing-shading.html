<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>Spheretracing with Shading</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="Ronja Böhringer">

<meta name="description" content="In a previous tutorial I showed how to trace signed distance functions to reveal their silouette. In this one I will show you how to expand that shad..." />





<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="Spheretracing with Shading">
<meta itemprop="description" content="In a previous tutorial I showed how to trace signed distance functions to reveal their silouette. In this one I will show you how to expand that shad...">

  <meta itemprop="image" content="https://www.ronja-tutorials.com/assets/images/posts/044/Result.png">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="Spheretracing with Shading">
<meta name="twitter:description" content="In a previous tutorial I showed how to trace signed distance functions to reveal their silouette. In this one I will show you how to expand that shad...">


  <meta name="twitter:creator" content="@TotallyRonja">


<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="https://www.ronja-tutorials.com/assets/images/posts/044/Result.png">
  <meta property="twitter:image" content="https://www.ronja-tutorials.com/assets/images/posts/044/Result.png">

<meta property="twitter:url" content="https://www.ronja-tutorials.com/2019/08/15/spheretracing-shading.html">

<!-- Open Graph data -->
<meta property="og:title" content="Spheretracing with Shading" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/2019/08/15/spheretracing-shading.html" />

  <meta property="og:image" content="https://www.ronja-tutorials.com/assets/images/posts/044/Result.png" />

<meta property="og:description" content="In a previous tutorial I showed how to trace signed distance functions to reveal their silouette. In this one I will show you how to expand that shad..." />
<meta property="og:site_name" content="Ronja's Shader Tutorials" />

  <meta property="article:published_time" content="2019-08-15T00:00:00+02:00" />














  





  




    

    <link rel="canonical" href="https://www.ronja-tutorials.com/2019/08/15/spheretracing-shading.html">

    

    <!-- <link rel="shortcut icon" href="https://www.ronja-tutorials.com/favicon.ico"> -->
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">Ronja&#39;s Shader Tutorials</a>
    
    <!-- SVG icons from https://iconmonstr.com -->

    <!-- Twitter icon -->
    <span class="my-span-icon">
        <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
          <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
        </a>
      </span>

      <!-- RSS icon -->
      
        <span class="my-span-icon">
          <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
          </a>
        </span>
      
      <!-- Contact icon -->
      
      
        <span class="my-span-icon">
          <a href="/about.html" aria-label="Contact" title="Contact ">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
          </a>
        </span>
      

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">Spheretracing with Shading</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2019-08-15T00:00:00+02:00" itemprop="datePublished">
          
          Aug 15, 2019
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ronja Böhringer</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Spheretracing with Shading</h1>
    <p class="post-meta">
      <time datetime="2019-08-15T00:00:00+02:00" itemprop="datePublished">
        
        Aug 15, 2019
      </time>
      </p>
  </header> -->

  
<ul>
  <li><a href="#architecture-changes">Architecture Changes</a></li>
  <li><a href="#normal">Normal</a></li>
  <li><a href="#lighting">Lighting</a></li>
  <li><a href="#final-steps">Final Steps</a></li>
  <li><a href="#source">Source</a></li>
</ul>

  <div itemprop="articleBody">
    <p>In a <a href="/2019/06/21/spheretracing-basics.html">previous tutorial</a> I showed how to trace signed distance functions to reveal their silouette. In this one I will show you how to expand that shader to add simple lighting and make the objects look more tangible.</p>

<h2 id="architecture-changes">Architecture Changes</h2>
<p>In the previous shader we returned a solid color after finding a surface the ray collides with. To add lighting or other effects we have to expand this part. To keep the shader as readable as possible we’ll do a function call in this place and return the result of the function. This material function will calculate the light and combine the lighting with the surface color. To make this function as modular as possible I decided to put the light calculations in another function and the calculations for the normal of the surface in yet another one. If fewer more monolithic functions are more readable to you, feel free to structure your shader like that.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float3</span> <span class="nf">normal</span><span class="p">(</span><span class="n">float3</span> <span class="n">pos</span><span class="p">){</span>
    <span class="c1">//calculate surface normal</span>
<span class="p">}</span>

<span class="n">float3</span> <span class="nf">lightColor</span><span class="p">(</span><span class="n">float3</span> <span class="n">pos</span><span class="p">){</span>
    <span class="c1">//calculate light color</span>
<span class="p">}</span>

<span class="n">float4</span> <span class="nf">material</span><span class="p">(</span><span class="n">float3</span> <span class="n">pos</span><span class="p">){</span>
    <span class="c1">//return final surface color</span>
<span class="p">}</span>

<span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="c1">//ray information</span>
    <span class="n">float3</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">localPosition</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="c1">//tracing loop</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">MAX_STEPS</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//get current location on ray</span>
        <span class="n">float3</span> <span class="n">samplePoint</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">dir</span> <span class="o">*</span> <span class="n">progress</span><span class="p">;</span>
        <span class="c1">//get distance to closest shape</span>
        <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">samplePoint</span><span class="p">);</span>
        <span class="c1">//return color if inside shape</span>
        <span class="k">if</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">THICKNESS</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">material</span><span class="p">(</span><span class="n">samplePoint</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//go forwards</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span> <span class="o">+</span> <span class="n">distance</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//discard pixel if no shape was hit</span>
    <span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="normal">Normal</h2>
<p>One of the most important variables when calculating light in a shader is the surface normal. Unlike a mesh where the normal is embeded into the data, we have to get the normal from the scene function ourselves in this case. We use the fact that we can see a signed distance field as a function to calculate the normal. The normal is the direction in which the value of the SDF grows. Even though a 3d function looks way more complex than a 1d function we can still use similar techniques to find the direction of it.</p>

<p>This “direction” of a function is also called its “derivative” and a common and simple way to find it is to look at two close points of the function and compare the change in value. With 1d functions we pass the function 2 different X values and divide the change in resulting Y values by the change in the X axis to get the rate at which the result of the function changes.</p>

<p><img src="/assets/images/posts/044/1d_derivative.png" alt="" /></p>

<p>When working with our 3d signed distance function we can do the same separately in 3 axis and since we only care about the direction and use the same change in position in all axis we don’t even have to care about the length of the resulting vector.</p>

<p>We call the change in position to get the normal “epsilon”. A epsilon that’s too big leads to surfaces that look too smooth and inaccurate, but a epsilon that’s too small can lead to calculation imprecisions, so it’s worth playing around with that value for your use case. I chose 0.01 as a starting value. The function to calculate the change in signed distance value is scenevalue at the position plus a little distance in a axis subtracted by the scene value at the position minus a tiny number on that axis. In code this looks like this:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//determine change in signed distance</span>
<span class="kt">float</span> <span class="n">changeX</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="kt">float</span> <span class="n">changeY</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="kt">float</span> <span class="n">changeZ</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">))</span> <span class="o">-</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">));</span>
</code></pre></div></div>

<p>You can see how to get the derivative on the X axis we move the position a bit to the right and left on that axis.</p>

<p>After getting all those values we can combine them to one normal vector. Since we used such a tiny epsilon, the normal vector will also be very small, so to fix that we normalize it wich results in a normal vector with a length of 1. Since we decided the object is traced in object space, but a normal in worldspace is more useful we also do a matrix multiplication to convert it into worldspace before normalizing it. For the multiplication we add a 4th component which we set to 0, this makes the instruction only change the rotation and scale of the vector, but doesn’t move it since the normal is position independent.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//distance from rendered point to sample SDF for normal calculation</span>
<span class="cp">#define NORMAL_EPSILON 0.01
</span>
<span class="n">float3</span> <span class="nf">normal</span><span class="p">(</span><span class="n">float3</span> <span class="n">pos</span><span class="p">){</span>
    <span class="c1">//determine change in signed distance</span>
    <span class="kt">float</span> <span class="n">changeX</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">changeY</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">changeZ</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">))</span> <span class="o">-</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">));</span>
    <span class="c1">//construct normal vector</span>
    <span class="n">float3</span> <span class="n">surfaceNormal</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="n">changeX</span><span class="p">,</span> <span class="n">changeY</span><span class="p">,</span> <span class="n">changeZ</span><span class="p">);</span>
    <span class="c1">//convert normal vector into worldspace and make it uniform length</span>
    <span class="n">surfaceNormal</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">surfaceNormal</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">surfaceNormal</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we now return the result of the normal function from the shader, we can see the worldspace normals which lead to a red/green/blue surface in the same direction as the direction gizmo in the corner.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//return color if inside shape</span>
<span class="k">if</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">THICKNESS</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">normal</span><span class="p">(</span><span class="n">samplePoint</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/044/normals.png" alt="" /></p>

<h2 id="lighting">Lighting</h2>

<p>The lighting function works the same as in any other context. The main difference to <a href="/2018/06/02/custom-lighting.html">the lighting implementations I’ve explained previously</a> we can’t use surface shaders so this implementation is more limited since that would need multiple shader passes. I’m not going to implement more than 1 light and won’t show how to make point lights work here, so we’re stuck with a single directional light.</p>

<p>We begin my retrieving the surface normal with the previously written function. Then we get the direction the light is coming from. In the case of directional lights this is always saved in <code class="language-plaintext highlighter-rouge">_WorldSpaceLightPos0.xyz</code>.</p>

<p>With this information we can do a simple lighting calculation. We get the dot product between direction and normal and then we use the saturate function to ensure the result is never negative. The result of the function is this falloff multiplied by the color of the light which is stored in <code class="language-plaintext highlighter-rouge">_LightColor0</code> to use the color of the light as a tint. It’s important that the <code class="language-plaintext highlighter-rouge">_LightColor0</code> variable is only available when we imclude the <code class="language-plaintext highlighter-rouge">Lighting.cginc</code> include file in our shader, so we also add that.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "Lighting.cginc"
</span>
<span class="n">float4</span> <span class="nf">lightColor</span><span class="p">(</span><span class="n">float3</span> <span class="n">position</span><span class="p">){</span>
    <span class="c1">//calculate needed surface and light data</span>
    <span class="n">float3</span> <span class="n">surfaceNormal</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">lightDirection</span> <span class="o">=</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>

    <span class="c1">//calculate simple shading</span>
    <span class="kt">float</span> <span class="n">lightAngle</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">surfaceNormal</span><span class="p">,</span> <span class="n">lightDirection</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">lightAngle</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Printing out the result of the lighting function already looks like a plain white surface.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//return color if inside shape</span>
<span class="k">if</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">THICKNESS</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">lightColor</span><span class="p">(</span><span class="n">samplePoint</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/044/light.png" alt="" /></p>

<h2 id="final-steps">Final Steps</h2>

<p>The last step for this shader I want to show is how to include the surface color into the shader again. For this we prepared the material function earlier which combines everything into the final result. In this implementation we just multiply the light we calculated with the color property which we added in the previous tutorial to get the final color.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float4</span> <span class="nf">material</span><span class="p">(</span><span class="n">float3</span> <span class="n">position</span><span class="p">){</span>
    <span class="c1">//get light color</span>
    <span class="n">float4</span> <span class="n">light</span> <span class="o">=</span> <span class="n">lightColor</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>

    <span class="c1">//combine base color and light color</span>
    <span class="n">float4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">_Color</span> <span class="o">*</span> <span class="n">light</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/044/Result.png" alt="" /></p>

<p>You can expand this by reading a texture or generating a pattern in the material function or by using more complex or interresting lighting functions in the lightColor function and of course by using a more complex signed distance field, but I hope this tutorial gave you some insight into the basics and how to get to more complex implementations.</p>

<h2 id="source">Source</h2>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/044_SphereTracingShading/SphereTracingShading.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/044_SphereTracingShading/SphereTracingShading.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/044_SphereTracingShading"</span><span class="p">{</span>
    <span class="c1">//show values to edit in inspector</span>
    <span class="n">Properties</span><span class="p">{</span>
        <span class="n">_Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">SubShader</span><span class="p">{</span>
        <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span> <span class="s">"DisableBatching"</span><span class="o">=</span><span class="s">"True"</span><span class="p">}</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">ZWrite</span> <span class="n">Off</span>

            <span class="n">CGPROGRAM</span>
            <span class="cp">#include "UnityCG.cginc"
</span>            <span class="cp">#include "Lighting.cginc"
</span>
            

            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="c1">//surface color</span>
            <span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>

            <span class="c1">//maximum amount of steps</span>
            <span class="cp">#define MAX_STEPS 10
</span>            <span class="c1">//furthest distance that's accepted as inside surface</span>
            <span class="cp">#define THICKNESS 0.01
</span>            <span class="c1">//distance from rendered point to sample SDF for normal calculation</span>
            <span class="cp">#define NORMAL_EPSILON 0.01
</span>
            <span class="c1">//input data</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="c1">//data that goes from vertex to fragment shader</span>
            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span> <span class="c1">//position in clip space</span>
                <span class="n">float4</span> <span class="n">localPosition</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span> <span class="c1">//position in local space</span>
                <span class="n">float4</span> <span class="n">viewDirection</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span> <span class="c1">//view direction in local space (not normalized!)</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//position for rendering</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//save local position for origin</span>
                <span class="n">o</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">;</span>
                <span class="c1">//get camera position in local space</span>
                <span class="n">float4</span> <span class="n">objectSpaceCameraPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_WorldToObject</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
                <span class="c1">//get local view vector</span>
                <span class="n">o</span><span class="p">.</span><span class="n">viewDirection</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span> <span class="o">-</span> <span class="n">objectSpaceCameraPos</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>


            <span class="kt">float</span> <span class="n">scene</span><span class="p">(</span><span class="n">float3</span> <span class="n">pos</span><span class="p">){</span>
                <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">float3</span> <span class="n">normal</span><span class="p">(</span><span class="n">float3</span> <span class="n">pos</span><span class="p">){</span>
                <span class="c1">//determine change in signed distance</span>
                <span class="kt">float</span> <span class="n">changeX</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="kt">float</span> <span class="n">changeY</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="kt">float</span> <span class="n">changeZ</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">))</span> <span class="o">-</span> <span class="n">scene</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NORMAL_EPSILON</span><span class="p">));</span>
                <span class="c1">//construct normal vector</span>
                <span class="n">float3</span> <span class="n">surfaceNormal</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="n">changeX</span><span class="p">,</span> <span class="n">changeY</span><span class="p">,</span> <span class="n">changeZ</span><span class="p">);</span>
                <span class="c1">//convert normal vector into worldspace and make it uniform length</span>
                <span class="n">surfaceNormal</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">surfaceNormal</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">surfaceNormal</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">float4</span> <span class="n">lightColor</span><span class="p">(</span><span class="n">float3</span> <span class="n">position</span><span class="p">){</span>
                <span class="c1">//calculate needed surface and light data</span>
                <span class="n">float3</span> <span class="n">surfaceNormal</span> <span class="o">=</span> <span class="n">normal</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
                <span class="n">float3</span> <span class="n">lightDirection</span> <span class="o">=</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>

                <span class="c1">//calculate simple shading</span>
                <span class="kt">float</span> <span class="n">lightAngle</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">surfaceNormal</span><span class="p">,</span> <span class="n">lightDirection</span><span class="p">));</span>
                <span class="k">return</span> <span class="n">lightAngle</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">float4</span> <span class="n">material</span><span class="p">(</span><span class="n">float3</span> <span class="n">position</span><span class="p">){</span>
                <span class="c1">//get light color</span>
                <span class="n">float4</span> <span class="n">light</span> <span class="o">=</span> <span class="n">lightColor</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>

                <span class="c1">//combine base color and light color</span>
                <span class="n">float4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">_Color</span> <span class="o">*</span> <span class="n">light</span><span class="p">;</span>

                <span class="k">return</span> <span class="n">color</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
                <span class="c1">//ray information</span>
                <span class="n">float3</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">localPosition</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
                <span class="kt">float</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                
                <span class="c1">//tracing loop</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">MAX_STEPS</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">//get current location on ray</span>
                    <span class="n">float3</span> <span class="n">samplePoint</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">dir</span> <span class="o">*</span> <span class="n">progress</span><span class="p">;</span>
                    <span class="c1">//get distance to closest shape</span>
                    <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">samplePoint</span><span class="p">);</span>
                    <span class="c1">//return color if inside shape</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">THICKNESS</span><span class="p">){</span>
                        <span class="k">return</span> <span class="n">material</span><span class="p">(</span><span class="n">samplePoint</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="c1">//go forwards</span>
                    <span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span> <span class="o">+</span> <span class="n">distance</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">//discard pixel if no shape was hit</span>
                <span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


    <p>
        You can also find me on twitter at <a href="https://www.twitter.com/totallyRonja">@totallyRonja</a>. If you liked my tutorial and want to support me you can do that on Patreon (<a href="https://www.patreon.com/RonjaTutorials">patreon.com/RonjaTutorials</a>) or Ko-Fi (<a href="https://ko-fi.com/RonjaTutorials">ko-fi.com/RonjaTutorials</a>).
    </p>
  </div>

  
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ronja-tutorials.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  
</article>


      <!-- SVG icons from https://iconmonstr.com -->

      <!-- Twitter icon -->
      <span class="my-span-icon">
          <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>

        <!-- RSS icon -->
        
          <span class="my-span-icon">
            <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
            </a>
          </span>
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact ">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        
    </section>

    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-124040112-1', 'auto');
        ga('send', 'pageview');
      </script>
    
  </body>
</html>
