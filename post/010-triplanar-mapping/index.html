<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Triplanar Mapping | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and breaks when the surface we‚Äôre drawing isn‚Äôt oriented towards the direction we‚Äôre mapping from (up in the previous example). A way to improve automatic uv generation is that we do the mapping three times from different directions and blend between those three colors.
This tutorial will build upon the planar mapping shader which is a unlit shader, but you can use the technique with many shaders, including surface shaders.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
		<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
		<link rel="canonical" href="https://www.ronja-tutorials.com/post/010-triplanar-mapping/">

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/css/main.css">
    

    
      

    

    
    
    <meta property="og:title" content="Triplanar Mapping" />
<meta property="og:description" content="Summary I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and breaks when the surface we‚Äôre drawing isn‚Äôt oriented towards the direction we‚Äôre mapping from (up in the previous example). A way to improve automatic uv generation is that we do the mapping three times from different directions and blend between those three colors.
This tutorial will build upon the planar mapping shader which is a unlit shader, but you can use the technique with many shaders, including surface shaders." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/010-triplanar-mapping/" />
<meta property="article:published_time" content="2018-05-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-05-11T00:00:00+00:00" />
<meta itemprop="name" content="Triplanar Mapping">
<meta itemprop="description" content="Summary I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and breaks when the surface we‚Äôre drawing isn‚Äôt oriented towards the direction we‚Äôre mapping from (up in the previous example). A way to improve automatic uv generation is that we do the mapping three times from different directions and blend between those three colors.
This tutorial will build upon the planar mapping shader which is a unlit shader, but you can use the technique with many shaders, including surface shaders.">
<meta itemprop="datePublished" content="2018-05-11T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-05-11T00:00:00+00:00" />
<meta itemprop="wordCount" content="1579">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Triplanar Mapping"/>
<meta name="twitter:description" content="Summary I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and breaks when the surface we‚Äôre drawing isn‚Äôt oriented towards the direction we‚Äôre mapping from (up in the previous example). A way to improve automatic uv generation is that we do the mapping three times from different directions and blend between those three colors.
This tutorial will build upon the planar mapping shader which is a unlit shader, but you can use the technique with many shaders, including surface shaders."/>

	
		
		
		<script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      <h1 class="f1 athelas mt3 mb1">Triplanar Mapping</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-05-11T00:00:00Z">May 11, 2018</time>

      
      
		</header>
		
		<div style="margin-bottom: 70px;">
			<h3>Table Of Contents</h3>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#calculate-projection-planes">Calculate Projection Planes</a></li>
    <li><a href="#normals">Normals</a></li>
  </ul>
</nav>
		</div>

    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><div>
				
				<h2 id="summary">Summary <a href="#summary" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>I made a tutorial about planar mapping previously. The biggest disadvantage of the technique is that it only works from one direction and breaks when the surface we‚Äôre drawing isn‚Äôt oriented towards the direction we‚Äôre mapping from (up in the previous example). A way to improve automatic uv generation is that we do the mapping three times from different directions and blend between those three colors.</p>
<p>This tutorial will build upon the <a href="https://www.ronja-tutorials.com/post/008-planar-mapping/">planar mapping shader</a> which is a unlit shader, but you can use the technique with many shaders, including surface shaders.
<img src="/assets/images/posts/010/Result.gif" alt="Result"></p>
<h2 id="calculate-projection-planes">Calculate Projection Planes <a href="#calculate-projection-planes" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>To generate three different sets of UV coordinates, we start by changing the way we get the UV coordinates. Instead of returning the transformed uv coordinates from the vertex shader we return the world position and then generate the UV coordinates in the fragment shader.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">struct</span> v2f{
    float4 position <span style="color:#333">:</span> SV_POSITION;
    float3 worldPos <span style="color:#333">:</span> TEXCOORD0;
};

v2f vert(appdata v){
    v2f o;
    <span style="color:#888">//calculate the position in clip space to render the object</span>
    o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
    <span style="color:#888">//calculate world position of vertex</span>
    float4 worldPos <span style="color:#333">=</span> mul(unity_ObjectToWorld, v.vertex);
    o.worldPos <span style="color:#333">=</span> worldPos.xyz;
    <span style="color:#080;font-weight:bold">return</span> o;
}
</code></pre></div><p>We use transform tex to apply the tiling and offset of the texture like we‚Äôre used to. In my shader I use xy and zy so the world up axis is mapped to the y axis of the texture for both textures, not rotating them in relation to each other, but you can play around with the way use use those values (the way the top UVs are mapped is arbitrary).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//calculate UV coordinates for three projections</span>
    float2 uv_front <span style="color:#333">=</span> TRANSFORM_TEX(i.worldPos.xy, _MainTex);
    float2 uv_side <span style="color:#333">=</span> TRANSFORM_TEX(i.worldPos.zy, _MainTex);
    float2 uv_top <span style="color:#333">=</span> TRANSFORM_TEX(i.worldPos.xz, _MainTex);
</code></pre></div><p>After obtaining the correct coordinates, we read the texture at those coordinates, add the three colors and divide the result by 3 (adding three colors without dividing by the number of colors would just be very bright).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//read texture at uv position of the three projections</span>
fixed4 col_front <span style="color:#333">=</span> tex2D(_MainTex, uv_front);
fixed4 col_side <span style="color:#333">=</span> tex2D(_MainTex, uv_side);
fixed4 col_top <span style="color:#333">=</span> tex2D(_MainTex, uv_top);

<span style="color:#888">//combine the projected colors</span>
fixed4 col <span style="color:#333">=</span> (col_front <span style="color:#333">+</span> col_side <span style="color:#333">+</span> col_top) <span style="color:#333">/</span> <span style="color:#00d;font-weight:bold">3</span>;

<span style="color:#888">//multiply texture color with tint color</span>
col <span style="color:#333">*=</span> _Color;
<span style="color:#080;font-weight:bold">return</span> col;
</code></pre></div><p><img src="/assets/images/posts/010/AllSides.png" alt="Add projections from all sides together"></p>
<h2 id="normals">Normals <a href="#normals" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>Having done that our material looks really weird. That‚Äôs because we display the average of the three projections. To fix that we have to show different projections based on the direction the surface is facing. The facing direction of the surface is also called ‚Äúnormal‚Äù and it‚Äôs saved in the object files, just like the position of the vertices.</p>
<p>So what we do is get the normals in our input struct, convert them to worldspace normals in the vertex shader (because our projection is in worldspace, if we used object space projection we‚Äôd keep the normals in object space).</p>
<p>For the conversion of the normal from object space to world space, we have to multiply it with the inverse transposed matrix. It‚Äôs not important to understand how that works exactly (matrix multiplication is complicated), but I‚Äôd like to explain why we can‚Äôt just multiply it with the object to world matrix like we do with the position. The normals are orthogonal to the surface, so when we scale the surface only along the X axis and not the Y axis the surface gets steeper, but when we do the same to our normal, it also points more upwards than previously and isn‚Äôt orthogonal to the surface anymore. Instead we have to make the normal more flat the steeper the surface gets and the inverse transpose matrix does that for us. Then we also convert the matrix to a 3x3 matrix, discarding the parts that would move the normals. (we don‚Äôt want to move the normals because they represent directions instead of positions)</p>
<p>The way we use the inverse transpose object to world matrix is that we multiply the normal with the world to object matrix (previously we multiplied the matrix with the vector, order is important here).</p>
<p><img src="/assets/images/posts/010/NormalScaling.png" alt="Why we have to scale the normal with the inverse matrix instead of the regular one"></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">struct</span> appdata{
    float4 vertex <span style="color:#333">:</span> POSITION;
    float3 normal <span style="color:#333">:</span> NORMAL;
};

<span style="color:#080;font-weight:bold">struct</span> v2f{
    float4 position <span style="color:#333">:</span> SV_POSITION;
    float3 worldPos <span style="color:#333">:</span> TEXCOORD0;
    float3 normal <span style="color:#333">:</span> NORMAL;
};

v2f vert(appdata v){
    v2f o;
    <span style="color:#888">//calculate the position in clip space to render the object</span>
    o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
    <span style="color:#888">//calculate world position of vertex</span>
    float4 worldPos <span style="color:#333">=</span> mul(unity_ObjectToWorld, v.vertex);
    o.worldPos <span style="color:#333">=</span> worldPos.xyz;
    <span style="color:#888">//calculate world normal</span>
    float3 worldNormal <span style="color:#333">=</span> mul(v.normal, (float3x3)unity_WorldToObject);
    o.normal <span style="color:#333">=</span> normalize(worldNormal);
    <span style="color:#080;font-weight:bold">return</span> o;
}
</code></pre></div><p>To check our normals, we can now just return them in our fragment shader and see the different axis as colors.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#080;font-weight:bold">return</span> fixed4(i.normal.xyz, <span style="color:#00d;font-weight:bold">1</span>);
}
</code></pre></div><p><img src="/assets/images/posts/010/Normals.png" alt="The normals as colors"></p>
<p>To convert the normals to weights for the different projections we start by taking the absolute value of the normal. That‚Äôs because the normals go in the positive and negative directions. That‚Äôs also why in our debug view the ‚Äúbackside‚Äù of our object, where the axes go towards the negative direction, is black.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 weights <span style="color:#333">=</span> i.normal;
weights <span style="color:#333">=</span> abs(weights);
</code></pre></div><p>After that we can multiply the different projections with the weights, making them only appear on the side we‚Äôre projecting it on, not the others where the texture looks stretched. We multiply the projection from the xy plane to the z weight because towards that axis it doesn‚Äôt stetch and we do a smiliar thing to the other axes.</p>
<p>We also remove the division by 3 because we don‚Äôt add them all together anymore.</p>
<p><img src="/assets/images/posts/010/ZPlane.png" alt="Illustration of a plane based on asurface normal"></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//generate weights from world normals</span>
float3 weights <span style="color:#333">=</span> i.normal;
<span style="color:#888">//show texture on both sides of the object (positive and negative)</span>
weights <span style="color:#333">=</span> abs(weights);

<span style="color:#888">//combine weights with projected colors</span>
col_front <span style="color:#333">*=</span> weights.z;
col_side <span style="color:#333">*=</span> weights.x;
col_top <span style="color:#333">*=</span> weights.y;

<span style="color:#888">//combine the projected colors</span>
fixed4 col <span style="color:#333">=</span> col_front <span style="color:#333">+</span> col_side <span style="color:#333">+</span> col_top;

<span style="color:#888">//multiply texture color with tint color</span>
col <span style="color:#333">*=</span> _Color;
<span style="color:#080;font-weight:bold">return</span> col;
</code></pre></div><p><img src="/assets/images/posts/010/AddPlanes.jpg" alt="the planar projections added based on normals"></p>
<p>That‚Äôs way better already, but now we have the same problem again why we added the division by 3, the components of the normals add up to more than 3 sometimes, making the texture appear brighter than it should be. We can fix that by dividing it by the sum of it‚Äôs components, forcing it to add up to 1.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//make it so the sum of all components is 1</span>
weights <span style="color:#333">=</span> weights <span style="color:#333">/</span> (weights.x <span style="color:#333">+</span> weights.y <span style="color:#333">+</span> weights.z);
</code></pre></div><p><img src="/assets/images/posts/010/AddPlanesNormalized.jpg" alt="the planar projections added based on normals with normalized blend factors"></p>
<p>And with that we‚Äôre back to the expected brightness.</p>
<p>The last thing we add to this shader is the possibility to make the different directions more distinct, because right now the area where they blend into each other is still pretty big, making the colors look messy. To archieve that we add a new property for the sharpness of the blending. Then, before making the weights sum up to one, we calculate weights to the power of sharpness. Because we only operate in ranges from 0 to 1 that will lower the low values if the sharpness is high, but won‚Äôt change the high values by as much. We make the property of the type range to have a nice slider in the UI of the shader.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//...</span>

_Sharpness(<span style="color:#f00;background-color:#faa">&#34;</span>Blend Sharpness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">64</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>

<span style="color:#888">//...</span>

<span style="color:#080;font-weight:bold">float</span> _Sharpness;

<span style="color:#888">//...</span>

<span style="color:#888">//make the transition sharper</span>
weights <span style="color:#333">=</span> pow(weights, _sharpness)

<span style="color:#888">//...</span>
</code></pre></div><p><img src="/assets/images/posts/010/BlendSharpness.gif" alt="adjusting the blend sharpness"></p>
<p>Triplanar Mapping still isn‚Äôt perfect, it needs tiling textures to work, it breaks at surfaces that are exactly 45¬∞ and it‚Äôs obviously more expensive than a single texture sample (though not by that much).</p>
<p>You can use it in surface shaders for albedo, specular, etc. maps, but it doesn‚Äôt work perfectly for normalmaps without some changes I won‚Äôt go into here.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">010</span>_Triplanar_Mapping<span style="color:#f00;background-color:#faa">&#34;</span>{
	<span style="color:#888">//show values to edit in inspector</span>
	Properties{
		_Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
		_MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
		_Sharpness (<span style="color:#f00;background-color:#faa">&#34;</span>Blend sharpness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">64</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
	}

	SubShader{
		<span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
		Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

		Pass{
			CGPROGRAM

			<span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

			<span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
			<span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

			<span style="color:#888">//texture and transforms of the texture</span>
			<span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
			float4 _MainTex_ST;

			fixed4 _Color;
			<span style="color:#080;font-weight:bold">float</span> _Sharpness;

			<span style="color:#080;font-weight:bold">struct</span> appdata{
				float4 vertex <span style="color:#333">:</span> POSITION;
				float3 normal <span style="color:#333">:</span> NORMAL;
			};

			<span style="color:#080;font-weight:bold">struct</span> v2f{
				float4 position <span style="color:#333">:</span> SV_POSITION;
				float3 worldPos <span style="color:#333">:</span> TEXCOORD0;
				float3 normal <span style="color:#333">:</span> NORMAL;
			};

			v2f vert(appdata v){
				v2f o;
				<span style="color:#888">//calculate the position in clip space to render the object</span>
				o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
				<span style="color:#888">//calculate world position of vertex</span>
				float4 worldPos <span style="color:#333">=</span> mul(unity_ObjectToWorld, v.vertex);
				o.worldPos <span style="color:#333">=</span> worldPos.xyz;
				<span style="color:#888">//calculate world normal</span>
				float3 worldNormal <span style="color:#333">=</span> mul(v.normal, (float3x3)unity_WorldToObject);
				o.normal <span style="color:#333">=</span> normalize(worldNormal);
				<span style="color:#080;font-weight:bold">return</span> o;
			}

			fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
				<span style="color:#888">//calculate UV coordinates for three projections</span>
				float2 uv_front <span style="color:#333">=</span> TRANSFORM_TEX(i.worldPos.xy, _MainTex);
				float2 uv_side <span style="color:#333">=</span> TRANSFORM_TEX(i.worldPos.zy, _MainTex);
				float2 uv_top <span style="color:#333">=</span> TRANSFORM_TEX(i.worldPos.xz, _MainTex);
				
				<span style="color:#888">//read texture at uv position of the three projections</span>
				fixed4 col_front <span style="color:#333">=</span> tex2D(_MainTex, uv_front);
				fixed4 col_side <span style="color:#333">=</span> tex2D(_MainTex, uv_side);
				fixed4 col_top <span style="color:#333">=</span> tex2D(_MainTex, uv_top);

				<span style="color:#888">//generate weights from world normals</span>
				float3 weights <span style="color:#333">=</span> i.normal;
				<span style="color:#888">//show texture on both sides of the object (positive and negative)</span>
				weights <span style="color:#333">=</span> abs(weights);
				<span style="color:#888">//make the transition sharper</span>
				weights <span style="color:#333">=</span> pow(weights, _Sharpness);
				<span style="color:#888">//make it so the sum of all components is 1</span>
				weights <span style="color:#333">=</span> weights <span style="color:#333">/</span> (weights.x <span style="color:#333">+</span> weights.y <span style="color:#333">+</span> weights.z);

				<span style="color:#888">//combine weights with projected colors</span>
				col_front <span style="color:#333">*=</span> weights.z;
				col_side <span style="color:#333">*=</span> weights.x;
				col_top <span style="color:#333">*=</span> weights.y;

				<span style="color:#888">//combine the projected colors</span>
				fixed4 col <span style="color:#333">=</span> col_front <span style="color:#333">+</span> col_side <span style="color:#333">+</span> col_top;

				<span style="color:#888">//multiply texture color with tint color</span>
				col <span style="color:#333">*=</span> _Color;

				<span style="color:#080;font-weight:bold">return</span> col;
			}

			ENDCG
		}
	}
	FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#888">//fallback adds a shadow pass so we get shadows on other objects</span>
}
</code></pre></div><p>I hope this tutorial helped you understand how to do triplanar texture mapping in unity.</p>
<p>You can also find the source code for this shader here: <a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader</a></p>

			</div>I hope you enjoyed my tutorial ‚ú®. If you want to support me further feel free to follow me on <a href="https://twitter.com/totallyRonja">twitter</a>, 
			throw me a one-time donation via <a href="https://ko-fi.com/ronjatutorials">ko-fi</a> 
			or support me on <a href="https://www.patreon.com/RonjaTutorials">patreon</a> 
			(I try to put updates also there, but I fail most of the time, bear with me üíñ).<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
