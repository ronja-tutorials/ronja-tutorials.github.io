<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Checkerboard Pattern | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary For me, one of the most interresting things to do with shaders is procedural images. To get started with that, weâ€™re going to create a simple Checkerboard pattern.
This tutorial will build on the simple shader with only properties, but as always, you can also use the technique to generate colors in more complex shaders.
Stripes I will take the world position of the surface to generate the chessboard texture, that way we can later move and rotate the model around and the generated patterns will fit together.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
		<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
		<link rel="canonical" href="https://www.ronja-tutorials.com/post/011-chessboard/">

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/css/main.css">
    

    
      

    

    
    
    <meta property="og:title" content="Checkerboard Pattern" />
<meta property="og:description" content="Summary For me, one of the most interresting things to do with shaders is procedural images. To get started with that, weâ€™re going to create a simple Checkerboard pattern.
This tutorial will build on the simple shader with only properties, but as always, you can also use the technique to generate colors in more complex shaders.
Stripes I will take the world position of the surface to generate the chessboard texture, that way we can later move and rotate the model around and the generated patterns will fit together." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/011-chessboard/" />
<meta property="article:published_time" content="2018-05-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-05-18T00:00:00+00:00" />
<meta itemprop="name" content="Checkerboard Pattern">
<meta itemprop="description" content="Summary For me, one of the most interresting things to do with shaders is procedural images. To get started with that, weâ€™re going to create a simple Checkerboard pattern.
This tutorial will build on the simple shader with only properties, but as always, you can also use the technique to generate colors in more complex shaders.
Stripes I will take the world position of the surface to generate the chessboard texture, that way we can later move and rotate the model around and the generated patterns will fit together.">
<meta itemprop="datePublished" content="2018-05-18T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-05-18T00:00:00+00:00" />
<meta itemprop="wordCount" content="1390">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Checkerboard Pattern"/>
<meta name="twitter:description" content="Summary For me, one of the most interresting things to do with shaders is procedural images. To get started with that, weâ€™re going to create a simple Checkerboard pattern.
This tutorial will build on the simple shader with only properties, but as always, you can also use the technique to generate colors in more complex shaders.
Stripes I will take the world position of the surface to generate the chessboard texture, that way we can later move and rotate the model around and the generated patterns will fit together."/>

	
		
		
		<script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      <h1 class="f1 athelas mt3 mb1">Checkerboard Pattern</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-05-18T00:00:00Z">May 18, 2018</time>

      
      
		</header>
		
		<div style="margin-bottom: 70px;">
			<h3>Table Of Contents</h3>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#stripes">Stripes</a></li>
    <li><a href="#checkerboard-in-2d-and-3d">Checkerboard in 2d and 3d</a></li>
    <li><a href="#scaling">Scaling</a></li>
    <li><a href="#customizable-colors">Customizable Colors</a></li>
  </ul>
</nav>
		</div>

    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><div>
				
				<h2 id="summary">Summary <a href="#summary" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>For me, one of the most interresting things to do with shaders is procedural images. To get started with that, weâ€™re going to create a simple Checkerboard pattern.</p>
<p>This tutorial will build on the <a href="/basics.html">simple shader with only properties</a>, but as always, you can also use the technique to generate colors in more complex shaders.</p>
<p><img src="/assets/images/posts/011/Result.png" alt="Result of the tutorial"></p>
<h2 id="stripes">Stripes <a href="#stripes" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>I will take the world position of the surface to generate the chessboard texture, that way we can later move and rotate the model around and the generated patterns will fit together. If you want to pattern to move and rotate with the model, you can also use the object space coordinates (the ones from appdata, not multiplied with anything).</p>
<p>To use the worldposition in the fragment shader, we add the world position to the vertex to fragment struct and then generate the world position in the vertex shader and write it into the struct.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">struct</span> v2f{
    float4 position <span style="color:#333">:</span> SV_POSITION;
    float3 worldPos <span style="color:#333">:</span> TEXCOORD0;
}

v2f vert(appdata v){
    v2f o;
    <span style="color:#888">//calculate the position in clip space to render the object</span>
    o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
    <span style="color:#888">//calculate the position of the vertex in the world</span>
    o.worldPos <span style="color:#333">=</span> mul(unity_ObjectToWorld, v.vertex);
    <span style="color:#080;font-weight:bold">return</span> o;
}
</code></pre></div><p>Then in the fragment shader, we can start by first doing a 1D chess field, so just alternating black and white lines. To do that, we take one of the axis of the position and modify the value. We start by flooring it. That means itâ€™ll be the next smaller whole number. We do that to make sure we only have one color per unit.</p>
<p>Then we find out wether our field is a even or a odd one. To do that, we divide the value by two and take the fractional part (the part of the number after the dot). so now the even numbers are all 0(because after a division by 2 even numbers are still whole numbers, so their fractional part is 0) and all of the odd fields result in 0.5(because after a division by 2 odd numbers end up fractional, 1 becomes 0.5, 3 becomes 1.5â€¦). To make the odd numbers white instead of grey, we can then multiply our value by 2.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//add different dimensions</span>
    <span style="color:#080;font-weight:bold">float</span> chessboard <span style="color:#333">=</span> floor(i.worldPos.x);
    <span style="color:#888">//divide it by 2 and get the fractional part, resulting in a value of 0 for even and 0.5 for odd numbers.</span>
    chessboard <span style="color:#333">=</span> frac(chessboard <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>);
    <span style="color:#888">//multiply it by 2 to make odd values white instead of grey</span>
    chessboard <span style="color:#333">*=</span> <span style="color:#00d;font-weight:bold">2</span>;
    <span style="color:#080;font-weight:bold">return</span> chessboard;
}
</code></pre></div><p><img src="/assets/images/posts/011/1d.png" alt="stripes on a material"></p>
<h2 id="checkerboard-in-2d-and-3d">Checkerboard in 2d and 3d <a href="#checkerboard-in-2d-and-3d" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>Next, we make the pattern two dimensional. To do that we only have to add a additional axis to the value weâ€™re evaluating. Thatâ€™s because when we add one to our rows all of the even values become odd and the odd values become even. This is also the main reason why we floor our values. We easily could have made the pattern work in one dimension without flooring them, but this makes it easier to add more dimensions.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//add different dimensions</span>
    <span style="color:#080;font-weight:bold">float</span> chessboard <span style="color:#333">=</span> floor(i.worldPos.x) <span style="color:#333">+</span> floor(i.worldPos.y);
    <span style="color:#888">//divide it by 2 and get the fractional part, resulting in a value of 0 for even and 0.5 for odd numbers.</span>
    chessboard <span style="color:#333">=</span> frac(chessboard <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>);
    <span style="color:#888">//multiply it by 2 to make odd values white instead of grey</span>
    chessboard <span style="color:#333">*=</span> <span style="color:#00d;font-weight:bold">2</span>;
    <span style="color:#080;font-weight:bold">return</span> chessboard;
}
</code></pre></div><p><img src="/assets/images/posts/011/OddEvenPattern.png" alt="even and odd numbers on a 2d grid where the components are added"></p>
<p><img src="/assets/images/posts/011/2d.png" alt="checkerboard pattern on a material"></p>
<p>After that we can go even further and add the third dimension in the same way as we added the second.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//add different dimensions</span>
    <span style="color:#080;font-weight:bold">float</span> chessboard <span style="color:#333">=</span> floor(i.worldPos.x) <span style="color:#333">+</span> floor(i.worldPos.y) <span style="color:#333">+</span> floor(i.worldPos.z);
    <span style="color:#888">//divide it by 2 and get the fractional part, resulting in a value of 0 for even and 0.5 for odd numbers.</span>
    chessboard <span style="color:#333">=</span> frac(chessboard <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>);
    <span style="color:#888">//multiply it by 2 to make odd values white instead of grey</span>
    chessboard <span style="color:#333">*=</span> <span style="color:#00d;font-weight:bold">2</span>;
    <span style="color:#080;font-weight:bold">return</span> chessboard;
}
</code></pre></div><p><img src="/assets/images/posts/011/3d.png" alt="checkerboard pattern on a sphere"></p>
<h2 id="scaling">Scaling <a href="#scaling" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>Next Iâ€™d like to add the ability to make the pattern bigger or smaller. For that, we add a new property for the scale of the pattern. We divide the position by the scale before we do anything else with it, that way, if the scale is smaller than one, the pattern is generated as if the object is bigger than it is and as such it has more pattern density per surface area.</p>
<p>Another small change I made is that we now use floor on the whole vector instead of the components separately. That doesnâ€™t change anything, I just think itâ€™s nicer to read.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//...</span>

<span style="color:#888">//show values to edit in inspector</span>
Properties{
    _Scale (<span style="color:#f00;background-color:#faa">&#34;</span>Pattern Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">10</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
}

<span style="color:#888">//...</span>

<span style="color:#080;font-weight:bold">float</span> _Scale;

<span style="color:#888">//...</span>

fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//scale the position to adjust for shader input and floor the values so we have whole numbers</span>
    float3 adjustedWorldPos <span style="color:#333">=</span> floor(i.worldPos <span style="color:#333">/</span> _Scale);
    <span style="color:#888">//add different dimensions</span>
    <span style="color:#080;font-weight:bold">float</span> chessboard <span style="color:#333">=</span> adjustedWorldPos.x <span style="color:#333">+</span> adjustedWorldPos.y <span style="color:#333">+</span> adjustedWorldPos.z;
    <span style="color:#888">//divide it by 2 and get the fractional part, resulting in a value of 0 for even and 0.5 for off numbers.</span>
    chessboard <span style="color:#333">=</span> frac(chessboard <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>);
    <span style="color:#888">//multiply it by 2 to make odd values white instead of grey</span>
    chessboard <span style="color:#333">*=</span> <span style="color:#00d;font-weight:bold">2</span>;
    <span style="color:#080;font-weight:bold">return</span> chessboard;
}

<span style="color:#888">//...</span>
</code></pre></div><p><img src="/assets/images/posts/011/Scaling.gif" alt="scaling checkerboard bigger and smaller"></p>
<h2 id="customizable-colors">Customizable Colors <a href="#customizable-colors" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>Finally Iâ€™d like to add the possibility to add Colors to the Pattern, One for the even areas, one for the odd. We add two new Properties and the matching values for those colors to the shader.</p>
<p>Then at the end of our fragment shader, we do a linear interpolation between the two colors. Since we only have two different values (zero and one), we can expect the interpolation to return either the color it interpolates from(for a input of 0) or the color it interpolates towards(for a input of 1). (If youâ€™re confused by the interpolation, I explain it more thouroghly in <a href="https://www.ronja-tutorials.com/post/009-interpolating-colors/">another tutorial</a>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//...</span>

<span style="color:#888">//show values to edit in inspector</span>
Properties{
    _Scale (<span style="color:#f00;background-color:#faa">&#34;</span>Pattern Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">10</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
    _EvenColor(<span style="color:#f00;background-color:#faa">&#34;</span>Color <span style="color:#00d;font-weight:bold">1</span><span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>)
    _OddColor(<span style="color:#f00;background-color:#faa">&#34;</span>Color <span style="color:#00d;font-weight:bold">2</span><span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>)
}

<span style="color:#888">//...</span>

float4 _EvenColor;
float4 _OddColor;

<span style="color:#888">//...</span>

fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//scale the position to adjust for shader input and floor the values so we have whole numbers</span>
    float3 adjustedWorldPos <span style="color:#333">=</span> floor(i.worldPos <span style="color:#333">/</span> _Scale);
    <span style="color:#888">//add different dimensions</span>
    <span style="color:#080;font-weight:bold">float</span> chessboard <span style="color:#333">=</span> adjustedWorldPos.x <span style="color:#333">+</span> adjustedWorldPos.y <span style="color:#333">+</span> adjustedWorldPos.z;
    <span style="color:#888">//divide it by 2 and get the fractional part, resulting in a value of 0 for even and 0.5 for off numbers.</span>
    chessboard <span style="color:#333">=</span> frac(chessboard <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>);
    <span style="color:#888">//multiply it by 2 to make odd values white instead of grey</span>
    chessboard <span style="color:#333">*=</span> <span style="color:#00d;font-weight:bold">2</span>;

    <span style="color:#888">//interpolate between color for even fields (0) and color for odd fields (1)</span>
    float4 color <span style="color:#333">=</span> lerp(_EvenColor, _OddColor, chessboard);
    <span style="color:#080;font-weight:bold">return</span> color;
}

<span style="color:#888">//...</span>
</code></pre></div><p><img src="/assets/images/posts/011/colors.png" alt="colorful checkerboard pattern on a material"></p>
<p>The complete shader for interpolating generating a checkerboard pattern on a surface should now look like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">011</span>_Chessboard<span style="color:#f00;background-color:#faa">&#34;</span>
{
    <span style="color:#888">//show values to edit in inspector</span>
    Properties{
        _Scale (<span style="color:#f00;background-color:#faa">&#34;</span>Pattern Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">10</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
        _EvenColor(<span style="color:#f00;background-color:#faa">&#34;</span>Color <span style="color:#00d;font-weight:bold">1</span><span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>)
        _OddColor(<span style="color:#f00;background-color:#faa">&#34;</span>Color <span style="color:#00d;font-weight:bold">2</span><span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>)
    }

    SubShader{
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}


        Pass{
            CGPROGRAM
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            <span style="color:#080;font-weight:bold">float</span> _Scale;

            float4 _EvenColor;
            float4 _OddColor;

            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
            };

            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
                float3 worldPos <span style="color:#333">:</span> TEXCOORD0;
            };

            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//calculate the position in clip space to render the object</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
                <span style="color:#888">//calculate the position of the vertex in the world</span>
                o.worldPos <span style="color:#333">=</span> mul(unity_ObjectToWorld, v.vertex);
                <span style="color:#080;font-weight:bold">return</span> o;
            }

            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                <span style="color:#888">//scale the position to adjust for shader input and floor the values so we have whole numbers</span>
                float3 adjustedWorldPos <span style="color:#333">=</span> floor(i.worldPos <span style="color:#333">/</span> _Scale);
                <span style="color:#888">//add different dimensions</span>
                <span style="color:#080;font-weight:bold">float</span> chessboard <span style="color:#333">=</span> adjustedWorldPos.x <span style="color:#333">+</span> adjustedWorldPos.y <span style="color:#333">+</span> adjustedWorldPos.z;
                <span style="color:#888">//divide it by 2 and get the fractional part, resulting in a value of 0 for even and 0.5 for off numbers.</span>
                chessboard <span style="color:#333">=</span> frac(chessboard <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>);
                <span style="color:#888">//multiply it by 2 to make odd values white instead of grey</span>
                chessboard <span style="color:#333">*=</span> <span style="color:#00d;font-weight:bold">2</span>;

                <span style="color:#888">//interpolate between color for even fields (0) and color for odd fields (1)</span>
                float4 color <span style="color:#333">=</span> lerp(_EvenColor, _OddColor, chessboard);
                <span style="color:#080;font-weight:bold">return</span> color;
            }

            ENDCG
        }
    }
    FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#888">//fallback adds a shadow pass so we get shadows on other objects</span>
}
</code></pre></div><p>I hope you liked making this simple chess board shader and it helped you understand how to create patterns in shaders with simple math operations.</p>
<p>You can also find the source code for this shader here: <a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/011_ChessBoard/Chessboard.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/011_ChessBoard/Chessboard.shader</a></p>

			</div>I hope you enjoyed my tutorial âœ¨. If you want to support me further feel free to follow me on <a href="https://twitter.com/totallyRonja">twitter</a>, 
			throw me a one-time donation via <a href="https://ko-fi.com/ronjatutorials">ko-fi</a> 
			or support me on <a href="https://www.patreon.com/RonjaTutorials">patreon</a> 
			(I try to put updates also there, but I fail most of the time, bear with me ðŸ’–).<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
