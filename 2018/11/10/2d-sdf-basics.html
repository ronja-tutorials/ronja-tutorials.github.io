<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>2D Signed Distance Field Basics</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="Ronja Böhringer">

<meta name="description" content="So far we mostly used polygonal meshes to represent shapes. While meshes are the easiest to render and the most versatile, there are other ways to re..." />





<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="2D Signed Distance Field Basics">
<meta itemprop="description" content="So far we mostly used polygonal meshes to represent shapes. While meshes are the easiest to render and the most versatile, there are other ways to re...">

  <meta itemprop="image" content="https://www.ronja-tutorials.com/assets/images/posts/034/Result.gif">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="2D Signed Distance Field Basics">
<meta name="twitter:description" content="So far we mostly used polygonal meshes to represent shapes. While meshes are the easiest to render and the most versatile, there are other ways to re...">


  <meta name="twitter:creator" content="@TotallyRonja">


<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="https://www.ronja-tutorials.com/assets/images/posts/034/Result.gif">
  <meta property="twitter:image" content="https://www.ronja-tutorials.com/assets/images/posts/034/Result.gif">

<meta property="twitter:url" content="https://www.ronja-tutorials.com/2018/11/10/2d-sdf-basics.html">

<!-- Open Graph data -->
<meta property="og:title" content="2D Signed Distance Field Basics" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/2018/11/10/2d-sdf-basics.html" />

  <meta property="og:image" content="https://www.ronja-tutorials.com/assets/images/posts/034/Result.gif" />

<meta property="og:description" content="So far we mostly used polygonal meshes to represent shapes. While meshes are the easiest to render and the most versatile, there are other ways to re..." />
<meta property="og:site_name" content="Ronja's Shader Tutorials" />

  <meta property="article:published_time" content="2018-11-10T00:00:00+01:00" />














  





  




    

    <link rel="canonical" href="https://www.ronja-tutorials.com/2018/11/10/2d-sdf-basics.html">

    

    <!-- <link rel="shortcut icon" href="https://www.ronja-tutorials.com/favicon.ico"> -->
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">Ronja&#39;s Shader Tutorials</a>
    
    <!-- SVG icons from https://iconmonstr.com -->

    <!-- Twitter icon -->
    <span class="my-span-icon">
        <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
          <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
        </a>
      </span>

      <!-- RSS icon -->
      
        <span class="my-span-icon">
          <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
          </a>
        </span>
      
      <!-- Contact icon -->
      
      
        <span class="my-span-icon">
          <a href="/about.html" aria-label="Contact" title="Contact ">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
          </a>
        </span>
      

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">2D Signed Distance Field Basics</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2018-11-10T00:00:00+01:00" itemprop="datePublished">
          
          Nov 10, 2018
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ronja Böhringer</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">2D Signed Distance Field Basics</h1>
    <p class="post-meta">
      <time datetime="2018-11-10T00:00:00+01:00" itemprop="datePublished">
        
        Nov 10, 2018
      </time>
      </p>
  </header> -->

  
<ul>
  <li><a href="#base-setup">Base Setup</a></li>
  <li><a href="#circle">Circle</a></li>
  <li><a href="#moving">Moving</a></li>
  <li><a href="#rectangle">Rectangle</a></li>
  <li><a href="#rotating">Rotating</a></li>
  <li><a href="#scaling">Scaling</a></li>
  <li><a href="#visualisation">Visualisation</a>
    <ul>
      <li><a href="#hard-shape">Hard Shape</a></li>
      <li><a href="#height-lines">Height Lines</a></li>
    </ul>
  </li>
  <li><a href="#source">Source</a>
    <ul>
      <li><a href="#2d-sdf-functions">2d SDF Functions</a></li>
      <li><a href="#circle-example">Circle Example</a></li>
      <li><a href="#rectangle-example">Rectangle Example</a></li>
      <li><a href="#cutoff">Cutoff</a></li>
      <li><a href="#distance-lines">Distance Lines</a></li>
    </ul>
  </li>
</ul>

  <div itemprop="articleBody">
    <p>So far we mostly used polygonal meshes to represent shapes. While meshes are the easiest to render and the most versatile, there are other ways to represent shapes in 2d and 3d. One way which is used frequently is signed distance fields. Signed distance fields allow for cheaper raytracing, smoothly letting different shapes flow into each other and saving lower resolution textures for higher quality images.</p>

<p>We’re going to start by generating signed distance fields with functions in 2 dimensions, but later continue by generating and using them in 3d. I’m going to use the worldspace coordinates to make everything as independent from scaling and uv coordinates as possible, so if you’re unsure how that works, look at <a href="/2018/04/23/planar-mapping.html">this tutorial about planar mapping</a> which explains what’s happening.</p>

<p><img src="/assets/images/posts/034/Result.gif" alt="" /></p>

<h2 id="base-setup">Base Setup</h2>

<p>From the base of the planar mapping shader we throw out the properties for now because we’ll do the technical base for now. Then we’ll write the world position to the vertex to fragment struct directly instead of transforming it to the uvs first. As a last point for preparation we’ll write a new function which will calculate the scene and return the distance to the nearest surface. Then we’ll call the function and use the result as the color.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/034_2D_SDF_Basics"</span><span class="p">{</span>
    <span class="n">SubShader</span><span class="p">{</span>
        <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">CGPROGRAM</span>

            <span class="cp">#include "UnityCG.cginc"
</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//calculate the position in clip space to render the object</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//calculate world position of vertex</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="n">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// calculate distance to nearest surface</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
                <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Standard"</span> <span class="c1">//fallback adds a shadow pass so we get shadows on other objects</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I’ll write all of the functions we write for signed distance fields in their own file, so we can easily reuse them later. For that we create a new file. In it we add include guards by first checking if a preprocessor varible isn’t defined yet, if it isn’t we define it and end the if condition after the functions we want to include. The advantage of adding this is that if we include the file twice (for example if we include two different files which both have functions we want and they both include the same file) it doesn’t break the shader. If you’re sure that’s never going to happen, feel free to not add them.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in include file</span>

<span class="c1">// include guards that keep the functions from being included more than once</span>
<span class="cp">#ifndef SDF_2D
#define SDF_2D
</span>
<span class="c1">// functions</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>As long as the include file in the same directory as the main shader, we can then simply include it with a pragma statement.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in main shader</span>

<span class="cp">#include "2D_SDF.cginc"
</span></code></pre></div></div>

<p>With this we just see a black surface on our rendered surface and are ready to display the signed distance on it.</p>

<p><img src="/assets/images/posts/034/NoSdf.png" alt="" /></p>

<h2 id="circle">Circle</h2>

<p>The simplest signed distance field function is the one for a circle. The function will only take a sample position and a radius of the circle. We start by simply taking the length of the sample position vector. With this we have a point at the (0, 0) position, which is the same as a circle with the radius of 0.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">circle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We then call the circle function in the scene function and return the distance it returns.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/Dot.png" alt="" /></p>

<p>Then we include the radius into the calculation. A important thing about signed distance functions is that when inside a object we get the negative distance to the surface (that’s what the “signed” in signed distance field stands for). To grow the circle to the radius we specify we simply subtract the radius from the length. This way the surface, which is everywhere where the function returns 0, moves outward the higher it is. What’s 2 units away from the surface for a circle with the size of 0 is only 1 unit away for a circle with the radius of 1 and is 1 unit inside the circle (value of -1) for a circle with a radius of 3;</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">circle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">)</span> <span class="o">-</span> <span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/Circle.png" alt="" /></p>

<p>Now the only thing we can’t do is to move the circle away from the center. To fix that we can either add a new argument to the circle function to calculate the distance between the sample position and the circle center and subtract the radius from that to define our circle. Or we can redefine the origin by moving the space of the sample point and then get the circle in that space. The later option seems a lot more complex, but because moving things is a operation we want to use on all shapes it’s a lot more flexible and is the way I’m going to explain here.</p>

<h2 id="moving">Moving</h2>

<p>“Transforming the space of a point” sounds a lot more scary than it is. It means that we pass the point into a function and the function changes it so we can still use it afterwards. In the case of translation we simply subtract the offset from the point. The reason we subtract the position when we want to move the shapes in the positive direction is that the shapes we render in a space move in the opposite direction than we move the space into.</p>

<p>For example if we want to draw a sphere at the position <code class="language-plaintext highlighter-rouge">(3, 4)</code> we have to change the space so <code class="language-plaintext highlighter-rouge">(3, 4)</code> becomes <code class="language-plaintext highlighter-rouge">(0, 0)</code> and the operation to do that is to subtract <code class="language-plaintext highlighter-rouge">(3, 4)</code>. Now if we draw a sphere around the NEW origin it’s at the OLD <code class="language-plaintext highlighter-rouge">(3, 4)</code> point.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in sdf functions include file</span>

<span class="n">float2</span> <span class="nf">translate</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="n">float2</span> <span class="n">offset</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">samplePosition</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/TranslatedCircle.png" alt="" /></p>

<h2 id="rectangle">Rectangle</h2>

<p>Another simple shape is a rectangle. We start by seeing the components independently. First we get the distance from the center by taking the absolute value. Then, similarly to the circle, we subtract the half size (which is basically like the radius for rectangles). For simply showing how the result looks like we’ll then return one of the components for now.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">rectangle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="n">float2</span> <span class="n">halfSize</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">componentWiseEdgeDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">)</span> <span class="o">-</span> <span class="n">halfSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">componentWiseEdgeDistance</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/RectangleXDistance.png" alt="" /></p>

<p>We can now get a cheap version of a rectangle by simply returning the bigger component of the 2. This works for many cases, but is wrong because it will not show the correct distance around the corners.</p>

<p><img src="/assets/images/posts/034/CheapRectangle.png" alt="" /></p>

<p>We can get the correct values for the rectangle outside of the shape by first taking the maximum between the edge distances and 0 and then taking the length of that.</p>

<p>If we wouldn’t limit the distance to 0 at the lower bound we would just calculate the distance to the corners (where the edgeDistances are <code class="language-plaintext highlighter-rouge">(0, 0)</code>), but this way the coordinates between the corners don’t go below 0 so it uses the whole edge. The downside of this is that it uses 0 as the distance from the edge for the whole inside of the shape.</p>

<p>The fix to the distance being 0 on the inside of the shape is to generate the inside distance by simply using the formula for the cheap rectangle (taking the maximum value between x and y component) and then ensuring that it’s never above 0 by taking the minimum value between it and 0. Then we can add the outside distance that’s never below 0 and the inside distance that’s never above 0 to get the complete distance function.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">rectangle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="n">float2</span> <span class="n">halfSize</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">componentWiseEdgeDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">)</span> <span class="o">-</span> <span class="n">halfSize</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">outsideDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">componentWiseEdgeDistance</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">insideDistance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">componentWiseEdgeDistance</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">componentWiseEdgeDistance</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">outsideDistance</span> <span class="o">+</span> <span class="n">insideDistance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Because we wrote the translation function in a flexible way previously we can now also use it to move the rectangle whereever we want it’s center to be.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/Rectangle.png" alt="" /></p>

<h2 id="rotating">Rotating</h2>

<p>Rotating shapes works similarly to moving them. We rotate the coordinate in the opposite direction before calculating the distance to the shape. To make rotations as easy to understand as possible, we multiply the rotation by 2 times pi to get the angle in radians. This way the rotation we pass the function is in rotations, 0.25 is a quarter rotation, 0.5 is half a rotation and 1 is a full rotation (Feel free to convert in another way if that comes more natural to you). Then we also invert it because we have to rotate the position in the inverse direction as the direction we want to rotate the shape in for the same reason we move the position into the negative direction to move the object into the positive direction for the translation.</p>

<p>To calculate the rotated coordinates we first calculate the sine and cosine based on our angle. Hlsl provides the sincos function which calculates both of those values quicker than if we would calculate them independently.</p>

<p>Then we build a new vector, for the x component we use the original x component multiplied by the cosine and the y component multiplied by the sine. We can easily remember this by remembering that the cosine of 0 is 1 and with a rotation of 0 we want the x component of the new vector to be exactly the same as before (multiplying it by 1). The y part that points upwards previously, not contributing anything to the x component of the vector gets rotated to the right, starting at 0 and becoming bigger at first, so that’s exactly the motion a sine describes.</p>

<p>For the y component of the new vector we multiply the cosine with the y component of the old vector and subtract the sine multiplied with the old x comonent. To understand why we subtract here instead of adding the sine multiplied with the x component it’s best to imagine how how a <code class="language-plaintext highlighter-rouge">(1, 0)</code> vector changes when it rotates clockwise. The y component of the result starts at 0 and then goes down below 0. That’s exactly the opposite behaviour of what a sine does, that’s why we invert it.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float2</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rotation</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">rotation</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">sine</span><span class="p">,</span> <span class="n">cosine</span><span class="p">;</span>
    <span class="n">sincos</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">sine</span><span class="p">,</span> <span class="n">cosine</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">float2</span><span class="p">(</span><span class="n">cosine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cosine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now that we wrote the rotation method we can use it in combination with the translation to make the shape move and rotate.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">_Time</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/RotateScene.gif" alt="" /></p>

<p>In this case we first rotate the object around the center of the whole scene, so the translation is also affected by that rotation. To rotate the shape around it’s own center we first have to move it and then rotate it. With this corrected order we made the center of the shape the center of our coordinate system by the time we rotate it.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">_Time</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/RotateShape.gif" alt="" /></p>

<h2 id="scaling">Scaling</h2>

<p>Scaling works in a similar way to the other ways of transforming shapes. We divide the coordinates by the scale and by drawing the shape in a scaled down space, they look bigger in the base coordinate system.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float2</span> <span class="nf">scale</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">samplePosition</span> <span class="o">/</span> <span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="p">.</span><span class="mi">125</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">pulseScale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">_Time</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14</span><span class="p">);</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">pulseScale</span><span class="p">);</span> 
    <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/ScaleDistance.gif" alt="" /></p>

<p>While this scales the shape property, it also scales the distance. The main advantage of a signed distance field is that we always know the distance to the nearest surface, but this destroys this property completely. We can fix it easily though by multiplying the distance field we get from the signed distance function (<code class="language-plaintext highlighter-rouge">rectangle</code> in this case) with the scale. This is also the reason why we can’t easily scale the shape non-uniformly (different scale for x and y axis).</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="p">.</span><span class="mi">125</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">pulseScale</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">_Time</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14</span><span class="p">);</span>
    <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">pulseScale</span><span class="p">);</span> 
    <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">pulseScale</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/ScaleShape.gif" alt="" /></p>

<h2 id="visualisation">Visualisation</h2>

<p>Signed distance fields can be used for a lot of things, for example shadows, 3d scene rendering, physics and text rendering. But we don’t want to get into too complex stuff right now, so I’ll just explain two techniques of visualising them. One a hard shape with antialiasing and the other one renders lines based on the distance.</p>

<h3 id="hard-shape">Hard Shape</h3>

<p>This is a method similar to what’s often used in text rendering and produces a clean shape. If we don’t generate the distance field from a function and instead read it from a texture instead this allows us to use textures with way less resolution than usual and still have a nice result. TextMesh Pro uses this technique for text rendering.</p>

<p>For this technique we use the fact that the data in signed distance fields is continuous and we know the cutoff point. We start by calculating how much the distance field changes to the next pixel. This should be the same amount as the length of the change of the coordinates, but it’s easier and more reliable to evaluate the signed distance.</p>

<p>After we have the change in distance, we can do a smoothstep from half the change in distance to minus plus half the change in distance. That will do a simple cutoff around 0, but with antialiasing. We can then use this antialiased value for whatever we binary value we need. In this example I’m going to change the shader to a transparent shader and use it for the alpha channel. The reason why we do the smoothstep from the positive to the negative value is that we want the negative value of the distance field to be visible. And if you don’t completely understand how the transparent rendering works here, I recommend you read <a href="/2018/04/06/simple-transparency.html">this tutorial</a> I made about transparent rendering.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//properties</span>
<span class="n">Properties</span><span class="p">{</span>
    <span class="n">_Color</span><span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in subshader outside of pass</span>
<span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Transparent"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Transparent"</span><span class="p">}</span>

<span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>
<span class="n">ZWrite</span> <span class="n">Off</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">distanceChange</span> <span class="o">=</span> <span class="n">fwidth</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">antialiasedCutoff</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">distanceChange</span><span class="p">,</span> <span class="o">-</span><span class="n">distanceChange</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
    <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">_Color</span><span class="p">,</span> <span class="n">antialiasedCutoff</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/Cutoff.gif" alt="" /></p>

<h3 id="height-lines">Height Lines</h3>

<p>Another common techique of visualising distance fields is to show the distances as lines. In our implementation I’m going to add thick lines and a few smaller ones inbetween. I’m also going to tint the inside and outside of the shape in different colors to make clear where the object is.</p>

<p>We start by showing the difference between the inside and outside of the shape. The colors will be adjustable in the material, so we add new properties as well as shader variables for the inner and outer color of the shape.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Properties</span><span class="p">{</span>
    <span class="n">_InsideColor</span><span class="p">(</span><span class="s">"Inside Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">_OutsideColor</span><span class="p">(</span><span class="s">"Outside Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//global shader variables</span>

<span class="n">float4</span> <span class="n">_InsideColor</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">_OutsideColor</span><span class="p">;</span>
</code></pre></div></div>

<p>Then in the fragment shader we check whether the pixel we’re rendering is inside or outside the shape by comparing the signed distance to 0 with the <code class="language-plaintext highlighter-rouge">step</code> function. We use this variable to interpolate from the inner to the outer color and render it to the screen.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
    <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">_InsideColor</span><span class="p">,</span> <span class="n">_OutsideColor</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dist</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/InOut.gif" alt="" /></p>

<p>To render the lines we first specify how often we render the lines and how thick they are with properties and corresponding shader variables.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Properties</span>
<span class="n">_LineDistance</span><span class="p">(</span><span class="s">"Mayor Line Distance"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_LineThickness</span><span class="p">(</span><span class="s">"Mayor Line Thickness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//shader variables</span>
<span class="kt">float</span> <span class="n">_LineDistance</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_LineThickness</span><span class="p">;</span>
</code></pre></div></div>

<p>Then to render the lines, we start by calculating the change in distance to use it for antialiasing later. We also already divide it by 2 because we will add half and subtract half of it later to cover a range of the change of 1 pixel.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">distanceChange</span> <span class="o">=</span> <span class="n">fwidth</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
</code></pre></div></div>

<p>Then we take the distance and transform it in a way to make it have similar behaviour at repeating points. To do this we first divide it by the distance between lines, this way we don’t have full numbers every 1 step, instead we have full numbers based on the distance we set.</p>

<p>Then we add 0.5 to the number, take the fractional part and subtract 0.5 again. The fractional part and the subtraction are there to make the line go through zero in a repeating pattern. The reason we add 0.5 before taking the fractional part is to counteract the subtraction of 0.5 later - the offset makes it so the values where our graph is 0 are at 0, 1, 2, etc.. and not 0.5, 1.5, etc… .</p>

<p>The last steps we use to transform the value are to take the absolute value and multiply it by the distance between lines again. The absolute value makes the areas before and after the line points look the same which makes the cutoff for the lines easier to make. The last operation where we multiply the value by the distance between lines again is to counteract the division at the start of the equation, with it the change in the value is the same as at the beginning again and the change in distance we calculated earlier is still valid.</p>

<p><img src="/assets/images/posts/034/LinesGraph.png" alt="" /></p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">majorLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">_LineDistance</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LineDistance</span><span class="p">;</span>
</code></pre></div></div>

<p>Now that we calculated the distance to the lines based on the distance to the shape we can draw the lines. We do a smoothstep from the linethickness minus half of the distance change to the linethickness plus half the change in distance and use the line distance we just calculated as the value to compare to. After we have calculated this value we multiply it with the color to make black lines (you could also lerp to another color if you want different colored lines).</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
    <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">_InsideColor</span><span class="p">,</span> <span class="n">_OutsideColor</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dist</span><span class="p">));</span>

    <span class="kt">float</span> <span class="n">distanceChange</span> <span class="o">=</span> <span class="n">fwidth</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">majorLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">_LineDistance</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LineDistance</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">majorLines</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">_LineThickness</span> <span class="o">-</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">_LineThickness</span> <span class="o">+</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">majorLineDistance</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">col</span> <span class="o">*</span> <span class="n">majorLines</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/MajorLines.gif" alt="" /></p>

<p>The way we implement the sublines between the thick ones is similar, we add a property to specify how many thin lines are inbetween every thick one and then do the same thing we did with the thick lines, but as the distance between thin lines we divide the distance between thick lines with the amount of thin lines inbetween. We’ll also make the thin line amount an <code class="language-plaintext highlighter-rouge">IntRange</code>, this way we can only assign it whole values and don’t get thin lines that don’t match the thicker ones. After we have calculated the thin lines we multiply them into the color just like the thick ones.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//properties</span>
<span class="p">[</span><span class="n">IntRange</span><span class="p">]</span><span class="n">_SubLines</span><span class="p">(</span><span class="s">"Lines between major lines"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">_SubLineThickness</span><span class="p">(</span><span class="s">"Thickness of inbetween lines"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">01</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//shader variables</span>
<span class="kt">float</span> <span class="n">_SubLines</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">_SubLineThickness</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
    <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">_InsideColor</span><span class="p">,</span> <span class="n">_OutsideColor</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dist</span><span class="p">));</span>

    <span class="kt">float</span> <span class="n">distanceChange</span> <span class="o">=</span> <span class="n">fwidth</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">majorLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">_LineDistance</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LineDistance</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">majorLines</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">_LineThickness</span> <span class="o">-</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">_LineThickness</span> <span class="o">+</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">majorLineDistance</span><span class="p">);</span>

    <span class="kt">float</span> <span class="n">distanceBetweenSubLines</span> <span class="o">=</span> <span class="n">_LineDistance</span> <span class="o">/</span> <span class="n">_SubLines</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">subLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">distanceBetweenSubLines</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">distanceBetweenSubLines</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">subLines</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">_SubLineThickness</span> <span class="o">-</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">_SubLineThickness</span> <span class="o">+</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">subLineDistance</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">col</span> <span class="o">*</span> <span class="n">majorLines</span> <span class="o">*</span> <span class="n">subLines</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/034/Result.gif" alt="" /></p>

<h2 id="source">Source</h2>

<h3 id="2d-sdf-functions">2d SDF Functions</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/2D_SDF.cginc">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/2D_SDF.cginc</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef SDF_2D
#define SDF_2D
</span>
<span class="n">float2</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rotation</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">rotation</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">sine</span><span class="p">,</span> <span class="n">cosine</span><span class="p">;</span>
    <span class="n">sincos</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">sine</span><span class="p">,</span> <span class="n">cosine</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">float2</span><span class="p">(</span><span class="n">cosine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cosine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float2</span> <span class="nf">translate</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="n">float2</span> <span class="n">offset</span><span class="p">){</span>
    <span class="c1">//move samplepoint in the opposite direction that we want to move shapes in</span>
    <span class="k">return</span> <span class="n">samplePosition</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float2</span> <span class="nf">scale</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">samplePosition</span> <span class="o">/</span> <span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">circle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="c1">//get distance from center and grow it according to radius</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">)</span> <span class="o">-</span> <span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">rectangle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="n">float2</span> <span class="n">halfSize</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">componentWiseEdgeDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">)</span> <span class="o">-</span> <span class="n">halfSize</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">outsideDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">componentWiseEdgeDistance</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">insideDistance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">componentWiseEdgeDistance</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">componentWiseEdgeDistance</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">outsideDistance</span> <span class="o">+</span> <span class="n">insideDistance</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif
</span></code></pre></div></div>

<h3 id="circle-example">Circle Example</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Circle.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Circle.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/034_2D_SDF_Basics/Circle"</span><span class="p">{</span>
    <span class="n">SubShader</span><span class="p">{</span>
        <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">CGPROGRAM</span>

            <span class="cp">#include "UnityCG.cginc"
</span>            <span class="cp">#include "2D_SDF.cginc"
</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//calculate the position in clip space to render the object</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//calculate world position of vertex</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="n">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
                <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
                <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Standard"</span> <span class="c1">//fallback adds a shadow pass so we get shadows on other objects</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="rectangle-example">Rectangle Example</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Rectangle.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Rectangle.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/034_2D_SDF_Basics/Rectangle"</span><span class="p">{</span>

    <span class="n">SubShader</span><span class="p">{</span>
        <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">CGPROGRAM</span>

            <span class="cp">#include "UnityCG.cginc"
</span>            <span class="cp">#include "2D_SDF.cginc"
</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//calculate the position in clip space to render the object</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//calculate world position of vertex</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="n">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
                <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">_Time</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>
                <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
                <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
                <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Standard"</span> <span class="c1">//fallback adds a shadow pass so we get shadows on other objects</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="cutoff">Cutoff</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Cutoff.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/Cutoff.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/034_2D_SDF_Basics/Cutoff"</span><span class="p">{</span>
    <span class="n">Properties</span><span class="p">{</span>
        <span class="n">_Color</span><span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">SubShader</span><span class="p">{</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Transparent"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Transparent"</span><span class="p">}</span>

        <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>
        <span class="n">ZWrite</span> <span class="n">Off</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">CGPROGRAM</span>
            <span class="cp">#include "UnityCG.cginc"
</span>            <span class="cp">#include "2D_SDF.cginc"
</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">fixed3</span> <span class="n">_Color</span><span class="p">;</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//calculate the position in clip space to render the object</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//calculate world position of vertex</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="n">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
                <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">_Time</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>
                <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
                <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
                <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
                <span class="kt">float</span> <span class="n">distanceChange</span> <span class="o">=</span> <span class="n">fwidth</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">antialiasedCutoff</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">distanceChange</span><span class="p">,</span> <span class="o">-</span><span class="n">distanceChange</span><span class="p">,</span> <span class="n">dist</span><span class="p">);</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">_Color</span><span class="p">,</span> <span class="n">antialiasedCutoff</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Standard"</span> <span class="c1">//fallback adds a shadow pass so we get shadows on other objects</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="distance-lines">Distance Lines</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/DistanceLines.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/034_2D_SDF/DistanceLines.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/034_2D_SDF_Basics/DistanceLines"</span><span class="p">{</span>
    <span class="n">Properties</span><span class="p">{</span>
        <span class="n">_InsideColor</span><span class="p">(</span><span class="s">"Inside Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">_OutsideColor</span><span class="p">(</span><span class="s">"Outside Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">_LineDistance</span><span class="p">(</span><span class="s">"Mayor Line Distance"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">_LineThickness</span><span class="p">(</span><span class="s">"Mayor Line Thickness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span>

        <span class="p">[</span><span class="n">IntRange</span><span class="p">]</span><span class="n">_SubLines</span><span class="p">(</span><span class="s">"Lines between major lines"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">_SubLineThickness</span><span class="p">(</span><span class="s">"Thickness of inbetween lines"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">01</span>
    <span class="p">}</span>

    <span class="n">SubShader</span><span class="p">{</span>
        <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">CGPROGRAM</span>

            <span class="cp">#include "UnityCG.cginc"
</span>            <span class="cp">#include "2D_SDF.cginc"
</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//calculate the position in clip space to render the object</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//calculate world position of vertex</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="n">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
                <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">_Time</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">);</span>
                <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
                <span class="kt">float</span> <span class="n">sceneDistance</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
                <span class="k">return</span> <span class="n">sceneDistance</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">float4</span> <span class="n">_InsideColor</span><span class="p">;</span>
            <span class="n">float4</span> <span class="n">_OutsideColor</span><span class="p">;</span>

            <span class="kt">float</span> <span class="n">_LineDistance</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">_LineThickness</span><span class="p">;</span>

            <span class="kt">float</span> <span class="n">_SubLines</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">_SubLineThickness</span><span class="p">;</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
                <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">_InsideColor</span><span class="p">,</span> <span class="n">_OutsideColor</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dist</span><span class="p">));</span>

                <span class="kt">float</span> <span class="n">distanceChange</span> <span class="o">=</span> <span class="n">fwidth</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">majorLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">_LineDistance</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LineDistance</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">majorLines</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">_LineThickness</span> <span class="o">-</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">_LineThickness</span> <span class="o">+</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">majorLineDistance</span><span class="p">);</span>

                <span class="kt">float</span> <span class="n">distanceBetweenSubLines</span> <span class="o">=</span> <span class="n">_LineDistance</span> <span class="o">/</span> <span class="n">_SubLines</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">subLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">distanceBetweenSubLines</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">distanceBetweenSubLines</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">subLines</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">_SubLineThickness</span> <span class="o">-</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">_SubLineThickness</span> <span class="o">+</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">subLineDistance</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">col</span> <span class="o">*</span> <span class="n">majorLines</span> <span class="o">*</span> <span class="n">subLines</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Standard"</span> <span class="c1">//fallback adds a shadow pass so we get shadows on other objects</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I hope I was able to explain the basics of signed distance fields to you and that you’re exited for the next few tutorials where I explain more ways to do things with them.</p>


    <p>
        You can also find me on twitter at <a href="https://www.twitter.com/totallyRonja">@totallyRonja</a>. If you liked my tutorial and want to support me you can do that on Patreon (<a href="https://www.patreon.com/RonjaTutorials">patreon.com/RonjaTutorials</a>) or Ko-Fi (<a href="https://ko-fi.com/RonjaTutorials">ko-fi.com/RonjaTutorials</a>).
    </p>
  </div>

  
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ronja-tutorials.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  
</article>


      <!-- SVG icons from https://iconmonstr.com -->

      <!-- Twitter icon -->
      <span class="my-span-icon">
          <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>

        <!-- RSS icon -->
        
          <span class="my-span-icon">
            <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
            </a>
          </span>
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact ">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        
    </section>

    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-124040112-1', 'auto');
        ga('send', 'pageview');
      </script>
    
  </body>
</html>
