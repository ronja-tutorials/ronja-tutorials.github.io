<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>Compute Shader</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="Ronja Böhringer">

<meta name="description" content="So far we always used shaders to render with a fixed pipeline into textures, but modern graphics card can do way more than just that (sometimes they’..." />





<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="Compute Shader">
<meta itemprop="description" content="So far we always used shaders to render with a fixed pipeline into textures, but modern graphics card can do way more than just that (sometimes they’...">

  <meta itemprop="image" content="https://www.ronja-tutorials.com/assets/images/posts/050/result.gif">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="Compute Shader">
<meta name="twitter:description" content="So far we always used shaders to render with a fixed pipeline into textures, but modern graphics card can do way more than just that (sometimes they’...">


  <meta name="twitter:creator" content="@TotallyRonja">


<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="https://www.ronja-tutorials.com/assets/images/posts/050/result.gif">
  <meta property="twitter:image" content="https://www.ronja-tutorials.com/assets/images/posts/050/result.gif">

<meta property="twitter:url" content="https://www.ronja-tutorials.com/2020/07/26/compute-shader.html">

<!-- Open Graph data -->
<meta property="og:title" content="Compute Shader" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/2020/07/26/compute-shader.html" />

  <meta property="og:image" content="https://www.ronja-tutorials.com/assets/images/posts/050/result.gif" />

<meta property="og:description" content="So far we always used shaders to render with a fixed pipeline into textures, but modern graphics card can do way more than just that (sometimes they’..." />
<meta property="og:site_name" content="Ronja's Shader Tutorials" />

  <meta property="article:published_time" content="2020-07-26T00:00:00+02:00" />














  
    <meta property="article:tag" content="shader,">
  
    <meta property="article:tag" content="unity,">
  
    <meta property="article:tag" content="compute">
  





  




    

    <link rel="canonical" href="https://www.ronja-tutorials.com/2020/07/26/compute-shader.html">

    

    <!-- <link rel="shortcut icon" href="https://www.ronja-tutorials.com/favicon.ico"> -->
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">Ronja&#39;s Shader Tutorials</a>
    
    <!-- SVG icons from https://iconmonstr.com -->

    <!-- Twitter icon -->
    <span class="my-span-icon">
        <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
          <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
        </a>
      </span>

      <!-- RSS icon -->
      
        <span class="my-span-icon">
          <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
          </a>
        </span>
      
      <!-- Contact icon -->
      
      
        <span class="my-span-icon">
          <a href="/about.html" aria-label="Contact" title="Contact ">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
          </a>
        </span>
      

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">Compute Shader</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2020-07-26T00:00:00+02:00" itemprop="datePublished">
          
          Jul 26, 2020
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ronja Böhringer</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Compute Shader</h1>
    <p class="post-meta">
      <time datetime="2020-07-26T00:00:00+02:00" itemprop="datePublished">
        
        Jul 26, 2020
      </time>
      </p>
  </header> -->

  
<ul>
  <li><a href="#basic-compute-shader">Basic Compute Shader</a></li>
  <li><a href="#executing-compute-shaders">Executing Compute Shaders</a></li>
  <li><a href="#a-tiny-bit-more-complex-compute-shader">A tiny bit more complex Compute Shader</a></li>
  <li><a href="#source">Source</a></li>
</ul>

  <div itemprop="articleBody">
    <p>So far we always used shaders to render with a fixed pipeline into textures, but modern graphics card can do way more than just that (sometimes they’re also referred to as GPGPU for “general purpose graphics processing unit” because of that). To do things that arent in the fix pipeline we’re using so far we have to use compute shaders.</p>

<p>If you’re asking yourself why we’d do that, the CPU is performant enough, especially once we use multithreading then I’m here to tell you that you’re 100% correct. You don’t need the GPU for you non graphics tasks. Using it will give you way more confusing error behaviour. The debugger wont give you as nice information and you can’t have breakpoints. Optimizing is weirder since you always have to think about what data you’re pushing around. The paralell nature of the GPU forces you to think way differently… If you don’t need compute shaders, especially when you’re not experienced, think about why you want to and if it’s making your more work than its worth.</p>

<p>If you’re still here, lets get going. In Unity you can check whether your GPU supports compute shaders by checking <a href="https://docs.unity3d.com/ScriptReference/SystemInfo-supportsComputeShaders.html">SystemInfo.supportsComputeShaders</a>.</p>

<p><img src="/assets/images/posts/050/result.gif" alt="" /></p>

<h2 id="basic-compute-shader">Basic Compute Shader</h2>

<p>We can get a simple compute shader by just doing <code class="language-plaintext highlighter-rouge">rclick&gt;Create&gt;Shader&gt;Compute Shader</code>. The default shader does a few calculations to write a pattern into a texture, but for this tutorial I want to go one step simpler and just write positions into an array.</p>

<p>In compute land an array we can write into is a <code class="language-plaintext highlighter-rouge">RWStructuredBuffer</code> with a certain type (<code class="language-plaintext highlighter-rouge">StructuredBuffer</code> is a array we can only read from). This type can be next to any type including vectors or structs. In our case we’ll use a float3 vector.</p>

<p>The function that calculates stuff is called the kernel. We have to add a <code class="language-plaintext highlighter-rouge">numthreads</code> attribute in front of the kernel and the kernel takes in one argument which tells us which iteration of the kernel we’re in. In our case we define the number of threads as 64 threads in the <code class="language-plaintext highlighter-rouge">x</code> dimension and 1 in both <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>. Those values should work for most platforms that support compute shaders and its in 1 dimension so we dont have to do any rethinking when writing to our 1d array. The input argument is also 3d for that reason but for now we only care about the x part. We do have to mark it as <code class="language-plaintext highlighter-rouge">SV_DispatchThreadID</code> though so the correct value is assigned to it.</p>

<p>To tell unity which functions are just regular functions that are called from somewhere else and which ones are the kernel functions we add a pragma statement, so <code class="language-plaintext highlighter-rouge">#pragma kernel &lt;functionname&gt;</code>. Its possible to have multiple kernels per shader file.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Each #kernel tells which function to compile; you can have many kernels</span>
<span class="cp">#pragma kernel Spheres
</span>
<span class="c1">//variables</span>
<span class="n">RWStructuredBuffer</span><span class="o">&lt;</span><span class="n">float3</span><span class="o">&gt;</span> <span class="n">Result</span><span class="p">;</span>

<span class="p">[</span><span class="n">numthreads</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="kt">void</span> <span class="nf">Spheres</span> <span class="p">(</span><span class="n">uint3</span> <span class="n">id</span> <span class="o">:</span> <span class="n">SV_DispatchThreadID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//compute shader code.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As a starting point I’ll just let the program write a id,0,0 positions in the buffer we set up.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">numthreads</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="kt">void</span> <span class="nf">Spheres</span> <span class="p">(</span><span class="n">uint3</span> <span class="n">id</span> <span class="o">:</span> <span class="n">SV_DispatchThreadID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="executing-compute-shaders">Executing Compute Shaders</h2>

<p>Unlike graphics shaders compute shaders can’t just be assigned to a material and via that to a object. Instead we trigger the execution ourselves from c# code.</p>

<p>In the C# component we create we reference our compute shader via a variable of the type <code class="language-plaintext highlighter-rouge">ComputeShader</code>. We also create a integer to store the identifier of our kernel after getting it once in the start method. To get the kernel identifier we call the <code class="language-plaintext highlighter-rouge">FindKernel(&lt;kernelname&gt;)</code> function on our compute shader. And after getting the kernel identifier we can use it to get the size of each thread group (thats equal to our <code class="language-plaintext highlighter-rouge">numthreads</code> in the shader). We store the x size in a variable and discard the others by passing in <code class="language-plaintext highlighter-rouge">_</code> as a output variable.</p>

<p>Lets also make the length of the buffer we’re filling a public property so we can change that in the future. With that information available we can also create the gpu array we’ll write to as a <code class="language-plaintext highlighter-rouge">ComputeBuffer</code>. Its constructor takes in the amount of elements as the first parameter and the size of its content as the second parameter. Since we’re using float3 on the shader side, we can get the size(in bytes) of a float with the <code class="language-plaintext highlighter-rouge">sizeof</code> function and multiply the result by 3(getting the size of a Vector3 or a float3 of the new mathematics lib is also possible, but only in a unsafe context and that sounds scary(it isn’t really, but whatever)). Paralell to the ComputeBuffer lets also create a regular Vector3 array of the same size, we’ll use it later to copy the data back to the ram where we can use it. If we want to write clean code (we kinda do) we should also call <code class="language-plaintext highlighter-rouge">Dispose</code> on our buffer when the component is destroyed so unity can do garbage collection, so lets add that to the OnDestroy method.</p>

<p>With all of that set up we can use the shader in the update method. First we declare set the buffer of the shader to be our buffer, this buffer is set per kernel so we also have to pass in our kernel identifier.
To dispatch the shader we first calculate how many threadgroups we need, in our case we want the amount of threads to be the length of the array, so the thread groups should be that amount divided by the thread size rounded up. When dealing with integers the easiest way of doing a division and getting the rounded up result is to add the divisor minus one before the division, that adds 1 to the result unless the dividend is a exact multiple of the divisor.
After thats done we can dispatch the shader and tell it how many thread groups it should run (the amount we just calculated in <code class="language-plaintext highlighter-rouge">x</code>, and 1 in <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>). And then we can already get the data out of the buffer into ram we can work with in C# with the aptly named <code class="language-plaintext highlighter-rouge">GetData</code> function.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">BasicComputeSpheres</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">SphereAmount</span> <span class="p">=</span> <span class="m">17</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">ComputeShader</span> <span class="n">Shader</span><span class="p">;</span>

    <span class="n">ComputeBuffer</span> <span class="n">resultBuffer</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">kernel</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="n">threadGroupSize</span><span class="p">;</span>
    <span class="n">Vector3</span><span class="p">[]</span> <span class="n">output</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//program we're executing</span>
        <span class="n">kernel</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">FindKernel</span><span class="p">(</span><span class="s">"Spheres"</span><span class="p">);</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">GetKernelThreadGroupSizes</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="k">out</span> <span class="n">threadGroupSize</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">);</span>

        <span class="c1">//buffer on the gpu in the ram</span>
        <span class="n">resultBuffer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ComputeBuffer</span><span class="p">(</span><span class="n">SphereAmount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">*</span> <span class="m">3</span><span class="p">);</span>
        <span class="n">output</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector3</span><span class="p">[</span><span class="n">SphereAmount</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">SetBuffer</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="s">"Result"</span><span class="p">,</span> <span class="n">resultBuffer</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">threadGroups</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">((</span><span class="n">SphereAmount</span> <span class="p">+</span> <span class="p">(</span><span class="n">threadGroupSize</span> <span class="p">-</span> <span class="m">1</span><span class="p">))</span> <span class="p">/</span> <span class="n">threadGroupSize</span><span class="p">);</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">Dispatch</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">threadGroups</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
        <span class="n">resultBuffer</span><span class="p">.</span><span class="nf">GetData</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">OnDestroy</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">resultBuffer</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we have the data but we can’t see it. There are ways of rendering the buffer directly on the GPU, but this is not the tutorial for that, instead I decided to instantiate a bunch of prefabs and use them for visualisation. The instanced transforms are saved in a private array which is created and filled with new prefab instances in the start method. The length of the array is the same length of the buffer.</p>

<p>In update method we then copy the positions from the output struct to the local position of the objects.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in start method</span>

<span class="c1">//spheres we use for visualisation</span>
<span class="n">instances</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Transform</span><span class="p">[</span><span class="n">SphereAmount</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">SphereAmount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">instances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">Prefab</span><span class="p">,</span> <span class="n">transform</span><span class="p">).</span><span class="n">transform</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in update method</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">instances</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="n">instances</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/050/Row.png" alt="" /></p>

<h2 id="a-tiny-bit-more-complex-compute-shader">A tiny bit more complex Compute Shader</h2>

<p>The rest of this is just to make stuff look nice, its just plain hlsl like in all my other tutorials.</p>

<p>In the Compute Shader I first include the functions from <a href="/2018/09/02/white-noise.html">my tutorial on randomness</a> and add a new variable called time.
In the kernel function I get a random vector(based on the kernel index), normalize it and get it to a random length between 0.1 and 1 (if I let it go too short bad math can happen too easily and some points become NaN). Then I generate a new vector thats orthogonal to that one by taking the cross product between the vector and a different random vector(this isn’t guaranteed to work, if the vectors are paralell the cross product is <code class="language-plaintext highlighter-rouge">(0,0,0)</code> and can’t e normalized, but it works well enough) and give its length the same treatment to make it be between 0.1 and 0.9. The random looking numbers I add to the inputs are to avoid some of the symmetry so not all random functions return the same result. Then I get a time variable by multiplying the time by 2(that 2 could be a uniform value if you want to adjust the speed manually) and give it a offset by a random value multiplied by some big-ish odd number.</p>

<p>Those values can then be combined by multiplying one of the vectors by the sine of the time and the other by the cosine of the time and adding the 2 results. I then also multiplied it by 20 to make it bigger, but you should also consider using a property settable from outside here(do as I say not as I do).</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Each #kernel tells which function to compile; you can have many kernels</span>
<span class="cp">#pragma kernel Spheres
</span>
<span class="cp">#include "Random.cginc"
</span>
<span class="c1">//variables</span>
<span class="n">RWStructuredBuffer</span><span class="o">&lt;</span><span class="n">float3</span><span class="o">&gt;</span> <span class="n">Result</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">float</span> <span class="n">Time</span><span class="p">;</span>

<span class="p">[</span><span class="n">numthreads</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="kt">void</span> <span class="nf">Spheres</span> <span class="p">(</span><span class="n">uint3</span> <span class="n">id</span> <span class="o">:</span> <span class="n">SV_DispatchThreadID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//generate 2 orthogonal vectors</span>
    <span class="n">float3</span> <span class="n">baseDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">rand1dTo3d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand1dTo1d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="o">+</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">baseDir</span><span class="p">,</span> <span class="n">rand1dTo3d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">7</span><span class="p">.</span><span class="mi">1393</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand1dTo1d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">.</span><span class="mi">7443</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="o">+</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//scale the time and give it a random offset</span>
    <span class="kt">float</span> <span class="n">scaledTime</span> <span class="o">=</span> <span class="n">Time</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rand1dTo1d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">712</span><span class="p">.</span><span class="mi">131234</span><span class="p">;</span>
    <span class="c1">//calculate a vector based on vectors</span>
    <span class="n">float3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">baseDir</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">scaledTime</span><span class="p">)</span> <span class="o">+</span> <span class="n">orthogonal</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">scaledTime</span><span class="p">);</span>
    <span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">dir</span> <span class="o">*</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then all thats missing is passing in the time from the C# code and you should have a nice orbiting swarm.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"Time"</span><span class="p">,</span> <span class="n">Time</span><span class="p">.</span><span class="n">time</span><span class="p">);</span>
</code></pre></div></div>

<p>With a emissive material and a simple bloom from the postprocessing stack it can look like this:</p>

<p><img src="/assets/images/posts/050/result.gif" alt="" /></p>

<h2 id="source">Source</h2>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/050_Compute_Shader/BasicCompute.compute">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/050_Compute_Shader/BasicCompute.compute</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Each #kernel tells which function to compile; you can have many kernels</span>
<span class="cp">#pragma kernel Spheres
</span>
<span class="cp">#include "Random.cginc"
</span>
<span class="c1">//variables</span>
<span class="n">RWStructuredBuffer</span><span class="o">&lt;</span><span class="n">float3</span><span class="o">&gt;</span> <span class="n">Result</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">float</span> <span class="n">Time</span><span class="p">;</span>

<span class="p">[</span><span class="n">numthreads</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="kt">void</span> <span class="nf">Spheres</span> <span class="p">(</span><span class="n">uint3</span> <span class="n">id</span> <span class="o">:</span> <span class="n">SV_DispatchThreadID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//generate 2 orthogonal vectors</span>
    <span class="n">float3</span> <span class="n">baseDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">rand1dTo3d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand1dTo1d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="o">+</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">baseDir</span><span class="p">,</span> <span class="n">rand1dTo3d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">7</span><span class="p">.</span><span class="mi">1393</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand1dTo1d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">.</span><span class="mi">7443</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="o">+</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//scale the time and give it a random offset</span>
    <span class="kt">float</span> <span class="n">scaledTime</span> <span class="o">=</span> <span class="n">Time</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rand1dTo1d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">712</span><span class="p">.</span><span class="mi">131234</span><span class="p">;</span>
    <span class="c1">//calculate a vector based on vectors</span>
    <span class="n">float3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">baseDir</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">scaledTime</span><span class="p">)</span> <span class="o">+</span> <span class="n">orthogonal</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">scaledTime</span><span class="p">);</span>
    <span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">dir</span> <span class="o">*</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/050_Compute_Shader/BasicComputeSpheres.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/050_Compute_Shader/BasicComputeSpheres.cs</a></li>
</ul>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">BasicComputeSpheres</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">SphereAmount</span> <span class="p">=</span> <span class="m">17</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">ComputeShader</span> <span class="n">Shader</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">GameObject</span> <span class="n">Prefab</span><span class="p">;</span>

    <span class="n">ComputeBuffer</span> <span class="n">resultBuffer</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">kernel</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="n">threadGroupSize</span><span class="p">;</span>
    <span class="n">Vector3</span><span class="p">[]</span> <span class="n">output</span><span class="p">;</span>

    <span class="n">Transform</span><span class="p">[]</span> <span class="n">instances</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//program we're executing</span>
        <span class="n">kernel</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">FindKernel</span><span class="p">(</span><span class="s">"Spheres"</span><span class="p">);</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">GetKernelThreadGroupSizes</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="k">out</span> <span class="n">threadGroupSize</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">);</span>

        <span class="c1">//buffer on the gpu in the ram</span>
        <span class="n">resultBuffer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ComputeBuffer</span><span class="p">(</span><span class="n">SphereAmount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">*</span> <span class="m">3</span><span class="p">);</span>
        <span class="n">output</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector3</span><span class="p">[</span><span class="n">SphereAmount</span><span class="p">];</span>

        <span class="c1">//spheres we use for visualisation</span>
        <span class="n">instances</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Transform</span><span class="p">[</span><span class="n">SphereAmount</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">SphereAmount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="n">instances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">Prefab</span><span class="p">,</span> <span class="n">transform</span><span class="p">).</span><span class="n">transform</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"Time"</span><span class="p">,</span> <span class="n">Time</span><span class="p">.</span><span class="n">time</span><span class="p">);</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">SetBuffer</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="s">"Result"</span><span class="p">,</span> <span class="n">resultBuffer</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">threadGroups</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">((</span><span class="n">SphereAmount</span> <span class="p">+</span> <span class="p">(</span><span class="n">threadGroupSize</span> <span class="p">-</span> <span class="m">1</span><span class="p">))</span> <span class="p">/</span> <span class="n">threadGroupSize</span><span class="p">);</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">Dispatch</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">threadGroups</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
        <span class="n">resultBuffer</span><span class="p">.</span><span class="nf">GetData</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">instances</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="n">instances</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">OnDestroy</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">resultBuffer</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


    <p>
        You can also find me on twitter at <a href="https://www.twitter.com/totallyRonja">@totallyRonja</a>. If you liked my tutorial and want to support me you can do that on Patreon (<a href="https://www.patreon.com/RonjaTutorials">patreon.com/RonjaTutorials</a>) or Ko-Fi (<a href="https://ko-fi.com/RonjaTutorials">ko-fi.com/RonjaTutorials</a>).
    </p>
  </div>

  
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ronja-tutorials.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  
</article>


      <!-- SVG icons from https://iconmonstr.com -->

      <!-- Twitter icon -->
      <span class="my-span-icon">
          <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>

        <!-- RSS icon -->
        
          <span class="my-span-icon">
            <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
            </a>
          </span>
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact ">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        
    </section>

    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-124040112-1', 'auto');
        ga('send', 'pageview');
      </script>
    
  </body>
</html>
