<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Improved Toon Light | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Last weeks tutorial was about making a simple toon shader, but I felt like there&rsquo;s still a lot to improve about it so this weeks tutorial is too. We&rsquo;ll fix a thing, and add multiple steps to the lighting as well as a specular highlight. I recommend you to read the previous tutorial if you haven&rsquo;t because this one is heavily based on it and expands its code.
Improved shadows for multiple lights.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="Improved Toon Light" />
<meta property="og:description" content="Last weeks tutorial was about making a simple toon shader, but I felt like there&rsquo;s still a lot to improve about it so this weeks tutorial is too. We&rsquo;ll fix a thing, and add multiple steps to the lighting as well as a specular highlight. I recommend you to read the previous tutorial if you haven&rsquo;t because this one is heavily based on it and expands its code.
Improved shadows for multiple lights." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/032-improved-toon/" />
<meta property="article:published_time" content="2018-10-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-10-27T00:00:00+00:00" />
<meta itemprop="name" content="Improved Toon Light">
<meta itemprop="description" content="Last weeks tutorial was about making a simple toon shader, but I felt like there&rsquo;s still a lot to improve about it so this weeks tutorial is too. We&rsquo;ll fix a thing, and add multiple steps to the lighting as well as a specular highlight. I recommend you to read the previous tutorial if you haven&rsquo;t because this one is heavily based on it and expands its code.
Improved shadows for multiple lights.">
<meta itemprop="datePublished" content="2018-10-27T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-10-27T00:00:00+00:00" />
<meta itemprop="wordCount" content="2623">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Improved Toon Light"/>
<meta name="twitter:description" content="Last weeks tutorial was about making a simple toon shader, but I felt like there&rsquo;s still a lot to improve about it so this weeks tutorial is too. We&rsquo;ll fix a thing, and add multiple steps to the lighting as well as a specular highlight. I recommend you to read the previous tutorial if you haven&rsquo;t because this one is heavily based on it and expands its code.
Improved shadows for multiple lights."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      
      
      <h1 class="f1 athelas mt3 mb1">Improved Toon Light</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-10-27T00:00:00Z">October 27, 2018</time>

      
      
    </header>
    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><p><a href="https://www.ronja-tutorials.com/post/031-single-step-toon/">Last weeks tutorial</a> was about making a simple toon shader, but I felt like there&rsquo;s still a lot to improve about it so this weeks tutorial is too. We&rsquo;ll fix a thing, and add multiple steps to the lighting as well as a specular highlight. I recommend you to read <a href="https://www.ronja-tutorials.com/post/031-single-step-toon/">the previous tutorial</a> if you haven&rsquo;t because this one is heavily based on it and expands its code.</p>
<p><img src="/assets/images/posts/032/Demo.gif" alt=""></p>
<h2 id="improved-shadows-for-multiple-lights">Improved shadows for multiple lights.</h2>
<p>If we have multiple lights in our scene we want them to all light up the light parts, but not have it change the areas where all of them have shadows. With the custom shadow color we have right now applied in the lighting function we also add the shadow color the more lights we have. This is also critical because point lights will add lighting in a weird square shape that we definitely don&rsquo;t want.</p>
<p><img src="/assets/images/posts/032/BadLight.gif" alt=""></p>
<p>The easiest fix for this is to add the shadow color in a way that only adds it once everywhere on the model and then use black as the shadow color in the lighting function.</p>
<p>There are 2 ways to do that. Either we set the ambient color in the lighting settings to the color we want our shadows to be in, or we set the ambient color to black and add the shadow color to the emissive value. I&rsquo;ll do the second solution here because it allows us to set a custom shadow color per material, but feel free to use the ambient color solution if you want to change the color of all shadows at the same time.</p>
<p>We start by setting the ambient color to black in the lighting settings. Then we also disable environment reflections and global illumination. I recommend you do this in general if you want greater control over your lighting and you want a &ldquo;clean&rdquo; look.</p>
<p><img src="/assets/images/posts/032/LightingSettings.png" alt=""></p>
<p>Then we move the shadow color to the emission of the material instead of the lighting function. We calculate it just like before by multiplying the albedo color of the object with the shadow color property. Then to use it we simply add it to the emissive color. Now that we implemented this we don&rsquo;t have to set the color in the lighting function anymore. In the line where we used it to interpolate from the shadow to the light color we can now remove the lerp function and simply multiply the light intensity by the albedo.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutput o) {
    <span style="color:#888">//sample and tint albedo texture</span>
    fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
    col <span style="color:#333">*=</span> _Color;
    o.Albedo <span style="color:#333">=</span> col.rgb;

    float3 shadowColor <span style="color:#333">=</span> col.rgb <span style="color:#333">*</span> _ShadowTint;
    o.Emission <span style="color:#333">=</span> _Emission <span style="color:#333">+</span> shadowColor;
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float4 color;
color.rgb <span style="color:#333">=</span> s.Albedo <span style="color:#333">*</span> lightIntensity <span style="color:#333">*</span> _LightColor0.rgb;
color.a <span style="color:#333">=</span> s.Alpha;
<span style="color:#080;font-weight:bold">return</span> color;
</code></pre></div><p><img src="/assets/images/posts/032/EmissiveShadowColor.png" alt=""></p>
<p>This technique works really well for dark shadow colors, but if we want the shadow color to be very strong we we always have the light tinted in the shadow color. There are ways to avoid that but they have their own disadvantages, so I won&rsquo;t get into them here (write me if you&rsquo;re curious).</p>
<h2 id="multiple-steps">Multiple Steps</h2>
<p>So far we only have a single hard cut for the lighting. Another option is to have several of those. Having more steps can give the model more plasticity while still looking clean, but it&rsquo;s important that you consider what fits your style best.</p>
<p>To make multiple steps we divide the <code>towardsLight</code> variable by the relative width of a single step. We&rsquo;ll make that a property to edit. By dividing it, the variable will become higher and span more whole numbers. If we pass 0.5 as the relative width, it&rsquo;ll go from 0 to 2 (in the area towards the light, we&rsquo;ll ignore the backside for now), for a width of 0.25 it&rsquo;s from 0 to 4 etc. We can then use this stretched variable to generate hard steps with the <code>ceil</code> function to force it to whole values. After we have whole values we divide it again, this time by another property which represents the amount of steps we want to show. The values will still be negative for the values on the shadow side and might go over 1 if we have a few narrow cuts, so we then clamp it between 0 and 1 by passing it though the <code>saturate</code> method. After those steps we can use it as the light intensity.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Properties {
    [Header(Base Parameters)]
    _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>)
    _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
    [HDR] _Emission (<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span> ,<span style="color:#40e;font-weight:bold">0</span> ,<span style="color:#40e;font-weight:bold">0</span> , <span style="color:#00d;font-weight:bold">1</span>)

    [Header(Lighting Parameters)]
    _ShadowTint (<span style="color:#f00;background-color:#faa">&#34;</span>Shadow Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#60e;font-weight:bold">0.5</span>, <span style="color:#60e;font-weight:bold">0.5</span>, <span style="color:#60e;font-weight:bold">0.5</span>, <span style="color:#00d;font-weight:bold">1</span>)
    [IntRange]_StepAmount (<span style="color:#f00;background-color:#faa">&#34;</span>Shadow Steps<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">16</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span>
    _StepWidth (<span style="color:#f00;background-color:#faa">&#34;</span>Step Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#60e;font-weight:bold">0.05</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.25</span>
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//our lighting function. Will be called once per light</span>
float4 LightingStepped(SurfaceOutput s, float3 lightDir, half3 viewDir, <span style="color:#080;font-weight:bold">float</span> shadowAttenuation){
    <span style="color:#888">//how much does the normal point towards the light?</span>
    <span style="color:#080;font-weight:bold">float</span> towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);
    towardsLight <span style="color:#333">=</span> towardsLight <span style="color:#333">/</span> _StepWidth;
    <span style="color:#080;font-weight:bold">float</span> lightIntensity <span style="color:#333">=</span> ceil(towardsLight);
    lightIntensity <span style="color:#333">=</span> lightIntensity <span style="color:#333">/</span> _StepAmount;
    lightIntensity <span style="color:#333">=</span> saturate(lightIntensity);

    <span style="color:#888">//shadow etc...</span>
</code></pre></div><p><img src="/assets/images/posts/032/SimpleSteps.gif" alt=""></p>
<p>This already works pretty well now, but we have lost our antialiasing with that conversion, so we have to implement that again. We do this by interpolating to the next lower step in the first pixels of each step. This addition has to happen between the line where we ceil the value to a whole number and the line where we divide it by the amount of steps. We first get the change of how much it points towards the light with the <code>fwidth</code> function, then we do a <code>smoothstep</code> again from 0 to the amount the change in one pixel. But instead of using the towards light variable as the value to check against, which would only smooth the first step towards the shadowed area, we use the fractional part. This way we&rsquo;ll get the smoothing for every single step. Once we have that smoothing variable which masks out the first few pixels, we add it to the intensity. Because this smoothing is 0 at the very beginning and 1 for most of the area of the step, this will make the material appear too bright. The easy way around that is to change the <code>ceil</code> method we used earlier to a <code>floor</code> which is basically the same, just one whole value lower.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//how much does the normal point towards the light?</span>
<span style="color:#080;font-weight:bold">float</span> towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);

<span style="color:#888">//stretch values so each whole value is one step</span>
towardsLight <span style="color:#333">=</span> towardsLight <span style="color:#333">/</span> _StepWidth;
<span style="color:#888">//make steps harder</span>
<span style="color:#080;font-weight:bold">float</span> lightIntensity <span style="color:#333">=</span> floor(towardsLight);

<span style="color:#888">// calculate smoothing in first pixels of the steps and add smoothing to step, raising it by one step</span>
<span style="color:#888">// (that&#39;s fine because we used floor previously and we want everything to be the value above the floor value, </span>
<span style="color:#888">// for example 0 to 1 should be 1, 1 to 2 should be 2 etc...)</span>
<span style="color:#080;font-weight:bold">float</span> change <span style="color:#333">=</span> fwidth(towardsLight);
<span style="color:#080;font-weight:bold">float</span> smoothing <span style="color:#333">=</span> smoothstep(<span style="color:#40e;font-weight:bold">0</span>, change, frac(towardsLight));
lightIntensity <span style="color:#333">=</span> lightIntensity <span style="color:#333">+</span> smoothing;

<span style="color:#888">// bring the light intensity back into a range where we can use it for color</span>
<span style="color:#888">// and clamp it so it doesn&#39;t do weird stuff below 0 / above one</span>
lightIntensity <span style="color:#333">=</span> lightIntensity <span style="color:#333">/</span> _StepAmount;
lightIntensity <span style="color:#333">=</span> saturate(lightIntensity);
</code></pre></div><p><img src="/assets/images/posts/032/AntialiasedSteps.png" alt=""></p>
<h2 id="specular-highlights">Specular Highlights</h2>
<p>For objects to look wet, shiny or metallic we can implement specular highlights. Because they depend on how the light would be reflected towards the camera they change based on the view direction.</p>
<p>First we calculate in which direction the light would be reflected, for this hlsl has the handy <code>reflect</code> method which takes a direction and a normal. Then we compare it to the view direction with a dot product, but only after we invert it because the reflection goes out of the surface and the view direction towards the surface.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 reflectionDirection <span style="color:#333">=</span> reflect(lightDir, s.Normal);
<span style="color:#080;font-weight:bold">float</span> towardsReflection <span style="color:#333">=</span> dot(viewDir, <span style="color:#333">-</span>reflectionDirection);
<span style="color:#080;font-weight:bold">return</span> towardsReflection;
</code></pre></div><p><img src="/assets/images/posts/032/ReflectionDirection.png" alt=""></p>
<p>With this we get a nice soft gradient towards the direction of the light reflection. Just like the shadowing, we can then cut it off so we get a nice hard highlight. We first get the change in the variable, then we do a smoothstep. We subtract our specular size property from 1 because the towards light variable will be one where it points towards the reflection so when we cut off at 1, the specular highlight will be invisible, and the lower the cutoff points gets, the bigger the highlight grows.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//property</span>
_SpecularSize (<span style="color:#f00;background-color:#faa">&#34;</span>Specular Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.1</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//global shader variable</span>
<span style="color:#080;font-weight:bold">float</span> _SpecularSize;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 reflectionDirection <span style="color:#333">=</span> reflect(lightDir, s.Normal);
<span style="color:#080;font-weight:bold">float</span> towardsReflection <span style="color:#333">=</span> dot(viewDir, <span style="color:#333">-</span>reflectionDirection);
<span style="color:#080;font-weight:bold">float</span> specularChange <span style="color:#333">=</span> fwidth(towardsReflection);
<span style="color:#080;font-weight:bold">float</span> specularIntensity <span style="color:#333">=</span> smoothstep(<span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> _SpecularSize, <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> _SpecularSize <span style="color:#333">+</span> specularChange, towardsReflection);
<span style="color:#080;font-weight:bold">return</span> specularIntensity;
</code></pre></div><p><img src="/assets/images/posts/032/SpecularIntensity.png" alt=""></p>
<p>One thing that can look weird with this is that if we go behind out object and look in the direction of the light, the highlight can become huge and span around the outside of the object.</p>
<p><img src="/assets/images/posts/032/BigSpecular.png" alt=""></p>
<p>To counteract this, we can simply multiply the towardsLight variable with a inverse fresnel before doing the cutoff. We get the inverse fresnel by simply taking the dot product between the normal and the view direction. To make it adjustable by a property, we take the dot product by the power of the property. Then we multiply the new falloff variable by the towards light direction.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//property</span>
_SpecularFalloff (<span style="color:#f00;background-color:#faa">&#34;</span>Specular Falloff<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">2</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//global shader variable</span>
<span style="color:#080;font-weight:bold">float</span> _SpecularFalloff;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 reflectionDirection <span style="color:#333">=</span> reflect(lightDir, s.Normal);
<span style="color:#080;font-weight:bold">float</span> towardsReflection <span style="color:#333">=</span> dot(viewDir, <span style="color:#333">-</span>reflectionDirection);
<span style="color:#080;font-weight:bold">float</span> specularFalloff <span style="color:#333">=</span> dot(viewDir, s.Normal);
specularFalloff <span style="color:#333">=</span> pow(specularFalloff, _SpecularFalloff);
towardsReflection <span style="color:#333">=</span> towardsReflection <span style="color:#333">*</span> specularFalloff;
<span style="color:#080;font-weight:bold">float</span> specularChange <span style="color:#333">=</span> fwidth(towardsReflection);
<span style="color:#080;font-weight:bold">float</span> specularIntensity <span style="color:#333">=</span> smoothstep(<span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> _SpecularSize, <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> _SpecularSize <span style="color:#333">+</span> specularChange, towardsReflection);
<span style="color:#080;font-weight:bold">return</span> specularIntensity;
</code></pre></div><p><img src="/assets/images/posts/032/FalloffAdjustment.gif" alt=""></p>
<p>And as a last point we also multiply the shadow intensity by our shadow variable so we don&rsquo;t see the specular highlights where the surface should be shadowed.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">specularIntensity <span style="color:#333">=</span> specularIntensity <span style="color:#333">*</span> shadow;
</code></pre></div><p>Then to implement it with the correct colors and with the existing lighting we simply do a linear interpolation from the color we calculated with lighting and the specular color based on the specular intensity and the color of the light. We set the specular color property as the specular parameter of the surfaceoutput struct. At this moment it doesn&rsquo;t matter wether we write the property to the surfaceoutput and read that in the lighting function or we simply read the property in the lighting function, but doing it this way makes it easier to expand in the future and for example read the specular color from a texture.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//property</span>
_Specular (<span style="color:#f00;background-color:#faa">&#34;</span>Specular Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//global shader variable</span>
fixed3 _Specular;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//in the surface function</span>
o.Specular <span style="color:#333">=</span> _Specular;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//in the lighting function</span>

<span style="color:#888">//calculate how much the surface points points towards the reflection direction</span>
float3 reflectionDirection <span style="color:#333">=</span> reflect(lightDir, s.Normal);
<span style="color:#080;font-weight:bold">float</span> towardsReflection <span style="color:#333">=</span> dot(viewDir, <span style="color:#333">-</span>reflectionDirection);

<span style="color:#888">//make specular highlight all off towards outside of model</span>
<span style="color:#080;font-weight:bold">float</span> specularFalloff <span style="color:#333">=</span> dot(viewDir, s.Normal);
specularFalloff <span style="color:#333">=</span> pow(specularFalloff, _SpecularFalloff);
towardsReflection <span style="color:#333">=</span> towardsReflection <span style="color:#333">*</span> specularFalloff;

<span style="color:#888">//make specular intensity with a hard corner</span>
<span style="color:#080;font-weight:bold">float</span> specularChange <span style="color:#333">=</span> fwidth(towardsReflection);
<span style="color:#080;font-weight:bold">float</span> specularIntensity <span style="color:#333">=</span> smoothstep(<span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> _SpecularSize, <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> _SpecularSize <span style="color:#333">+</span> specularChange, towardsReflection);
<span style="color:#888">//factor inshadows</span>
specularIntensity <span style="color:#333">=</span> specularIntensity <span style="color:#333">*</span> shadow;

float4 color;
<span style="color:#888">//calculate final color</span>
color.rgb <span style="color:#333">=</span> s.Albedo <span style="color:#333">*</span> lightIntensity <span style="color:#333">*</span> _LightColor0.rgb;
color.rgb <span style="color:#333">=</span> lerp(color.rgb, s.Specular <span style="color:#333">*</span> _LightColor0.rgb, saturate(specularIntensity));

color.a <span style="color:#333">=</span> s.Alpha;
<span style="color:#080;font-weight:bold">return</span> color;
</code></pre></div><p>Sadly the surface variable only supports 1-dimensional variables, so we&rsquo;ll write our own struct for passing variables. It needs an albedo, emission, specular, alpha, and normal property. We&rsquo;ll then replace all occurances of SurfaceOutput with our new struct.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">struct</span> ToonSurfaceOutput{
    fixed3 Albedo;
    half3 Emission;
    fixed3 Specular;
    <span style="color:#080;font-weight:bold">fixed</span> Alpha;
    fixed3 Normal;
};
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float4 LightingStepped(ToonSurfaceOutput s, float3 lightDir, half3 viewDir, <span style="color:#080;font-weight:bold">float</span> shadowAttenuation){
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> ToonSurfaceOutput o) {
</code></pre></div><p><img src="/assets/images/posts/032/CompleteToon.png" alt=""></p>
<h2 id="source">Source</h2>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/032_ImprovedToon/ImprovedToonLighting.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/032_ImprovedToon/ImprovedToonLighting.shader</a></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">032</span>_ImprovedToon<span style="color:#f00;background-color:#faa">&#34;</span> {
    <span style="color:#888">//show values to edit in inspector</span>
    Properties {
        [Header(Base Parameters)]
        _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>)
        _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
        _Specular (<span style="color:#f00;background-color:#faa">&#34;</span>Specular Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>)
        [HDR] _Emission (<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span> ,<span style="color:#40e;font-weight:bold">0</span> ,<span style="color:#40e;font-weight:bold">0</span> , <span style="color:#00d;font-weight:bold">1</span>)

        [Header(Lighting Parameters)]
        _ShadowTint (<span style="color:#f00;background-color:#faa">&#34;</span>Shadow Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#60e;font-weight:bold">0.5</span>, <span style="color:#60e;font-weight:bold">0.5</span>, <span style="color:#60e;font-weight:bold">0.5</span>, <span style="color:#00d;font-weight:bold">1</span>)
        [IntRange]_StepAmount (<span style="color:#f00;background-color:#faa">&#34;</span>Shadow Steps<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">16</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span>
        _StepWidth (<span style="color:#f00;background-color:#faa">&#34;</span>Step Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.25</span>
        _SpecularSize (<span style="color:#f00;background-color:#faa">&#34;</span>Specular Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.1</span>
        _SpecularFalloff (<span style="color:#f00;background-color:#faa">&#34;</span>Specular Falloff<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">2</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
    }
    SubShader {
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        CGPROGRAM

        <span style="color:#888">//the shader is a surface shader, meaning that it will be extended by unity in the background to have fancy lighting and other features</span>
        <span style="color:#888">//our surface shader function is called surf and we use our custom lighting model</span>
        <span style="color:#888">//fullforwardshadows makes sure unity adds the shadow passes the shader might need</span>
        <span style="color:#f00;background-color:#faa">#</span>pragma surface surf Stepped fullforwardshadows
        <span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

        <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
        fixed4 _Color;
        half3 _Emission;
        fixed4 _Specular;

        float3 _ShadowTint;
        <span style="color:#080;font-weight:bold">float</span> _StepWidth;
        <span style="color:#080;font-weight:bold">float</span> _StepAmount;
        <span style="color:#080;font-weight:bold">float</span> _SpecularSize;
        <span style="color:#080;font-weight:bold">float</span> _SpecularFalloff;

        <span style="color:#080;font-weight:bold">struct</span> ToonSurfaceOutput{
            fixed3 Albedo;
            half3 Emission;
            fixed3 Specular;
            <span style="color:#080;font-weight:bold">fixed</span> Alpha;
            fixed3 Normal;
        };

        <span style="color:#888">//our lighting function. Will be called once per light</span>
        float4 LightingStepped(ToonSurfaceOutput s, float3 lightDir, half3 viewDir, <span style="color:#080;font-weight:bold">float</span> shadowAttenuation){
            <span style="color:#888">//how much does the normal point towards the light?</span>
            <span style="color:#080;font-weight:bold">float</span> towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);

            <span style="color:#888">//stretch values so each whole value is one step</span>
            towardsLight <span style="color:#333">=</span> towardsLight <span style="color:#333">/</span> _StepWidth;
            <span style="color:#888">//make steps harder</span>
            <span style="color:#080;font-weight:bold">float</span> lightIntensity <span style="color:#333">=</span> floor(towardsLight);

            <span style="color:#888">// calculate smoothing in first pixels of the steps and add smoothing to step, raising it by one step</span>
            <span style="color:#888">// (that&#39;s fine because we used floor previously and we want everything to be the value above the floor value, </span>
            <span style="color:#888">// for example 0 to 1 should be 1, 1 to 2 should be 2 etc...)</span>
            <span style="color:#080;font-weight:bold">float</span> change <span style="color:#333">=</span> fwidth(towardsLight);
            <span style="color:#080;font-weight:bold">float</span> smoothing <span style="color:#333">=</span> smoothstep(<span style="color:#40e;font-weight:bold">0</span>, change, frac(towardsLight));
            lightIntensity <span style="color:#333">=</span> lightIntensity <span style="color:#333">+</span> smoothing;

            <span style="color:#888">// bring the light intensity back into a range where we can use it for color</span>
            <span style="color:#888">// and clamp it so it doesn&#39;t do weird stuff below 0 / above one</span>
            lightIntensity <span style="color:#333">=</span> lightIntensity <span style="color:#333">/</span> _StepAmount;
            lightIntensity <span style="color:#333">=</span> saturate(lightIntensity);

        <span style="color:#f00;background-color:#faa">#</span>ifdef USING_DIRECTIONAL_LIGHT
            <span style="color:#888">//for directional lights, get a hard vut in the middle of the shadow attenuation</span>
            <span style="color:#080;font-weight:bold">float</span> attenuationChange <span style="color:#333">=</span> fwidth(shadowAttenuation) <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>;
            <span style="color:#080;font-weight:bold">float</span> shadow <span style="color:#333">=</span> smoothstep(<span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">-</span> attenuationChange, <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> attenuationChange, shadowAttenuation);
        <span style="color:#f00;background-color:#faa">#</span><span style="color:#080;font-weight:bold">else</span>
            <span style="color:#888">//for other light types (point, spot), put the cutoff near black, so the falloff doesn&#39;t affect the range</span>
            <span style="color:#080;font-weight:bold">float</span> attenuationChange <span style="color:#333">=</span> fwidth(shadowAttenuation);
            <span style="color:#080;font-weight:bold">float</span> shadow <span style="color:#333">=</span> smoothstep(<span style="color:#40e;font-weight:bold">0</span>, attenuationChange, shadowAttenuation);
        <span style="color:#f00;background-color:#faa">#</span>endif
            lightIntensity <span style="color:#333">=</span> lightIntensity <span style="color:#333">*</span> shadow;

            <span style="color:#888">//calculate how much the surface points points towards the reflection direction</span>
            float3 reflectionDirection <span style="color:#333">=</span> reflect(lightDir, s.Normal);
            <span style="color:#080;font-weight:bold">float</span> towardsReflection <span style="color:#333">=</span> dot(viewDir, <span style="color:#333">-</span>reflectionDirection);

            <span style="color:#888">//make specular highlight all off towards outside of model</span>
            <span style="color:#080;font-weight:bold">float</span> specularFalloff <span style="color:#333">=</span> dot(viewDir, s.Normal);
            specularFalloff <span style="color:#333">=</span> pow(specularFalloff, _SpecularFalloff);
            towardsReflection <span style="color:#333">=</span> towardsReflection <span style="color:#333">*</span> specularFalloff;

            <span style="color:#888">//make specular intensity with a hard corner</span>
            <span style="color:#080;font-weight:bold">float</span> specularChange <span style="color:#333">=</span> fwidth(towardsReflection);
            <span style="color:#080;font-weight:bold">float</span> specularIntensity <span style="color:#333">=</span> smoothstep(<span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> _SpecularSize, <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> _SpecularSize <span style="color:#333">+</span> specularChange, towardsReflection);
            <span style="color:#888">//factor inshadows</span>
            specularIntensity <span style="color:#333">=</span> specularIntensity <span style="color:#333">*</span> shadow;

            float4 color;
            <span style="color:#888">//calculate final color</span>
            color.rgb <span style="color:#333">=</span> s.Albedo <span style="color:#333">*</span> lightIntensity <span style="color:#333">*</span> _LightColor0.rgb;
            color.rgb <span style="color:#333">=</span> lerp(color.rgb, s.Specular <span style="color:#333">*</span> _LightColor0.rgb, saturate(specularIntensity));

            color.a <span style="color:#333">=</span> s.Alpha;
            <span style="color:#080;font-weight:bold">return</span> color;
        }


        <span style="color:#888">//input struct which is automatically filled by unity</span>
        <span style="color:#080;font-weight:bold">struct</span> Input {
            float2 uv_MainTex;
        };

        <span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
        <span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> ToonSurfaceOutput o) {
            <span style="color:#888">//sample and tint albedo texture</span>
            fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
            col <span style="color:#333">*=</span> _Color;
            o.Albedo <span style="color:#333">=</span> col.rgb;

            o.Specular <span style="color:#333">=</span> _Specular;

            float3 shadowColor <span style="color:#333">=</span> col.rgb <span style="color:#333">*</span> _ShadowTint;
            o.Emission <span style="color:#333">=</span> _Emission <span style="color:#333">+</span> shadowColor;
        }
        ENDCG
    }
    FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><p>I mainly concentrated on the lighting function in those tutorials, you can easily expand the shader by writing different values from the surface function and use textures for emissive color or normals. I also think it might be a good call to add the specular size to the surface struct and use that in the lighting function to be able to do drive the look more via textures. Whatever you end up doing I hope this tutorial made you curious about non photorealistic lighting and helped you realise the look you wanted to create.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ronja-tutorials" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
