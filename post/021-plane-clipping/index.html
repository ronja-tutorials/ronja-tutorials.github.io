<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Clipping a Model with a Plane | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary Another cool effect is to make the surface disappear when it’s beyond a certain plane.
To follow this tutorial, it’s best to know how surface shaders work - you can find a tutorial how they work here.
Define Plane We start by creating a new C# script which will define the plane we use later and pass it to the shader. It has a material as a public variable which we will pass the plane to.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="Clipping a Model with a Plane" />
<meta property="og:description" content="Summary Another cool effect is to make the surface disappear when it’s beyond a certain plane.
To follow this tutorial, it’s best to know how surface shaders work - you can find a tutorial how they work here.
Define Plane We start by creating a new C# script which will define the plane we use later and pass it to the shader. It has a material as a public variable which we will pass the plane to." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/021-plane-clipping/" />
<meta property="article:published_time" content="2018-08-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-08-06T00:00:00+00:00" />
<meta itemprop="name" content="Clipping a Model with a Plane">
<meta itemprop="description" content="Summary Another cool effect is to make the surface disappear when it’s beyond a certain plane.
To follow this tutorial, it’s best to know how surface shaders work - you can find a tutorial how they work here.
Define Plane We start by creating a new C# script which will define the plane we use later and pass it to the shader. It has a material as a public variable which we will pass the plane to.">
<meta itemprop="datePublished" content="2018-08-06T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-08-06T00:00:00+00:00" />
<meta itemprop="wordCount" content="1759">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Clipping a Model with a Plane"/>
<meta name="twitter:description" content="Summary Another cool effect is to make the surface disappear when it’s beyond a certain plane.
To follow this tutorial, it’s best to know how surface shaders work - you can find a tutorial how they work here.
Define Plane We start by creating a new C# script which will define the plane we use later and pass it to the shader. It has a material as a public variable which we will pass the plane to."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      
      
      <h1 class="f1 athelas mt3 mb1">Clipping a Model with a Plane</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-08-06T00:00:00Z">August 6, 2018</time>

      
      
    </header>
    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><h2 id="summary">Summary</h2>
<p>Another cool effect is to make the surface disappear when it’s beyond a certain plane.</p>
<p>To follow this tutorial, it’s best to know how <a href="https://www.ronja-tutorials.com/post/005-simple-surface/">surface shaders work</a> - you can find a tutorial how they work <a href="https://www.ronja-tutorials.com/post/005-simple-surface/">here</a>.</p>
<p><img src="/assets/images/posts/021/Result.gif" alt="Result"></p>
<h2 id="define-plane">Define Plane</h2>
<p>We start by creating a new C# script which will define the plane we use later and pass it to the shader. It has a material as a public variable which we will pass the plane to.</p>
<p>In the Update Method we create a new variable of the type Plane which unity already has. We pass it the the normal of the plane and a point on the plane. We will use the up vector of the transform the script is on as the normal and the position of the transform as the point on the plane.</p>
<p>Then we create a new 4d vector and put the normal of the new plane in the first three components and the distance from the origin in the 4th component. I’ll explain later how we’ll use those values.</p>
<p>Then we pass this new vector to the shader so we can use it there.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cs" data-lang="cs"><span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">System.Collections</span>;
<span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">System.Collections.Generic</span>;
<span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">UnityEngine</span>;

<span style="color:#080;font-weight:bold">public</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">ClippingPlane</span> : MonoBehaviour {
    <span style="color:#888">//material we pass the values to
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">public</span> Material mat;

    <span style="color:#888">//execute every frame
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">void</span> Update () {
        <span style="color:#888">//create plane
</span><span style="color:#888"></span>        Plane plane = <span style="color:#080;font-weight:bold">new</span> Plane(transform.up, transform.position);
        <span style="color:#888">//transfer values from plane to vector4
</span><span style="color:#888"></span>        Vector4 planeRepresentation = <span style="color:#080;font-weight:bold">new</span> Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.distance);
        <span style="color:#888">//pass vector to shader
</span><span style="color:#888"></span>        mat.SetVector(<span style="background-color:#fff0f0">&#34;_Plane&#34;</span>, planeRepresentation);
    }
}
</code></pre></div><p>To set up this script we add it to a empty gameobject and apply our material to the corresponding variable.</p>
<p><img src="/assets/images/posts/021/PlaneInspector.png" alt=""></p>
<h2 id="clip-plane">Clip Plane</h2>
<p>Then we’ll write the shader. As a base for it we use the basic surface shader from this (tutorial](https://www.ronja-tutorials.com/post/005-simple-surface/).</p>
<p>First we add the plane variable we just passed into the material. Because we won’t write to it from the inspector, we don’t need a property for it.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float4 _Plane;
</code></pre></div><p>In the surface shader we can then calculate the distance of the surface point to the plane if it was in the origin of the world. We do this by calculating the dot product between the surface point and the plane normal. For all points on that plane the dot product will return 0 because the position vector is orthogonal to the normal. For points that are above the plane the values will be positive because the vectors point in the same direction and for the surface points below the plane the dot product will be negative because they point away from the normal.</p>
<p>To do this comparison we need the world position, so we add it to our input struct, just the exact name <code>worldPos</code> is enough for surface shaders to generate the world position for us, in <a href="https://www.ronja-tutorials.com/post/008-planar-mapping/">non-surface shaders we can do that ourselves with a small matrix multiplication</a>. Then we get the dot product and just write it to the emission for now.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//input struct which is automatically filled by unity</span>
<span style="color:#080;font-weight:bold">struct</span> Input {
    float2 uv_MainTex;
    float3 worldPos;
};
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    <span style="color:#888">//calculate signed distance to plane</span>
    <span style="color:#080;font-weight:bold">float</span> distance <span style="color:#333">=</span> dot(i.worldPos, _Plane.xyz);
    o.Emission <span style="color:#333">=</span> distance;
}
</code></pre></div><p><img src="/assets/images/posts/021/OriginPlaneDistance.gif" alt=""></p>
<p>When we now rotate our plane object we can see the distance being calculated correctly, but it completely ignores the position of the plane object because we act like it’s positioned in the center so far. This is where the distance we saved in the 4th component of the vector earlier comes in. Because it’s the distance from the center we can simply add it to the plane we constructed around the center and we get the plane at the correct position.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    <span style="color:#888">//calculate signed distance to plane</span>
    <span style="color:#080;font-weight:bold">float</span> distance <span style="color:#333">=</span> dot(i.worldPos, _Plane.xyz);
    distance <span style="color:#333">=</span> distance <span style="color:#333">+</span> _Plane.w;
    o.Emission <span style="color:#333">=</span> distance;
}
</code></pre></div><p><img src="/assets/images/posts/021/PlaneDistance.gif" alt=""></p>
<p>You might notice that even though we call it the distance, the two sides of the plane don’t actually look the same, one has increasing values like we expect it from a distance, while the other side stays black. That’s because we actually have a signed distance, meaning the values on the dark side that are 1 unit far away from the plane have the value of -1.</p>
<p>We can use this fact by simply cutting off all values above one, that means everything above the plane will not be rendered while the parts that are currently black will be.</p>
<p>We can cut off pixels in hlsl by feeding a variable to the clip function, if the variable is less than zero it will be discarded, otherwise it will be rendered like usual. So in this case we invert our distance and feed it to the clip function, that way the surface in front of the plane has negative values and the surface behind the plane positive ones.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    <span style="color:#888">//calculate signed distance to plane</span>
    <span style="color:#080;font-weight:bold">float</span> distance <span style="color:#333">=</span> dot(i.worldPos, _Plane.xyz);
    distance <span style="color:#333">=</span> distance <span style="color:#333">+</span> _Plane.w;
    clip(<span style="color:#333">-</span>distance);
    o.Emission <span style="color:#333">=</span> distance;
}
</code></pre></div><p><img src="/assets/images/posts/021/ClipWithDistance.png" alt=""></p>
<p>Now we can simply see through the upper part of the model. With this done, we don’t need the visualisation anymore and can use colors we use usually again.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    <span style="color:#888">//calculate signed distance to plane</span>
    <span style="color:#080;font-weight:bold">float</span> distance <span style="color:#333">=</span> dot(i.worldPos, _Plane.xyz);
    distance <span style="color:#333">=</span> distance <span style="color:#333">+</span> _Plane.w;
    o.Emission <span style="color:#333">=</span> distance;

    <span style="color:#888">//normal color stuff</span>
    fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
    col <span style="color:#333">*=</span> _Color;
    o.Albedo <span style="color:#333">=</span> col.rgb;
    o.Metallic <span style="color:#333">=</span> _Metallic;
    o.Smoothness <span style="color:#333">=</span> _Smoothness;
    o.Emission <span style="color:#333">=</span> _Emission;
}
</code></pre></div><p><img src="/assets/images/posts/021/SimpleClip.gif" alt=""></p>
<h2 id="show-inside">Show Inside</h2>
<p>With those changes we can now cut off the model based on a plane, but looking in the hole we created looks weird. Especially concave bodies look like they have small parts of them flying around sometimes. This is because by default we don’t draw the backfaces of models. It’s a optimisation we can make because we assume we won’t see inside the model anyways, but we can simply disable it.</p>
<p>To draw all faces, no matter if they’re pointing towards the camera or away from it, we set the Cull parameter to off at the top of our subshader, outside of the hlsl code.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">SubShader{
    <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
    Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

    <span style="color:#888">// render faces regardless if they point towards the camera or away from it</span>
    Cull Off
</code></pre></div><p><img src="/assets/images/posts/021/UnCulledClip.png" alt=""></p>
<p>Now we can see inside the head, but the normals still point to the outside and we might not want to see the inside of the head. But can detect the difference between the inside surface and outside surface pretty easily so let’s do that.</p>
<p>To get wether we’re rendering a inside or a outside surface we make a new parameter in our input struct and give it the vface attribute. This variable will have a value of 1 one the outside and a value of -1 on the inside.</p>
<p>To use the value for things like linear interpolation I prefer to have it in a 0 to 1 range so I halved it and added 0.5 to it to convert it.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//input struct which is automatically filled by unity</span>
<span style="color:#080;font-weight:bold">struct</span> Input {
    float2 uv_MainTex;
    float3 worldPos;
    <span style="color:#080;font-weight:bold">float</span> facing <span style="color:#333">:</span> VFACE;
};
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> facing <span style="color:#333">=</span> i.facing <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> <span style="color:#60e;font-weight:bold">0.5</span>;
o.Emission <span style="color:#333">=</span> facing;
</code></pre></div><p><img src="/assets/images/posts/021/Facing.png" alt=""></p>
<p>Now that we know the difference between the inside and outside faces, we can make the inside it’s own specific color. We lerp to the new color we expose via a property on the emissive channel because the emission is not affected by the wrong normals. We also multiply all other channels with the facing variable to make them black/matte/non-metallic to make the color we can see in the opening as neutral as possible.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//show values to edit in inspector</span>
Properties{
    _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
    _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
    _Smoothness (<span style="color:#f00;background-color:#faa">&#34;</span>Smoothness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
    _Metallic (<span style="color:#f00;background-color:#faa">&#34;</span>Metalness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
    [HDR]_Emission (<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>)

    [HDR]_CutoffColor(<span style="color:#f00;background-color:#faa">&#34;</span>Cutoff Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>)
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">    float4 _CutoffColor;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> facing <span style="color:#333">=</span> i.facing <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> <span style="color:#60e;font-weight:bold">0.5</span>;

<span style="color:#888">//normal color stuff</span>
fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
col <span style="color:#333">*=</span> _Color;
o.Albedo <span style="color:#333">=</span> col.rgb <span style="color:#333">*</span> facing;
o.Metallic <span style="color:#333">=</span> _Metallic <span style="color:#333">*</span> facing;
o.Smoothness <span style="color:#333">=</span> _Smoothness <span style="color:#333">*</span> facing;
o.Emission <span style="color:#333">=</span> lerp(_CutoffColor, _Emission, facing);
</code></pre></div><p><img src="/assets/images/posts/021/Result.gif" alt=""></p>
<p>There are still a few artefacts because of golbal illumination, but we can’t fix them without rewriting/removing global illumination and we won’t do that in this tutorial.</p>
<h2 id="source">Source</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">021</span>_Clipping_Plane<span style="color:#f00;background-color:#faa">&#34;</span>{
    <span style="color:#888">//show values to edit in inspector</span>
    Properties{
        _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
        _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
        _Smoothness (<span style="color:#f00;background-color:#faa">&#34;</span>Smoothness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        _Metallic (<span style="color:#f00;background-color:#faa">&#34;</span>Metalness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        [HDR]_Emission (<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>)

        [HDR]_CutoffColor(<span style="color:#f00;background-color:#faa">&#34;</span>Cutoff Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>)
    }

    SubShader{
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        <span style="color:#888">// render faces regardless if they point towards the camera or away from it</span>
        Cull Off

        CGPROGRAM
        <span style="color:#888">//the shader is a surface shader, meaning that it will be extended by unity in the background</span>
        <span style="color:#888">//to have fancy lighting and other features</span>
        <span style="color:#888">//our surface shader function is called surf and we use our custom lighting model</span>
        <span style="color:#888">//fullforwardshadows makes sure unity adds the shadow passes the shader might need</span>
        <span style="color:#888">//vertex:vert makes the shader use vert as a vertex shader function</span>
        <span style="color:#f00;background-color:#faa">#</span>pragma surface surf Standard fullforwardshadows
        <span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

        <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
        fixed4 _Color;

        <span style="color:#080;font-weight:bold">half</span> _Smoothness;
        <span style="color:#080;font-weight:bold">half</span> _Metallic;
        half3 _Emission;

        float4 _Plane;

        float4 _CutoffColor;

        <span style="color:#888">//input struct which is automatically filled by unity</span>
        <span style="color:#080;font-weight:bold">struct</span> Input {
            float2 uv_MainTex;
            float3 worldPos;
            <span style="color:#080;font-weight:bold">float</span> facing <span style="color:#333">:</span> VFACE;
        };

        <span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
        <span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
            <span style="color:#888">//calculate signed distance to plane</span>
            <span style="color:#080;font-weight:bold">float</span> distance <span style="color:#333">=</span> dot(i.worldPos, _Plane.xyz);
            distance <span style="color:#333">=</span> distance <span style="color:#333">+</span> _Plane.w;
            <span style="color:#888">//discard surface above plane</span>
            clip(<span style="color:#333">-</span>distance);

            <span style="color:#080;font-weight:bold">float</span> facing <span style="color:#333">=</span> i.facing <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> <span style="color:#60e;font-weight:bold">0.5</span>;

            <span style="color:#888">//normal color stuff</span>
            fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
            col <span style="color:#333">*=</span> _Color;
            o.Albedo <span style="color:#333">=</span> col.rgb <span style="color:#333">*</span> facing;
            o.Metallic <span style="color:#333">=</span> _Metallic <span style="color:#333">*</span> facing;
            o.Smoothness <span style="color:#333">=</span> _Smoothness <span style="color:#333">*</span> facing;
            o.Emission <span style="color:#333">=</span> lerp(_CutoffColor, _Emission, facing);
        }
        ENDCG
    }
    FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#888">//fallback adds a shadow pass so we get shadows on other objects</span>
}
</code></pre></div><p>This technique is great to make things disappear into nothing or make simple dynamic water in a vessel. I hope it’ll help you archieve cool effects yourself.</p>
<p>You can find the code for the tutorial here:<!-- raw HTML omitted -->
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/021_Clipping_Plane/ClippingPlane.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/021_Clipping_Plane/ClippingPlane.cs</a><!-- raw HTML omitted -->
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/021_Clipping_Plane/ClippingPlane.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/021_Clipping_Plane/ClippingPlane.shader</a></p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "disqus_vlgXjcPhg1" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
