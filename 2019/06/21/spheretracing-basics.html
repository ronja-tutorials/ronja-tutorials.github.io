<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>Spheretracing Basics</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="Ronja Böhringer">

<meta name="description" content="Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance field..." />





<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="Spheretracing Basics">
<meta itemprop="description" content="Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance field...">

  <meta itemprop="image" content="https://www.ronja-tutorials.com/assets/images/posts/043/Result.png">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="Spheretracing Basics">
<meta name="twitter:description" content="Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance field...">


  <meta name="twitter:creator" content="@TotallyRonja">


<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="https://www.ronja-tutorials.com/assets/images/posts/043/Result.png">
  <meta property="twitter:image" content="https://www.ronja-tutorials.com/assets/images/posts/043/Result.png">

<meta property="twitter:url" content="https://www.ronja-tutorials.com/2019/06/21/spheretracing-basics.html">

<!-- Open Graph data -->
<meta property="og:title" content="Spheretracing Basics" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/2019/06/21/spheretracing-basics.html" />

  <meta property="og:image" content="https://www.ronja-tutorials.com/assets/images/posts/043/Result.png" />

<meta property="og:description" content="Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance field..." />
<meta property="og:site_name" content="Ronja's Shader Tutorials" />

  <meta property="article:published_time" content="2019-06-21T00:00:00+02:00" />














  





  




    

    <link rel="canonical" href="https://www.ronja-tutorials.com/2019/06/21/spheretracing-basics.html">

    

    <!-- <link rel="shortcut icon" href="https://www.ronja-tutorials.com/favicon.ico"> -->
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">Ronja&#39;s Shader Tutorials</a>
    
    <!-- SVG icons from https://iconmonstr.com -->

    <!-- Twitter icon -->
    <span class="my-span-icon">
        <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
          <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
        </a>
      </span>

      <!-- RSS icon -->
      
        <span class="my-span-icon">
          <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
          </a>
        </span>
      
      <!-- Contact icon -->
      
      
        <span class="my-span-icon">
          <a href="/about.html" aria-label="Contact" title="Contact ">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
          </a>
        </span>
      

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">Spheretracing Basics</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2019-06-21T00:00:00+02:00" itemprop="datePublished">
          
          Jun 21, 2019
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ronja Böhringer</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Spheretracing Basics</h1>
    <p class="post-meta">
      <time datetime="2019-06-21T00:00:00+02:00" itemprop="datePublished">
        
        Jun 21, 2019
      </time>
      </p>
  </header> -->

  
<ul>
  <li><a href="#the-theory">The theory</a></li>
  <li><a href="#preparing-the-data">Preparing the data</a></li>
  <li><a href="#3d-signed-distance-functions">3d signed distance functions</a></li>
  <li><a href="#fixed-step-ray-marching">Fixed step ray marching</a></li>
  <li><a href="#spheretracing">Spheretracing</a></li>
  <li><a href="#source">Source</a></li>
</ul>

  <div itemprop="articleBody">
    <p>Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance fields which I have explored in the 2d space in previous tutorials is called spheretracing. In this first tutorial we’ll just trace the silouette of a sphere, but in future tutorials I’ll give examples how to make more complex shapes and do lighting.</p>

<p>As the base of the shader we’ll use a <a href="/basics.html">basic unlit shader</a>, so you can do this tutorial when you’re fairly new to shaders. If you do struggle with some of the concepts of signed distance fields though, have a look into <a href="/2018/11/10/2d-sdf-basics.html">my tutorial about 2d signed distance fields</a>.</p>

<h2 id="the-theory">The theory</h2>

<p>The central concept of raytracing is the ray. To construct a ray we need a origin and a direction. If we only do the raytracing inside of a mesh we can use the surface point of that mesh as the origin of the ray. The direction of the view ray is the vector from the camera to that surface point.</p>

<p>With this data we can take steps through our SDF scene. We’ll advance the distance of our distance field in the direction of our ray. We can do that because the definition of a distance field is that the closest surface is as far away as the return value of the distance function. As soon as we are close enough to a surface that we consider it a hit we know that the ray does hit the silouette. If the ray travelled too far or a maximum number of steps was reached that can be interpeted as a fail state and we can assume the ray never hits a scene object.</p>

<h2 id="preparing-the-data">Preparing the data</h2>

<p>As mentioned previously what we need to define a ray for each pixel is the origin and the direction of the ray. We can do the raytracing in any “space” we want to. If we do it in world space we can move around the object and it moves like a window into the traced world. If we do it in object space the raytraced objects will be moved, scaled and rotated with the object that’s moved. For this tutorial I’ll do the spheretracing in object space because it’s more intuitive and it’s a bit harder to do so you might be able to figure out how to do it in worldspace yourself if you want that.</p>

<p>As the origin of the ray we’ll use the local coordinates which is the data that’s given to the shader via the appdata struct. The object space view direction is a bit trickier - we get it by transforming the camera world position into object space and then subtracting it from the local position. To transform the camera position into local space we have to multiply the world to object matrix with it, but before this multiplication we have to transform it from a float3 into a float4 with a “1” as the w component. If we don’t do that the w component would be filled with a 0 and the movement would be ignored, only rotation and scale would be applied.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//input data</span>
<span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
    <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//data that goes from vertex to fragment shader</span>
<span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span> <span class="c1">//position in clip space</span>
    <span class="n">float4</span> <span class="n">localPosition</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span> <span class="c1">//position in local space</span>
    <span class="n">float4</span> <span class="n">viewDirection</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span> <span class="c1">//view direction in local space (not normalized!)</span>
<span class="p">};</span>

<span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
    <span class="c1">//position for rendering</span>
    <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="c1">//save local position for origin</span>
    <span class="n">o</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">;</span>
    <span class="c1">//get camera position in local space</span>
    <span class="n">float4</span> <span class="n">objectSpaceCameraPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_WorldToObject</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="c1">//get local view vector</span>
    <span class="n">o</span><span class="p">.</span><span class="n">viewDirection</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span> <span class="o">-</span> <span class="n">objectSpaceCameraPos</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3d-signed-distance-functions">3d signed distance functions</h2>

<p>Signed distance functions work similarly in 3d as they do in 2d. In this tutorial I’ll only use a sphere, but if you’re curious about other shapes and how to combine them you can use those two sites: <a href="https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm">https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm</a>, <a href="http://mercury.sexy/hg_sdf/">http://mercury.sexy/hg_sdf/</a></p>

<p>The sphere is very similar to the circle in 2d. We first subtract the center of the sphere from the position we want to sample it at, then we calculate the length of the resulting vector and subtract the radius of the sphere to increase it’s size. Because this is a very simple example I’m going to place the sphere at the origin of the scene which means I don’t have to do the subtraction of the sphere center and give it a hardcoded size of <code class="language-plaintext highlighter-rouge">0.5</code>.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">scene</span><span class="p">(</span><span class="n">float3</span> <span class="n">pos</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="fixed-step-ray-marching">Fixed step ray marching</h2>

<p>Before we take full advantage of our signed distance field, I want to show a more simplistic way of raytracing which just going fixed steps forwards through the space until it hits something. The advantage of this is that we can use it with any function that tells us wether a given point is inside or outside of a shape.</p>

<p>To do the raytracing we first have to set up three variables. The point where the ray starts, the direction of the ray and the progress we’ve already made on our ray. The starting point is the local position in our case which we passed via the v2f struct. The direction was also already calculated in the vertex shader, but we have to normalize it so it’s easier to work with before using it. We normalize this vector in the fragment and not the vertex shader because it would loose it wouldn’t have a length of 1 anymore after being interpolated between vertices. This is especially visible when the camera is close to low poly objects. Third we define the progress variable which starts at <code class="language-plaintext highlighter-rouge">0</code>.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ray information</span>
<span class="n">float3</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">localPosition</span><span class="p">;</span>
<span class="n">float3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>For the tracing itself we also have to decide on two more factors, how many steps we iterate through at maximum and how big the steps we will do will be. Because those are fixed, I’m going to use define statements, but if you’re more comfortable with variables or just writing in the numbers that’s also fine. Because we know the size and complexity of our shape fairly well we can make a pretty good guess what would be appropriate values. I decided to define 10 steps with a distance of 0.1 each. Note that you can use the define statements anywhere, but I decided that they’re best with the global variables that can also be manipulated by properties.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//how big steps to take when usign fixed steps</span>
<span class="cp">#define STEP_SIZE 0.1
</span><span class="c1">//maximum amount of steps</span>
<span class="cp">#define MAX_STEPS 10
</span></code></pre></div></div>

<p>And with all of this set up we can then finally write the loop that does the actual work. I used a for loop with a iterator that counts up and aborts when the iterator reaches the maximum amount of steps we defined. Inside the loop we first calculate the current point on the ray we’re on. We get this by solving the line equation of <code class="language-plaintext highlighter-rouge">point = origin + direction * progress</code>. Putting this result into the scene function then gives us the distance to the closest shape. Right now we’re only interrested in whether our current location is inside the shape or not so we check whether the distance smaller than <code class="language-plaintext highlighter-rouge">0</code> which would mean that it’s inside of a shape. If that check is successful we directly return the color we set via our property. If it isn’t inside the shape we increase our progress by the step size and the code goes into the next iteration of the loop. If the loop terminates without ever hitting a shape we assume it missed completely and return <code class="language-plaintext highlighter-rouge">0</code> for a completely black pixel.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="c1">//ray information</span>
    <span class="n">float3</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">localPosition</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">//tracing loop</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">MAX_STEPS</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//get current location on ray</span>
        <span class="n">float3</span> <span class="n">samplePoint</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">dir</span> <span class="o">*</span> <span class="n">progress</span><span class="p">;</span>
        <span class="c1">//get distance to closest shape</span>
        <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">samplePoint</span><span class="p">);</span>
        <span class="c1">//return color if inside shape</span>
        <span class="k">if</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">_Color</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//go forwards</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span> <span class="o">+</span> <span class="n">STEP_SIZE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//return black pixel if no shape was hit</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/043/TracedSphere.png" alt="" /></p>

<p>The main disadvantage of fixed step raymarching is that it’s often hard to choose a step size. With a step size that’s too short you do a lot of samples in areas where theres no shape anywhere close and loose a lot of calculation time doing that. If you choose a step size that’s too big it’s possible to jump through walls and shapes that should be visible are simply missing because they are between two samples.</p>

<h2 id="spheretracing">Spheretracing</h2>

<p>With signed distance fields we have more information than just is it inside a shape or not. We can also determine how close the closest shape is. If we go the distance to the closest shape forwards we cannot skip any shapes. So instead of using a fixed step spheretracing walks forward the current distance of the SDF.</p>

<p>The changes we make to our existing code are just that we completely get rid of the step size and instead add the distance we have anyways to the progress. Because we only go the distance to the closest shape further it’s impossible now to follow the ray inside of the surface. Instead we define a small thickness and accept it as a hit if the distance is smaller than that.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//maximum amount of steps</span>
<span class="cp">#define MAX_STEPS 10
</span><span class="c1">//furthest distance that's accepted as inside surface</span>
<span class="cp">#define THICKNESS 0.01
</span></code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="c1">//ray information</span>
    <span class="n">float3</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">localPosition</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">//tracing loop</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">MAX_STEPS</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//get current location on ray</span>
        <span class="n">float3</span> <span class="n">samplePoint</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">dir</span> <span class="o">*</span> <span class="n">progress</span><span class="p">;</span>
        <span class="c1">//get distance to closest shape</span>
        <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">samplePoint</span><span class="p">);</span>
        <span class="c1">//return color if inside shape</span>
        <span class="k">if</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">THICKNESS</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">_Color</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//go forwards</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span> <span class="o">+</span> <span class="n">distance</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//return black pixel if no shape was hit</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Your result shouldn’t look too different from the previous iteration, but I promise you it works way better with huge spaces as well as more delicate shapes.</p>

<p>One minor tweak I’ll also mention in this tutorial is how to make the object have the silouette of the traced shape instead of the mesh. For that you can discard the pixels with missed rays before returning black by calling the clip function with a negative argument.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//discard pixel if no shape was hit</span>
<span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/043/ClippedSphere.png" alt="" /></p>

<h2 id="source">Source</h2>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/043_SphereTracingBasics/SphereTracingBasics.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/043_SphereTracingBasics/SphereTracingBasics.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/042_SphereTracingBasics"</span><span class="p">{</span>
    <span class="c1">//show values to edit in inspector</span>
    <span class="n">Properties</span><span class="p">{</span>
        <span class="n">_Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">SubShader</span><span class="p">{</span>
        <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span class="c1">//also disable batching so local coordinates are always valid</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span> <span class="s">"DisableBatching"</span><span class="o">=</span><span class="s">"True"</span><span class="p">}</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">ZWrite</span> <span class="n">Off</span>

            <span class="n">CGPROGRAM</span>
            <span class="cp">#include "UnityCG.cginc"
</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="c1">//silouette color</span>
            <span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>

            <span class="c1">//maximum amount of steps</span>
            <span class="cp">#define MAX_STEPS 10
</span>            <span class="c1">//furthest distance that's accepted as inside surface</span>
            <span class="cp">#define THICKNESS 0.01
</span>
            <span class="c1">//input data</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="c1">//data that goes from vertex to fragment shader</span>
            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span> <span class="c1">//position in clip space</span>
                <span class="n">float4</span> <span class="n">localPosition</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span> <span class="c1">//position in local space</span>
                <span class="n">float4</span> <span class="n">viewDirection</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span> <span class="c1">//view direction in local space (not normalized!)</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//position for rendering</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//save local position for origin</span>
                <span class="n">o</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">;</span>
                <span class="c1">//get camera position in local space</span>
                <span class="n">float4</span> <span class="n">objectSpaceCameraPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_WorldToObject</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
                <span class="c1">//get local view vector</span>
                <span class="n">o</span><span class="p">.</span><span class="n">viewDirection</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span> <span class="o">-</span> <span class="n">objectSpaceCameraPos</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>


            <span class="kt">float</span> <span class="n">scene</span><span class="p">(</span><span class="n">float3</span> <span class="n">pos</span><span class="p">){</span>
                <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
                <span class="c1">//ray information</span>
                <span class="n">float3</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">localPosition</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">viewDirection</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
                <span class="kt">float</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                <span class="c1">//tracing loop</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">MAX_STEPS</span><span class="p">;</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">//get current location on ray</span>
                    <span class="n">float3</span> <span class="n">samplePoint</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">dir</span> <span class="o">*</span> <span class="n">progress</span><span class="p">;</span>
                    <span class="c1">//get distance to closest shape</span>
                    <span class="kt">float</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">samplePoint</span><span class="p">);</span>
                    <span class="c1">//return color if inside shape</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">THICKNESS</span><span class="p">){</span>
                        <span class="k">return</span> <span class="n">_Color</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="c1">//go forwards</span>
                    <span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span> <span class="o">+</span> <span class="n">distance</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">//discard pixel if no shape was hit</span>
                <span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


    <p>
        You can also find me on twitter at <a href="https://www.twitter.com/totallyRonja">@totallyRonja</a>. If you liked my tutorial and want to support me you can do that on Patreon (<a href="https://www.patreon.com/RonjaTutorials">patreon.com/RonjaTutorials</a>) or Ko-Fi (<a href="https://ko-fi.com/RonjaTutorials">ko-fi.com/RonjaTutorials</a>).
    </p>
  </div>

  
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ronja-tutorials.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  
</article>


      <!-- SVG icons from https://iconmonstr.com -->

      <!-- Twitter icon -->
      <span class="my-span-icon">
          <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>

        <!-- RSS icon -->
        
          <span class="my-span-icon">
            <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
            </a>
          </span>
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact ">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        
    </section>

    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-124040112-1', 'auto');
        ga('send', 'pageview');
      </script>
    
  </body>
</html>
