<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Vertex Displacement | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary So far we only used the vertex shader to move vertices from their object coordinates to their clip space coordinates (or to the world space coordinates which we then used for other things). But there are more things we can do with vertex shaders. As a introduction Iâ€™m going to show you how to apply a simple sine wave to a model, making it wobble.
I will make the shader with a surface shader so you should know the basics of surface shaders, but it works the same with any other type of shader.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/css/main.css">
    

    
      

    

    
    
    <meta property="og:title" content="Vertex Displacement" />
<meta property="og:description" content="Summary So far we only used the vertex shader to move vertices from their object coordinates to their clip space coordinates (or to the world space coordinates which we then used for other things). But there are more things we can do with vertex shaders. As a introduction Iâ€™m going to show you how to apply a simple sine wave to a model, making it wobble.
I will make the shader with a surface shader so you should know the basics of surface shaders, but it works the same with any other type of shader." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/015-wobble-displacement/" />
<meta property="article:published_time" content="2018-06-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-06-16T00:00:00+00:00" />
<meta itemprop="name" content="Vertex Displacement">
<meta itemprop="description" content="Summary So far we only used the vertex shader to move vertices from their object coordinates to their clip space coordinates (or to the world space coordinates which we then used for other things). But there are more things we can do with vertex shaders. As a introduction Iâ€™m going to show you how to apply a simple sine wave to a model, making it wobble.
I will make the shader with a surface shader so you should know the basics of surface shaders, but it works the same with any other type of shader.">
<meta itemprop="datePublished" content="2018-06-16T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-06-16T00:00:00+00:00" />
<meta itemprop="wordCount" content="1616">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vertex Displacement"/>
<meta name="twitter:description" content="Summary So far we only used the vertex shader to move vertices from their object coordinates to their clip space coordinates (or to the world space coordinates which we then used for other things). But there are more things we can do with vertex shaders. As a introduction Iâ€™m going to show you how to apply a simple sine wave to a model, making it wobble.
I will make the shader with a surface shader so you should know the basics of surface shaders, but it works the same with any other type of shader."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      <h1 class="f1 athelas mt3 mb1">Vertex Displacement</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-06-16T00:00:00Z">June 16, 2018</time>

      
      
		</header>
		
		<div style="margin-bottom: 70px;">
			<h3>Table Of Contents</h3>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
		</div>

    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><div>
				
				<h2 id="summary">Summary <a href="#summary" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>So far we only used the vertex shader to move vertices from their object coordinates to their clip space coordinates (or to the world space coordinates which we then used for other things). But there are more things we can do with vertex shaders. As a introduction Iâ€™m going to show you how to apply a simple sine wave to a model, making it wobble.</p>
<p>I will make the shader with a surface shader so you should know the basics of <a href="https://www.ronja-tutorials.com/post/005-simple-surface/">surface shaders</a>, but it works the same with any other type of shader.</p>
<p><img src="/assets/images/posts/015/Result.gif" alt="Result"></p>
<p>When manipulating the positions of our surface, we use the vertex shader. So far we didnâ€™t write a vertex shader in our surface shader, it was instead generated by unity in the background. To change that we add the declaration for it in our surface shader definition by adding the vertex:vertexShaderName part.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the shader is a surface shader, meaning that it will be extended by unity in the background </span>
    <span style="color:#888">//to have fancy lighting and other features</span>
    <span style="color:#888">//our surface shader function is called surf and we use our custom lighting model</span>
    <span style="color:#888">//fullforwardshadows makes sure unity adds the shadow passes the shader might need</span>
    <span style="color:#888">//vertex:vert makes the shader use vert as a vertex shader function</span>
    <span style="color:#f00;background-color:#faa">#</span>pragma surface surf Standard fullforwardshadows vertex<span style="color:#333">:</span>vert
</code></pre></div><p>Then we have to write the actual vertex function. Previously, in unlit shaders, we calculated the clip space position in there, but even when using vertex shaders, that part is generated for us in surface shaders. We manipulate the object space vertex positions and then let them be processed by unity.</p>
<p>Because the input struct has to have variables with specific names, itâ€™s easiest to use a input struct unity provides for us here, itâ€™s called appadata_full, but we could also use our own struct here if it uses the same terminology.</p>
<p>Just like the surface shader, the vertex shader in surface shaders (there should be better terminology for this) doesnâ€™t return anything, instead it takes a parameter with the inout keyword we can manipulate.</p>
<p>Because surface shaders generate the conversion to clip space for us, a empty vertex function is all we need to make our shader work just like before.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> vert(<span style="color:#080;font-weight:bold">inout</span> appdata_full data){

}
</code></pre></div><p>A simple thing we can do to our mesh is multiply all of our vertices by a value to make the model bigger. (a *= b is the same as a = a * b but a bit shorter)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> vert(<span style="color:#080;font-weight:bold">inout</span> appdata_full data){
    data.vertex.xyz <span style="color:#333">*=</span> <span style="color:#00d;font-weight:bold">2</span>;
}
</code></pre></div><p><img src="/assets/images/posts/015/ShadowRealm.png" alt="A bigger monkey head with the ghost of a small one inside"></p>
<p>While the model is bigger we also see a weird artefact here. The shadow is still calculated based on the original, unmodified vertex positions. Thatâ€™s because the surface shader doesnâ€™t automatically generate a shadow pass (used for casting shadows) for our new vertex positions. To fix that we expand our surface definition with the hint addshadows and the artefects should be gone.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//addshadows tells the surface shader to generate a new shadow pass based on out vertex shader</span>
<span style="color:#579">#pragma surface surf Standard fullforwardshadows vertex:vert addshadow</span>
</code></pre></div><p><img src="/assets/images/posts/015/FixedShadows.png" alt="A bigger monkey head with correct shadows"></p>
<p>To make the shader more interresting weâ€™ll change the vertex shader. Instead of making the model just bigger, weâ€™ll offset the y position based on the sine of the x position, making it wavy.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> vert(<span style="color:#080;font-weight:bold">inout</span> appdata_full data){
    data.vertex.y <span style="color:#333">+=</span> sin(data.vertex.x);
}
</code></pre></div><p><img src="/assets/images/posts/015/QueerMonkey.png" alt="A bigger monkey head with correct shadows"></p>
<p>This results in big waves with a low frequency, so weâ€™ll add two variables to change those properties.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//...</span>

_Amplitude (<span style="color:#f00;background-color:#faa">&#34;</span>Wave Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.4</span>
_Frequency (<span style="color:#f00;background-color:#faa">&#34;</span>Wave Freqency<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">8</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span>

<span style="color:#888">//...</span>

<span style="color:#080;font-weight:bold">float</span> _Amplitude;
<span style="color:#080;font-weight:bold">float</span> _Frequency;

<span style="color:#888">//...</span>

<span style="color:#080;font-weight:bold">void</span> vert(<span style="color:#080;font-weight:bold">inout</span> appdata_full data){
float4 modifiedPos <span style="color:#333">=</span> data.vertex;
modifiedPos.y <span style="color:#333">+=</span> sin(data.vertex.x <span style="color:#333">*</span> _Frequency) <span style="color:#333">*</span> _Amplitude;
data.vertex <span style="color:#333">=</span> modifiedPos;

<span style="color:#888">//...</span>
</code></pre></div><p><img src="/assets/images/posts/015/Sliders.png" alt="inspector where wave size is 0.23 and wave frequency is 5.14"></p>
<p><img src="/assets/images/posts/015/WobblyMonkey.png" alt="inspector where wave size is 0.23 and wave frequency is 5.14"></p>
<p>With this we have nice customizable waves on our model, but sadly the normals of our deformed models are wrong. We only moved the positions, not the normals.</p>
<p><img src="/assets/images/posts/015/WrongNormalsExplanation.png" alt="illustration in which direction the normals point/should point"></p>
<p>The easiest and most flexible way to generate correct normals for custom geometry is to calculate the custom geometry for neighboring surface points and recalculate the normal from that.</p>
<p>To get neighboring surface points we can follow the tangent and bitangent of the surface. The normal, the tangent and the bitangent are all orthogonal to each other. The tangent and the bitangent both lie on the surface of the object.</p>
<p><img src="/assets/images/posts/015/ShowNormals.png" alt="illustration how normal, tangent and bitangent look like on a surface point"></p>
<p>Normal in blue, tangent in red and bitangent in yellow.</p>
<p>Luckily the tangent are already saved in the model data, so we can just use them. The bitangent isnâ€™t, but we can calculate it easily by taking the cross product of the normal and the tangent (taking the cross product of two vectors returns a vector thatâ€™s orthogonal to both).</p>
<p>After we obtain the bitangent we create two new points that are almost at the vertex position, but slightly changed, and give them the same treatment we gave the original position.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 posPlusTangent <span style="color:#333">=</span> data.vertex <span style="color:#333">+</span> data.tangent <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.01</span>;
posPlusTangent.y <span style="color:#333">+=</span> sin(posPlusTangent.x <span style="color:#333">*</span> _Frequency) <span style="color:#333">*</span> _Amplitude;

float3 bitangent <span style="color:#333">=</span> cross(data.normal, data.tangent);
float3 posPlusBitangent <span style="color:#333">=</span> data.vertex <span style="color:#333">+</span> bitangent <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.01</span>;
posPlusBitangent.y <span style="color:#333">+=</span> sin(posPlusBitangent.x <span style="color:#333">*</span> _Frequency) <span style="color:#333">*</span> _Amplitude;
</code></pre></div><p>With those positions we can now calculate the new normal of the surface. For that we calculate a new tangent and bitangent from the positions by subtracting the modified base surface position from the modified surface positions where we added the tangent/bitangent previously. And after obtaining the new tangent and bitangent, we can take their cross product to get the new normal which we then use.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> vert(<span style="color:#080;font-weight:bold">inout</span> appdata_full data){
    float4 modifiedPos <span style="color:#333">=</span> data.vertex;
    modifiedPos.y <span style="color:#333">+=</span> sin(data.vertex.x <span style="color:#333">*</span> _Frequency) <span style="color:#333">*</span> _Amplitude;
    
    float3 posPlusTangent <span style="color:#333">=</span> data.vertex <span style="color:#333">+</span> data.tangent <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.01</span>;
    posPlusTangent.y <span style="color:#333">+=</span> sin(posPlusTangent.x <span style="color:#333">*</span> _Frequency) <span style="color:#333">*</span> _Amplitude;

    float3 bitangent <span style="color:#333">=</span> cross(data.normal, data.tangent);
    float3 posPlusBitangent <span style="color:#333">=</span> data.vertex <span style="color:#333">+</span> bitangent <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.01</span>;
    posPlusBitangent.y <span style="color:#333">+=</span> sin(posPlusBitangent.x <span style="color:#333">*</span> _Frequency) <span style="color:#333">*</span> _Amplitude;

    float3 modifiedTangent <span style="color:#333">=</span> posPlusTangent <span style="color:#333">-</span> modifiedPos;
    float3 modifiedBitangent <span style="color:#333">=</span> posPlusBitangent <span style="color:#333">-</span> modifiedPos;

    float3 modifiedNormal <span style="color:#333">=</span> cross(modifiedTangent, modifiedBitangent);
    data.normal <span style="color:#333">=</span> normalize(modifiedNormal);
    data.vertex <span style="color:#333">=</span> modifiedPos;
}
</code></pre></div><p><img src="/assets/images/posts/015/CorrectNormals.png" alt="the wobbly monkey with correct normals"></p>
<p>The last thing Iâ€™d like to add to this shader is movement over time. So far we only use the x position of the vertex as a changing parameter in our function which generates the new vertex positions, but adding the time to that is pretty easy.</p>
<p>Unity passes the time to all shaders automatically as a 4-dimentional vector, the first component of the vector is the time divided by 20, the second just the time in seconds, the third the time multiplied by 2 and the fourth contains the time multiplied by 3. Because we want to adjust the time via a external property we use the second component, with the time in seconds. We then add the time multiplied by the animation speed to the x position.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">_AnimationSpeed (<span style="color:#f00;background-color:#faa">&#34;</span>Animation Speed<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">5</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>

<span style="color:#888">//...</span>

<span style="color:#080;font-weight:bold">float</span> _AnimationSpeed;

<span style="color:#888">//...</span>

<span style="color:#080;font-weight:bold">void</span> vert(<span style="color:#080;font-weight:bold">inout</span> appdata_full data){
    float4 modifiedPos <span style="color:#333">=</span> data.vertex;
    modifiedPos.y <span style="color:#333">+=</span> sin(data.vertex.x <span style="color:#333">*</span> _Frequency <span style="color:#333">+</span> _Time.y <span style="color:#333">*</span> _AnimationSpeed) <span style="color:#333">*</span> _Amplitude;
    
    float3 posPlusTangent <span style="color:#333">=</span> data.vertex <span style="color:#333">+</span> data.tangent <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.01</span>;
    posPlusTangent.y <span style="color:#333">+=</span> sin(posPlusTangent.x <span style="color:#333">*</span> _Frequency <span style="color:#333">+</span> _Time.y <span style="color:#333">*</span> _AnimationSpeed) <span style="color:#333">*</span> _Amplitude;

    float3 bitangent <span style="color:#333">=</span> cross(data.normal, data.tangent);
    float3 posPlusBitangent <span style="color:#333">=</span> data.vertex <span style="color:#333">+</span> bitangent <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.01</span>;
    posPlusBitangent.y <span style="color:#333">+=</span> sin(posPlusBitangent.x <span style="color:#333">*</span> _Frequency <span style="color:#333">+</span> _Time.y <span style="color:#333">*</span> _AnimationSpeed) <span style="color:#333">*</span> _Amplitude;

    float3 modifiedTangent <span style="color:#333">=</span> posPlusTangent <span style="color:#333">-</span> modifiedPos;
    float3 modifiedBitangent <span style="color:#333">=</span> posPlusBitangent <span style="color:#333">-</span> modifiedPos;

    float3 modifiedNormal <span style="color:#333">=</span> cross(modifiedTangent, modifiedBitangent);
    data.normal <span style="color:#333">=</span> normalize(modifiedNormal);
    data.vertex <span style="color:#333">=</span> modifiedPos;
}
</code></pre></div><p><img src="/assets/images/posts/015/Result.gif" alt="Result"></p>
<p>I increased the offset of the sampled surface positions a bit (up to 0.01 units) to smooth over the artefacts better. A small distance can represent a more complex distortion better while bigger distances smoothes over some things.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">015</span>_vertex_manipulation<span style="color:#f00;background-color:#faa">&#34;</span> {
    <span style="color:#888">//show values to edit in inspector</span>
    Properties {
        _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
        _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
        _Smoothness (<span style="color:#f00;background-color:#faa">&#34;</span>Smoothness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        _Metallic (<span style="color:#f00;background-color:#faa">&#34;</span>Metalness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        [HDR] _Emission (<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>)

        _Amplitude (<span style="color:#f00;background-color:#faa">&#34;</span>Wave Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.4</span>
        _Frequency (<span style="color:#f00;background-color:#faa">&#34;</span>Wave Freqency<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">8</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span>
        _AnimationSpeed (<span style="color:#f00;background-color:#faa">&#34;</span>Animation Speed<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">5</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
    }
    SubShader {
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        CGPROGRAM

        <span style="color:#888">//the shader is a surface shader, meaning that it will be extended by unity in the background </span>
        <span style="color:#888">//to have fancy lighting and other features</span>
        <span style="color:#888">//our surface shader function is called surf and we use our custom lighting model</span>
        <span style="color:#888">//fullforwardshadows makes sure unity adds the shadow passes the shader might need</span>
        <span style="color:#888">//vertex:vert makes the shader use vert as a vertex shader function</span>
        <span style="color:#888">//addshadows tells the surface shader to generate a new shadow pass based on out vertex shader</span>
        <span style="color:#f00;background-color:#faa">#</span>pragma surface surf Standard fullforwardshadows vertex<span style="color:#333">:</span>vert addshadow
        <span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

        <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
        fixed4 _Color;

        <span style="color:#080;font-weight:bold">half</span> _Smoothness;
        <span style="color:#080;font-weight:bold">half</span> _Metallic;
        half3 _Emission;

        <span style="color:#080;font-weight:bold">float</span> _Amplitude;
        <span style="color:#080;font-weight:bold">float</span> _Frequency;
        <span style="color:#080;font-weight:bold">float</span> _AnimationSpeed;

        <span style="color:#888">//input struct which is automatically filled by unity</span>
        <span style="color:#080;font-weight:bold">struct</span> Input {
            float2 uv_MainTex;
        };

        <span style="color:#080;font-weight:bold">void</span> vert(<span style="color:#080;font-weight:bold">inout</span> appdata_full data){
            float4 modifiedPos <span style="color:#333">=</span> data.vertex;
            modifiedPos.y <span style="color:#333">+=</span> sin(data.vertex.x <span style="color:#333">*</span> _Frequency <span style="color:#333">+</span> _Time.y <span style="color:#333">*</span> _AnimationSpeed) <span style="color:#333">*</span> _Amplitude;
            
            float3 posPlusTangent <span style="color:#333">=</span> data.vertex <span style="color:#333">+</span> data.tangent <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.01</span>;
            posPlusTangent.y <span style="color:#333">+=</span> sin(posPlusTangent.x <span style="color:#333">*</span> _Frequency <span style="color:#333">+</span> _Time.y <span style="color:#333">*</span> _AnimationSpeed) <span style="color:#333">*</span> _Amplitude;

            float3 bitangent <span style="color:#333">=</span> cross(data.normal, data.tangent);
            float3 posPlusBitangent <span style="color:#333">=</span> data.vertex <span style="color:#333">+</span> bitangent <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.01</span>;
            posPlusBitangent.y <span style="color:#333">+=</span> sin(posPlusBitangent.x <span style="color:#333">*</span> _Frequency <span style="color:#333">+</span> _Time.y <span style="color:#333">*</span> _AnimationSpeed) <span style="color:#333">*</span> _Amplitude;

            float3 modifiedTangent <span style="color:#333">=</span> posPlusTangent <span style="color:#333">-</span> modifiedPos;
            float3 modifiedBitangent <span style="color:#333">=</span> posPlusBitangent <span style="color:#333">-</span> modifiedPos;

            float3 modifiedNormal <span style="color:#333">=</span> cross(modifiedTangent, modifiedBitangent);
            data.normal <span style="color:#333">=</span> normalize(modifiedNormal);
            data.vertex <span style="color:#333">=</span> modifiedPos;
        }

        <span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
        <span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
            <span style="color:#888">//sample and tint albedo texture</span>
            fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
            col <span style="color:#333">*=</span> _Color;
            o.Albedo <span style="color:#333">=</span> col.rgb;
            <span style="color:#888">//just apply the values for metalness, smoothness and emission</span>
            o.Metallic <span style="color:#333">=</span> _Metallic;
            o.Smoothness <span style="color:#333">=</span> _Smoothness;
            o.Emission <span style="color:#333">=</span> _Emission;
        }
        ENDCG
    }
    FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><p>You can also find the source code for this tutorial here:
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/015_VertexManipulation/vertexmanipulation.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/015_VertexManipulation/vertexmanipulation.shader</a></p>
<p>I hope I was able to explain how to start manipulating vertices and you find your own ways of making nice looking shaders with this technique.</p>

			</div>I hope you enjoyed my tutorial âœ¨. If you want to support me further feel free to follow me on <a href="https://twitter.com/totallyRonja">twitter</a>, 
			throw me a one-time donation via <a href="https://ko-fi.com/ronjatutorials">ko-fi</a> 
			or support me on <a href="https://www.patreon.com/RonjaTutorials">patreon</a> 
			(I try to put updates also there, but I fail most of the time, bear with me ðŸ’–).<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
