<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>Graphics.DrawProcedural</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="Ronja Böhringer">

<meta name="description" content="The last tutorial was about compute shader basics, how to generate values, read them back to the cpu and use them. One critical aspect in all that is..." />





<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="Graphics.DrawProcedural">
<meta itemprop="description" content="The last tutorial was about compute shader basics, how to generate values, read them back to the cpu and use them. One critical aspect in all that is...">

  <meta itemprop="image" content="https://www.ronja-tutorials.com/assets/images/posts/051/result.png">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="Graphics.DrawProcedural">
<meta name="twitter:description" content="The last tutorial was about compute shader basics, how to generate values, read them back to the cpu and use them. One critical aspect in all that is...">


  <meta name="twitter:creator" content="@TotallyRonja">


<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="https://www.ronja-tutorials.com/assets/images/posts/051/result.png">
  <meta property="twitter:image" content="https://www.ronja-tutorials.com/assets/images/posts/051/result.png">

<meta property="twitter:url" content="https://www.ronja-tutorials.com/2020/09/16/draw-procedural.html">

<!-- Open Graph data -->
<meta property="og:title" content="Graphics.DrawProcedural" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/2020/09/16/draw-procedural.html" />

  <meta property="og:image" content="https://www.ronja-tutorials.com/assets/images/posts/051/result.png" />

<meta property="og:description" content="The last tutorial was about compute shader basics, how to generate values, read them back to the cpu and use them. One critical aspect in all that is..." />
<meta property="og:site_name" content="Ronja's Shader Tutorials" />

  <meta property="article:published_time" content="2020-09-16T00:00:00+02:00" />














  
    <meta property="article:tag" content="shader,">
  
    <meta property="article:tag" content="unity,">
  
    <meta property="article:tag" content="compute">
  





  




    

    <link rel="canonical" href="https://www.ronja-tutorials.com/2020/09/16/draw-procedural.html">

    

    <!-- <link rel="shortcut icon" href="https://www.ronja-tutorials.com/favicon.ico"> -->
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">Ronja&#39;s Shader Tutorials</a>
    
    <!-- SVG icons from https://iconmonstr.com -->

    <!-- Twitter icon -->
    <span class="my-span-icon">
        <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
          <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
        </a>
      </span>

      <!-- RSS icon -->
      
        <span class="my-span-icon">
          <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
          </a>
        </span>
      
      <!-- Contact icon -->
      
      
        <span class="my-span-icon">
          <a href="/about.html" aria-label="Contact" title="Contact ">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
          </a>
        </span>
      

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">Graphics.DrawProcedural</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2020-09-16T00:00:00+02:00" itemprop="datePublished">
          
          Sep 16, 2020
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ronja Böhringer</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Graphics.DrawProcedural</h1>
    <p class="post-meta">
      <time datetime="2020-09-16T00:00:00+02:00" itemprop="datePublished">
        
        Sep 16, 2020
      </time>
      </p>
  </header> -->

  
<ul>
  <li><a href="#buffer-handling-in-c">Buffer handling in C#</a></li>
  <li><a href="#the-shader">The Shader</a></li>
  <li><a href="#tiny-tweaks">Tiny Tweaks</a></li>
  <li><a href="#sources">Sources</a>
    <ul>
      <li><a href="#proceduralcomputespherescs">ProceduralComputeSpheres.cs</a></li>
      <li><a href="#proceduralspheresshader">ProceduralSpheres.shader</a></li>
      <li><a href="#basiccomputecompute-unchanged">BasicCompute.compute (unchanged)</a></li>
    </ul>
  </li>
</ul>

  <div itemprop="articleBody">
    <p>The <a href="/2020/07/26/compute-shader.html">last tutorial</a> was about compute shader basics, how to generate values, read them back to the cpu and use them. One critical aspect in all that is that copying data from the cpu to the gpu (from the ram to the vram) or back takes some time, so wouldn’t it be neat if there was a way to just render the data directly from the GPU without copying it around? Thats where Graphics.DrawProcedural and similar methods come into play, they allow us to do exactly that. So lets build on the result of that tutorial but without using GameObjects for rendering.</p>

<video width="300" height="300" preload="metadata" autoplay="" loop="" muted="" loading="lazy"><source src="/assets/images/posts/051/result.mp4" type="video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;" /></video>

<h2 id="buffer-handling-in-c">Buffer handling in C#</h2>

<p>First lets remove all code connected to rendering using GameObjects. We don’t need the output array anymore, not the GameObject instances where we stored the Transforms, we don’t need to create them in the start method and don’t need to update their positions in the Update method.</p>

<p>The way Graphics.DrawProcedural works is that all the shader gets as information is the index of the current vertex. That also means we’ll have to make the vertices available to shader ourselves via more compute buffers and then write a custom shader to read from those buffers. Lets add a mesh and a material to our public class variables so we can set them from the inspector and use their data for rendering. Since we’re filling the mentioned buffers ourselves its not nessecary for that data to come from a mesh or even exist in the ram at any point.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// class variables</span>
<span class="k">public</span> <span class="n">Mesh</span> <span class="n">Mesh</span><span class="p">;</span>
<span class="k">public</span> <span class="n">Material</span> <span class="n">Material</span><span class="p">;</span>
</code></pre></div></div>

<p>In this case we don’t need uv coordinates or normals, so we’ll just create 2 buffers, one for the triangles and one for the positions. The way those work is that each pair of 3 integers in the triangles array define a triangle to be rendered by its index positions in the vertex position array. Just like the previous result array we also need to discard this one at some point (In our case in the <code class="language-plaintext highlighter-rouge">OnDestroy</code> method).</p>

<p>The stride (size of a single variable in the buffer) is simply the size of the base type times the components (1 for scalar values and 3 for 3d vectors). And after creating the buffers we already fill them once at the start.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// class variables</span>
<span class="n">ComputeBuffer</span> <span class="n">meshTriangles</span><span class="p">;</span>
<span class="n">ComputeBuffer</span> <span class="n">meshPositions</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///in Start method</span>

<span class="c1">//gpu buffers for the mesh</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">triangles</span> <span class="p">=</span> <span class="n">Mesh</span><span class="p">.</span><span class="n">triangles</span><span class="p">;</span>
<span class="n">meshTriangles</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ComputeBuffer</span><span class="p">(</span><span class="n">triangles</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">meshTriangles</span><span class="p">.</span><span class="nf">SetData</span><span class="p">(</span><span class="n">triangles</span><span class="p">);</span>
<span class="n">Vector3</span><span class="p">[]</span> <span class="n">positions</span> <span class="p">=</span> <span class="n">Mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">;</span>
<span class="n">meshPositions</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ComputeBuffer</span><span class="p">(</span><span class="n">positions</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">*</span> <span class="m">3</span><span class="p">);</span>
<span class="n">meshPositions</span><span class="p">.</span><span class="nf">SetData</span><span class="p">(</span><span class="n">positions</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">OnDestroy</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">resultBuffer</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
    <span class="n">meshTriangles</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
    <span class="n">meshPositions</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To allow the material to read from the buffers we just call <code class="language-plaintext highlighter-rouge">SetBuffer</code> just like we’d call <code class="language-plaintext highlighter-rouge">SetColor</code> or <code class="language-plaintext highlighter-rouge">SetTexture</code>.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///in Start method</span>

<span class="c1">//give data to shaders</span>
<span class="n">Material</span><span class="p">.</span><span class="nf">SetBuffer</span><span class="p">(</span><span class="s">"SphereLocations"</span><span class="p">,</span> <span class="n">resultBuffer</span><span class="p">);</span>
<span class="n">Material</span><span class="p">.</span><span class="nf">SetBuffer</span><span class="p">(</span><span class="s">"Triangles"</span><span class="p">,</span> <span class="n">meshTriangles</span><span class="p">);</span>
<span class="n">Material</span><span class="p">.</span><span class="nf">SetBuffer</span><span class="p">(</span><span class="s">"Positions"</span><span class="p">,</span> <span class="n">meshPositions</span><span class="p">);</span>
</code></pre></div></div>

<p>Now we have most things we need to call the DrawProcedural method, but if you take a look at it one of the non-optional arguments we havent accounted for is still the bounds of what we’re drawing. This is here for frustum culling and in our case we can quickly calculate them by creating 40x40 units bounds at the origin and passing them. The reason for the bounds in this case are the compute shader spits out positions in a sphere with a 20 unit radius around the origin.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///class variable</span>

<span class="n">Bounds</span> <span class="n">bounds</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///in start method</span>

<span class="c1">//bounds for frustum culling (20 is a magic number (radius) from the compute shader)</span>
<span class="n">bounds</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Bounds</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span> <span class="p">*</span> <span class="m">20</span><span class="p">);</span>
</code></pre></div></div>

<p>After the material and the bounds are passed the next argument is the topology. Changing that allows us to draw lines, dots or even quads (though they’re slow), but in most cases we like to stick to triangles and its also what our mesh data gave us. Then we pass in the length of the triangle array since in this case we want to run the vertex stage once per trangle corner, not once per position. And we pass the amount of spheres as the instance count. We could also queue the triangle amount times the sphere amount and figure out which sphere we’re in in the shader but this approach makes writing our shader a whole bit easier.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">///in Update</span>

<span class="c1">//draw result</span>
<span class="n">Graphics</span><span class="p">.</span><span class="nf">DrawProcedural</span><span class="p">(</span><span class="n">Material</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">MeshTopology</span><span class="p">.</span><span class="n">Triangles</span><span class="p">,</span> <span class="n">meshTriangles</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">SphereAmount</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="the-shader">The Shader</h2>

<p>The shader is actually pretty straightforward. We can use the the result of <a href="/basics.md">the basics series</a> to start. Then the first few changes are that we throw out the texture rendering and to mark the color property with <code class="language-plaintext highlighter-rouge">[HDR]</code> to allow us to go to values beyond 1 and play with bloom up there.</p>

<p>Next we can just delete the <code class="language-plaintext highlighter-rouge">appdata</code> and <code class="language-plaintext highlighter-rouge">v2f</code> structs. We’re not getting any data from a mesh and we’re not passing any data to the fragment stage. Instead we add our 3 buffers, since we don’t have to write to them we can just make them StructuredBuffers without the read-write functionality.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//buffers</span>
<span class="n">StructuredBuffer</span><span class="o">&lt;</span><span class="n">float3</span><span class="o">&gt;</span> <span class="n">SphereLocations</span><span class="p">;</span>
<span class="n">StructuredBuffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Triangles</span><span class="p">;</span>
<span class="n">StructuredBuffer</span><span class="o">&lt;</span><span class="n">float3</span><span class="o">&gt;</span> <span class="n">Positions</span><span class="p">;</span>
</code></pre></div></div>

<p>Then we change the return type of our vertex function to <code class="language-plaintext highlighter-rouge">float4</code> and give it the <code class="language-plaintext highlighter-rouge">: SV_POSITION</code> attribute, similarly to the <code class="language-plaintext highlighter-rouge">SV_TARGET</code> of the fragment function. The arguments our vertex function now takes are the vertex id as well as the instance id, marked via <code class="language-plaintext highlighter-rouge">SV_VertexID</code> and <code class="language-plaintext highlighter-rouge">SV_InstanceID</code>.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//the vertex shader function</span>
<span class="n">float4</span> <span class="n">vert</span><span class="p">(</span><span class="kt">uint</span> <span class="n">vertex_id</span><span class="o">:</span> <span class="n">SV_VertexID</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">instance_id</span><span class="o">:</span> <span class="n">SV_InstanceID</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">{</span>
  <span class="c1">//return position?</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Our first step is now to get the index of the position in the position list thats saved in the triangle buffer, just like in the compute shader we can access the buffer here like we would with an array in most languages. After getting the position index based on the vertex id, we use that to get the actual position from the position buffer. Then we also add the location of the current sphere by using instance id to the position.</p>

<p>And lastly we transform the position from worldspace to clip space by multiplying the view-projection matrix with it. This isn’t anything we haven’t done yet, it was just hidden in <code class="language-plaintext highlighter-rouge">UnityObjectToClipPos</code> until now, which internally only does <code class="language-plaintext highlighter-rouge">mul(UNITY_MATRIX_VP, mul(unity_ObjectToWorld, float4(pos, 1.0)));</code> where the inner <code class="language-plaintext highlighter-rouge">mul</code> transforms the position to the world coordinates and the outer one to clip coordinates.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//the vertex shader function</span>
<span class="n">float4</span> <span class="n">vert</span><span class="p">(</span><span class="kt">uint</span> <span class="n">vertex_id</span><span class="o">:</span> <span class="n">SV_VertexID</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">instance_id</span><span class="o">:</span> <span class="n">SV_InstanceID</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">{</span>
  <span class="c1">//get vertex position</span>
  <span class="kt">int</span> <span class="n">positionIndex</span> <span class="o">=</span> <span class="n">Triangles</span><span class="p">[</span><span class="n">vertex_id</span><span class="p">];</span>
  <span class="n">float3</span> <span class="n">position</span> <span class="o">=</span> <span class="n">Positions</span><span class="p">[</span><span class="n">positionIndex</span><span class="p">];</span>
  <span class="c1">//add sphere position</span>
  <span class="n">position</span> <span class="o">+=</span> <span class="n">SphereLocations</span><span class="p">[</span><span class="n">instance_id</span><span class="p">];</span>
  <span class="c1">//convert the vertex position from world space to clip space</span>
  <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_VP</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And with all of that you rendered objects at positions the cpu never knew about! And depending on your situation that can be pretty fast.</p>

<video width="300" height="300" preload="metadata" autoplay="" loop="" muted="" loading="lazy"><source src="/assets/images/posts/051/result.mp4" type="video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;" /></video>

<h2 id="tiny-tweaks">Tiny Tweaks</h2>

<p>Because we left the world of GameObjects and Transforms theres no easy way to resize objects in this thing, which is a thing I want to do. So lets add that functionality by just multiplying all positions with a value before putting them into the buffer with a linq function.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector3</span><span class="p">[]</span> <span class="n">positions</span> <span class="p">=</span> <span class="n">Mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span> <span class="p">*</span> <span class="n">Scale</span><span class="p">).</span><span class="nf">ToArray</span><span class="p">();</span> <span class="c1">//adjust scale here</span>
<span class="n">meshPositions</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ComputeBuffer</span><span class="p">(</span><span class="n">positions</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">*</span> <span class="m">3</span><span class="p">);</span>
<span class="n">meshPositions</span><span class="p">.</span><span class="nf">SetData</span><span class="p">(</span><span class="n">positions</span><span class="p">);</span>
</code></pre></div></div>

<p>Also as a tiny note microsoft is very clear in their docs that they prefer the content type of structured buffers to have a stride thats a power of 2 (more specifically a value 128 is dividable by), but in my playing around with float3 and float4 they seemed very similar in performance. Do with that information what you will.</p>

<p>Oh, and I moved the the calculation of the thread group count as well as the setting of the result buffer to the compute kernel to the Start method.</p>

<h2 id="sources">Sources</h2>

<h3 id="proceduralcomputespherescs">ProceduralComputeSpheres.cs</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/051_DrawProcedural/ProceduralComputeSpheres.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/051_DrawProcedural/ProceduralComputeSpheres.cs</a></li>
</ul>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ProceduralComputeSpheres</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="c1">//rough outline for data</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">SphereAmount</span> <span class="p">=</span> <span class="m">17</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">ComputeShader</span> <span class="n">Shader</span><span class="p">;</span>

    <span class="c1">//what is rendered</span>
    <span class="k">public</span> <span class="n">Mesh</span> <span class="n">Mesh</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Material</span> <span class="n">Material</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">Scale</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>

    <span class="c1">//internal data</span>
    <span class="n">ComputeBuffer</span> <span class="n">resultBuffer</span><span class="p">;</span>
    <span class="n">ComputeBuffer</span> <span class="n">meshTriangles</span><span class="p">;</span>
    <span class="n">ComputeBuffer</span> <span class="n">meshPositions</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">kernel</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="n">threadGroupSize</span><span class="p">;</span>
    <span class="n">Bounds</span> <span class="n">bounds</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">threadGroups</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//program we're executing</span>
        <span class="n">kernel</span> <span class="p">=</span> <span class="n">Shader</span><span class="p">.</span><span class="nf">FindKernel</span><span class="p">(</span><span class="s">"Spheres"</span><span class="p">);</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">GetKernelThreadGroupSizes</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="k">out</span> <span class="n">threadGroupSize</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">);</span>

        <span class="c1">//amount of thread groups we'll need to dispatch</span>
        <span class="n">threadGroups</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">((</span><span class="n">SphereAmount</span> <span class="p">+</span> <span class="p">(</span><span class="n">threadGroupSize</span> <span class="p">-</span> <span class="m">1</span><span class="p">))</span> <span class="p">/</span> <span class="n">threadGroupSize</span><span class="p">);</span>

        <span class="c1">//gpu buffer for the sphere positions</span>
        <span class="n">resultBuffer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ComputeBuffer</span><span class="p">(</span><span class="n">SphereAmount</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">*</span> <span class="m">3</span><span class="p">);</span>

        <span class="c1">//gpu buffers for the mesh</span>
        <span class="kt">int</span><span class="p">[]</span> <span class="n">triangles</span> <span class="p">=</span> <span class="n">Mesh</span><span class="p">.</span><span class="n">triangles</span><span class="p">;</span>
        <span class="n">meshTriangles</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ComputeBuffer</span><span class="p">(</span><span class="n">triangles</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="n">meshTriangles</span><span class="p">.</span><span class="nf">SetData</span><span class="p">(</span><span class="n">triangles</span><span class="p">);</span>
        <span class="n">Vector3</span><span class="p">[]</span> <span class="n">positions</span> <span class="p">=</span> <span class="n">Mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span> <span class="p">*</span> <span class="n">Scale</span><span class="p">).</span><span class="nf">ToArray</span><span class="p">();</span> <span class="c1">//adjust scale here</span>
        <span class="n">meshPositions</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ComputeBuffer</span><span class="p">(</span><span class="n">positions</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="p">*</span> <span class="m">3</span><span class="p">);</span>
        <span class="n">meshPositions</span><span class="p">.</span><span class="nf">SetData</span><span class="p">(</span><span class="n">positions</span><span class="p">);</span>

        <span class="c1">//give data to shaders</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">SetBuffer</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="s">"Result"</span><span class="p">,</span> <span class="n">resultBuffer</span><span class="p">);</span>

        <span class="n">Material</span><span class="p">.</span><span class="nf">SetBuffer</span><span class="p">(</span><span class="s">"SphereLocations"</span><span class="p">,</span> <span class="n">resultBuffer</span><span class="p">);</span>
        <span class="n">Material</span><span class="p">.</span><span class="nf">SetBuffer</span><span class="p">(</span><span class="s">"Triangles"</span><span class="p">,</span> <span class="n">meshTriangles</span><span class="p">);</span>
        <span class="n">Material</span><span class="p">.</span><span class="nf">SetBuffer</span><span class="p">(</span><span class="s">"Positions"</span><span class="p">,</span> <span class="n">meshPositions</span><span class="p">);</span>

        <span class="c1">//bounds for frustum culling (20 is a magic number (radius) from the compute shader)</span>
        <span class="n">bounds</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Bounds</span><span class="p">(</span><span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span> <span class="p">*</span> <span class="m">20</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//calculate positions</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">SetFloat</span><span class="p">(</span><span class="s">"Time"</span><span class="p">,</span> <span class="n">Time</span><span class="p">.</span><span class="n">time</span><span class="p">);</span>
        <span class="n">Shader</span><span class="p">.</span><span class="nf">Dispatch</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">threadGroups</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>

        <span class="c1">//draw result</span>
        <span class="n">Graphics</span><span class="p">.</span><span class="nf">DrawProcedural</span><span class="p">(</span><span class="n">Material</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">MeshTopology</span><span class="p">.</span><span class="n">Triangles</span><span class="p">,</span> <span class="n">meshTriangles</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">SphereAmount</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">OnDestroy</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">resultBuffer</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
        <span class="n">meshTriangles</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
        <span class="n">meshPositions</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="proceduralspheresshader">ProceduralSpheres.shader</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/051_DrawProcedural/ProceduralSpheres.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/051_DrawProcedural/ProceduralSpheres.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/051_ProceduralSpheres"</span><span class="p">{</span>
  <span class="c1">//show values to edit in inspector</span>
  <span class="n">Properties</span><span class="p">{</span>
    <span class="p">[</span><span class="n">HDR</span><span class="p">]</span> <span class="n">_Color</span> <span class="p">(</span><span class="s">"Tint"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">SubShader</span><span class="p">{</span>
    <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
    <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span> <span class="p">}</span>

    <span class="n">Pass</span><span class="p">{</span>
      <span class="n">CGPROGRAM</span>

      <span class="c1">//include useful shader functions</span>
      <span class="cp">#include "UnityCG.cginc"
</span>
      <span class="c1">//define vertex and fragment shader functions</span>
      <span class="cp">#pragma vertex vert
</span>      <span class="cp">#pragma fragment frag
</span>
      <span class="c1">//tint of the texture</span>
      <span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>

      <span class="c1">//buffers</span>
      <span class="n">StructuredBuffer</span><span class="o">&lt;</span><span class="n">float3</span><span class="o">&gt;</span> <span class="n">SphereLocations</span><span class="p">;</span>
      <span class="n">StructuredBuffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Triangles</span><span class="p">;</span>
      <span class="n">StructuredBuffer</span><span class="o">&lt;</span><span class="n">float3</span><span class="o">&gt;</span> <span class="n">Positions</span><span class="p">;</span>

      <span class="c1">//the vertex shader function</span>
      <span class="n">float4</span> <span class="n">vert</span><span class="p">(</span><span class="kt">uint</span> <span class="n">vertex_id</span><span class="o">:</span> <span class="n">SV_VertexID</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">instance_id</span><span class="o">:</span> <span class="n">SV_InstanceID</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">{</span>
        <span class="c1">//get vertex position</span>
        <span class="kt">int</span> <span class="n">positionIndex</span> <span class="o">=</span> <span class="n">Triangles</span><span class="p">[</span><span class="n">vertex_id</span><span class="p">];</span>
        <span class="n">float3</span> <span class="n">position</span> <span class="o">=</span> <span class="n">Positions</span><span class="p">[</span><span class="n">positionIndex</span><span class="p">];</span>
        <span class="c1">//add sphere position</span>
        <span class="n">position</span> <span class="o">+=</span> <span class="n">SphereLocations</span><span class="p">[</span><span class="n">instance_id</span><span class="p">];</span>
        <span class="c1">//convert the vertex position from world space to clip space</span>
        <span class="k">return</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_VP</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
      <span class="p">}</span>

      <span class="c1">//the fragment shader function</span>
      <span class="n">fixed4</span> <span class="n">frag</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
        <span class="c1">//return the final color to be drawn on screen</span>
        <span class="k">return</span> <span class="n">_Color</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">ENDCG</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">Fallback</span> <span class="s">"VertexLit"</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="basiccomputecompute-unchanged">BasicCompute.compute (unchanged)</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/051_DrawProcedural/BasicCompute.compute">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/051_DrawProcedural/BasicCompute.compute</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Each #kernel tells which function to compile; you can have many kernels</span>
<span class="cp">#pragma kernel Spheres
</span>
<span class="cp">#include "Random.cginc"
</span>
<span class="c1">//variables</span>
<span class="n">RWStructuredBuffer</span><span class="o">&lt;</span><span class="n">float3</span><span class="o">&gt;</span> <span class="n">Result</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">float</span> <span class="n">Time</span><span class="p">;</span>

<span class="p">[</span><span class="n">numthreads</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="kt">void</span> <span class="nf">Spheres</span> <span class="p">(</span><span class="n">uint3</span> <span class="n">id</span> <span class="o">:</span> <span class="n">SV_DispatchThreadID</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//generate 2 orthogonal vectors</span>
  <span class="n">float3</span> <span class="n">baseDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">rand1dTo3d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand1dTo1d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="o">+</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">float3</span> <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">baseDir</span><span class="p">,</span> <span class="n">rand1dTo3d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">7</span><span class="p">.</span><span class="mi">1393</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand1dTo1d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">.</span><span class="mi">7443</span><span class="p">)</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">9</span><span class="o">+</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span>
  <span class="c1">//scale the time and give it a random offset</span>
  <span class="kt">float</span> <span class="n">scaledTime</span> <span class="o">=</span> <span class="n">Time</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rand1dTo1d</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">712</span><span class="p">.</span><span class="mi">131234</span><span class="p">;</span>
  <span class="c1">//calculate a vector based on vectors</span>
  <span class="n">float3</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">baseDir</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">scaledTime</span><span class="p">)</span> <span class="o">+</span> <span class="n">orthogonal</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">scaledTime</span><span class="p">);</span>
  <span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="n">dir</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>


    <p>
        You can also find me on twitter at <a href="https://www.twitter.com/totallyRonja">@totallyRonja</a>. If you liked my tutorial and want to support me you can do that on Patreon (<a href="https://www.patreon.com/RonjaTutorials">patreon.com/RonjaTutorials</a>) or Ko-Fi (<a href="https://ko-fi.com/RonjaTutorials">ko-fi.com/RonjaTutorials</a>).
    </p>
  </div>

  
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ronja-tutorials.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  
</article>


      <!-- SVG icons from https://iconmonstr.com -->

      <!-- Twitter icon -->
      <span class="my-span-icon">
          <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>

        <!-- RSS icon -->
        
          <span class="my-span-icon">
            <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
            </a>
          </span>
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact ">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        
    </section>

    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-124040112-1', 'auto');
        ga('send', 'pageview');
      </script>
    
  </body>
</html>
