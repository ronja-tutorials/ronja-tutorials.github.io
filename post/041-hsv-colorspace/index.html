<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>HSV Color Space | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="So far we always used RGB colors in our shaders, meaning the components of our color vector always map to the red green and blue components of the color. This is great if we want to render the color or tint it, but adjusting the hue or saturation becomes very bothersome. For those kinds of operations we can use the HSV color space. In addition to the HSV color space there are also other similar color spaces, like the HSL or CIE color models.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="HSV Color Space" />
<meta property="og:description" content="So far we always used RGB colors in our shaders, meaning the components of our color vector always map to the red green and blue components of the color. This is great if we want to render the color or tint it, but adjusting the hue or saturation becomes very bothersome. For those kinds of operations we can use the HSV color space. In addition to the HSV color space there are also other similar color spaces, like the HSL or CIE color models." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/041-hsv-colorspace/" />
<meta property="article:published_time" content="2019-04-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-04-16T00:00:00+00:00" />
<meta itemprop="name" content="HSV Color Space">
<meta itemprop="description" content="So far we always used RGB colors in our shaders, meaning the components of our color vector always map to the red green and blue components of the color. This is great if we want to render the color or tint it, but adjusting the hue or saturation becomes very bothersome. For those kinds of operations we can use the HSV color space. In addition to the HSV color space there are also other similar color spaces, like the HSL or CIE color models.">
<meta itemprop="datePublished" content="2019-04-16T00:00:00+00:00" />
<meta itemprop="dateModified" content="2019-04-16T00:00:00+00:00" />
<meta itemprop="wordCount" content="2546">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="HSV Color Space"/>
<meta name="twitter:description" content="So far we always used RGB colors in our shaders, meaning the components of our color vector always map to the red green and blue components of the color. This is great if we want to render the color or tint it, but adjusting the hue or saturation becomes very bothersome. For those kinds of operations we can use the HSV color space. In addition to the HSV color space there are also other similar color spaces, like the HSL or CIE color models."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      
      
      <h1 class="f1 athelas mt3 mb1">HSV Color Space</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-04-16T00:00:00Z">April 16, 2019</time>

      
      
    </header>
    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><p>So far we always used RGB colors in our shaders, meaning the components of our color vector always map to the red green and blue components of the color. This is great if we want to render the color or tint it, but adjusting the hue or saturation becomes very bothersome. For those kinds of operations we can use the HSV color space. In addition to the HSV color space there are also other similar color spaces, like the HSL or CIE color models. Some of them are very similar to the HSL model while others get way closer to the visible spectrum at the cost of higher cost of calculating them. For simplicities sake I&rsquo;m only going to explain the HSV model here.</p>
<p><img src="/assets/images/posts/041/Result.gif" alt=""></p>
<h2 id="how-does-it-work">How does it work?</h2>
<p>When using the HSV model we also have 3 components which define our color, but in this case they map to the hue, saturation and value of the color. Because the maximum and minimum value of the hue map to the same value (red), we can view it as a circle. This concept can be taken a step further to imagine the color space as a cylinder where the hue is the rotation around the center, the saturation is the proximity to the center and the value is represented by the relative height of the point in the cylinder.</p>
<p><img src="/assets/images/posts/041/hsvCylinder.png" alt=""></p>
<h2 id="generating-a-rgb-color-from-hue">Generating a RGB Color from Hue</h2>
<p>The most critical step in converting colors from HSV to RGB is to convert the hue of a HSV color to a RGB color, that&rsquo;s why we&rsquo;re writing a function to do only this. In our implementation the hue will be between 0 and 1. Other implementations define it to be between 0 and 360, similar to degree numbers in a circle, but I personally prefer 0 to 1 scaling since it makes it easier to work with functions like <code>saturate</code> or <code>frac</code> which assume we&rsquo;re working in those dimensions.</p>
<p>In the range from 0 to 1 each of the 3 components has one third where it has a value of 1, one third where it has a value of 0 and two sixths where it&rsquo;s linearly growing from 0 to 1 or decreasing from 1 to 0 accordingly. Those changes in values are offset in a way that each hue generates a different color.</p>
<p><img src="/assets/images/posts/041/rgbHueValues.png" alt=""></p>
<p>In code we can most efficiently represent this by taking the absolute value of a value that&rsquo;s first multiplied by 6(because it has to reach a value of 1 over the change of a sixth) and shifted to the side. The green and blue values both go up and then down again in the range, that&rsquo;s why they are subtracted from 2, flipping them. The red value instead first decreases and then later increases again. To archieve this, 1 is subtracted from it.</p>
<p>After the increase and decrease of the values is set up the values are combined and the saturate function is called on it. The saturate function ensures that no value is below 0 or above 1.</p>
<p>If we want to make sure that hue values above 1 or below 0 don&rsquo;t result in a red hue and instead wrap around the color spectrum like expected we can just take the fractional part of the hue and ignore the decimal part. In hlsl, the <code>frac</code> function does exactly that.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 hue2rgb(<span style="color:#080;font-weight:bold">float</span> hue) {
    hue <span style="color:#333">=</span> frac(hue); <span style="color:#888">//only use fractional part of hue, making it loop</span>
    <span style="color:#080;font-weight:bold">float</span> r <span style="color:#333">=</span> abs(hue <span style="color:#333">*</span> <span style="color:#00d;font-weight:bold">6</span> <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">3</span>) <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">1</span>; <span style="color:#888">//red</span>
    <span style="color:#080;font-weight:bold">float</span> g <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span> <span style="color:#333">-</span> abs(hue <span style="color:#333">*</span> <span style="color:#00d;font-weight:bold">6</span> <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">2</span>); <span style="color:#888">//green</span>
    <span style="color:#080;font-weight:bold">float</span> b <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span> <span style="color:#333">-</span> abs(hue <span style="color:#333">*</span> <span style="color:#00d;font-weight:bold">6</span> <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">4</span>); <span style="color:#888">//blue</span>
    float3 rgb <span style="color:#333">=</span> float3(r,g,b); <span style="color:#888">//combine components</span>
    rgb <span style="color:#333">=</span> saturate(rgb); <span style="color:#888">//clamp between 0 and 1</span>
    <span style="color:#080;font-weight:bold">return</span> rgb;
}
</code></pre></div><p>After setting up this method you can simply use it in any other method to generate a rgb color with a specific hue.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
	float3 col <span style="color:#333">=</span> hue2rgb(i.uv);
	<span style="color:#080;font-weight:bold">return</span> float4(col, <span style="color:#00d;font-weight:bold">1</span>);
}
</code></pre></div><p><img src="/assets/images/posts/041/SimpleRainbow.png" alt=""></p>
<h2 id="full-hsv-to-rgb-conversion">Full HSV to RGB conversion</h2>
<p>After being able to convert the hue into a rgb color that looks correct we next also have to make the output color respect the saturation and value. To apply the saturation to the already generated color, we do a linear interpolation from 1 to the color and use the saturation component of the vector as the argument. Since 1 stands for full white in thic context, this makes the hue vanish for low saturation color while preserving it for high saturation ones.</p>
<p>The last step to take is to appy the value. Since the value stands for the brightness of the color the operation to apply it is to simply multiply the color so far by the value component.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 hsv2rgb(float3 hsv)
{
    float3 rgb <span style="color:#333">=</span> hue2rgb(hsv.x); <span style="color:#888">//apply hue</span>
    rgb <span style="color:#333">=</span> lerp(<span style="color:#00d;font-weight:bold">1</span>, rgb, hsv.y); <span style="color:#888">//apply saturation</span>
    rgb <span style="color:#333">=</span> rgb <span style="color:#333">*</span> hsv.z; <span style="color:#888">//apply value</span>
    <span style="color:#080;font-weight:bold">return</span> rgb;
}
</code></pre></div><p>To test this we can make a new example shader. In this one I used the x uv coordinate as the saturation, the y coordinate as the value and generated the hue by taking a value that increases diagonally by subtracting the y from the x UV component.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET
{
	<span style="color:#080;font-weight:bold">float</span> diagonal <span style="color:#333">=</span> i.uv.x <span style="color:#333">-</span> i.uv.y;
	float3 col <span style="color:#333">=</span> hsv2rgb(float3(diagonal, i.uv.x, i.uv.y));
	<span style="color:#080;font-weight:bold">return</span> float4(col, <span style="color:#00d;font-weight:bold">1</span>);
}
</code></pre></div><p><img src="/assets/images/posts/041/FullHsvTest.png" alt=""></p>
<h2 id="rgb-to-hsv-conversion">RGB to HSV conversion</h2>
<p>Unlike the conversion from rgb to hsv, the data we&rsquo;re using to generate the hsv color is a bit more entangled between the different components of the output vector so we won&rsquo;t split this into several functions.</p>
<p>Which variables we&rsquo;re using to get the hue depends on which component of the rgb color has the highest value, additionally we also need the difference between the highest and lowest component to calculate it. So after calculating the highest and lowest components of the input color via the builtin <code>min</code> and <code>max</code> functions and using them to get the difference between them we first create the hue and then check which of the components is equal to the highest value. We then subtract the two values that are not the highest value from each other, divide them by the difference between minimum and maximum value and then add 0, 2 or 4 depending on the color that&rsquo;s the highest. Afterwards we divide the resulting hue by 6 and only use the fractional part.</p>
<p>By getting the biggest component we ensure that the other 2 components are the minimum component and the component that&rsquo;s changing in the third we&rsquo;re in right now (see graph further up the article). For example when red is the most intense color, either blue has the lowest value and the difference between green to blue is calculated or green has the lowest value, in that case the resulting difference has a negative value. One thing that distorts this value is that because the value and saturation are also part of the input value, the hue might be way off from the &ldquo;completely red/green/blue&rdquo; points, but since max and min values are super close the difference we just calculated is still very small. This is luckily easy to fix by dividing the difference by the difference between the biggest and smallest component of the input color we calculated earlier. With those modifications we get a value of 0 if the colors that aren&rsquo;t the biggest color are the same, a.k.a. the hue is red/green/blue or a value of -1/1 if it&rsquo;s yellow/magenta/cyan and a value inbetween for the other hues. By adding a value based on the hue of the most intense input component we&rsquo;re remapping the colors to -1 to 1 for the redish colors, 1 to 3 for the greenish colors and 3 to 5 for the blueish colors. The division afterwards pulls this into the range of -1/6 to 5/6 and taking the fractional part of that makes the negative values wrap around so it&rsquo;s in the range of 0 to 1 as expected.</p>
<p>Getting the saturation and value is easier. The saturation is the difference between the biggest and smallest component, divided by the biggest component. The division factors out the multiplication by the value we do in the hsv to rgb conversion. To get the value we can just take the biggest component of the input value, since neither applying the hue nor the saturation can make the highest value drop below 1, so everything that goes into it is dependent on the value of the color.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 rgb2hsv(float3 rgb)
{
    <span style="color:#080;font-weight:bold">float</span> maxComponent <span style="color:#333">=</span> max(rgb.r, max(rgb.g, rgb.b));
    <span style="color:#080;font-weight:bold">float</span> minComponent <span style="color:#333">=</span> min(rgb.r, min(rgb.g, rgb.b));
    <span style="color:#080;font-weight:bold">float</span> diff <span style="color:#333">=</span> maxComponent <span style="color:#333">-</span> minComponent;
    <span style="color:#080;font-weight:bold">float</span> hue <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;
    <span style="color:#080;font-weight:bold">if</span>(maxComponent <span style="color:#333">==</span> rgb.r) {
        hue <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span><span style="color:#333">+</span>(rgb.g<span style="color:#333">-</span>rgb.b)<span style="color:#333">/</span>diff;
    } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span>(maxComponent <span style="color:#333">==</span> rgb.g) {
        hue <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span><span style="color:#333">+</span>(rgb.b<span style="color:#333">-</span>rgb.r)<span style="color:#333">/</span>diff;
    } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span>(maxComponent <span style="color:#333">==</span> rgb.b) {
        hue <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">4</span><span style="color:#333">+</span>(rgb.r<span style="color:#333">-</span>rgb.g)<span style="color:#333">/</span>diff;
    }
    hue <span style="color:#333">=</span> frac(hue <span style="color:#333">/</span> <span style="color:#00d;font-weight:bold">6</span>);
    <span style="color:#080;font-weight:bold">float</span> saturation <span style="color:#333">=</span> diff <span style="color:#333">/</span> maxComponent;
    <span style="color:#080;font-weight:bold">float</span> value <span style="color:#333">=</span> maxComponent;
    <span style="color:#080;font-weight:bold">return</span> float3(hue, saturation, value);
}
</code></pre></div><p>With this done, you can now convert a color into hsv, adjust it and move it back into rgb to render the color. The easiest one is to add some value to the hue to make it shift in a rainbow effect.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    float3 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
    float3 hsv <span style="color:#333">=</span> rgb2hsv(col);
    hsv.x <span style="color:#333">+=</span> i.uv.y <span style="color:#333">+</span> _Time.y <span style="color:#333">*</span> _CycleSpeed;
    col <span style="color:#333">=</span> hsv2rgb(hsv);
    <span style="color:#080;font-weight:bold">return</span> float4(col, <span style="color:#00d;font-weight:bold">1</span>);
}
</code></pre></div><p><img src="/assets/images/posts/041/MonaCycle.gif" alt=""></p>
<p>While with the hue you can just add values where a change of 1 results in the same hue again, 0.5 is the opposite hue etc, the saturation and value should usually be kept between 0 and 1. To adjust them we can use power operator. Taking the <code>N</code>th power of the saturation or value where <code>N</code> is above 1 makes the color less saturated/darker. Taking the <code>N</code>th power with <code>N</code> between 0 and 1 makes the color more saturated/brighter. With this knowledge we can make a shader that adjusts those properties in the shader. It&rsquo;s important to keep in mind that you shouldn&rsquo;t do that just to statically adjust a image though, since the conversions as well as taking the power of a number are pretty expensive operations, instead consider to change the image in a image manipulation program or if you want to use shaders, via <a href="https://www.arteryengine.com/shadron/">shadron</a> or <a href="https://www.ronja-tutorials.com/post/030-baking_shaders/">the texture baking tool I wrote a tutorial on</a>.</p>
<p>The fragment function of a shader adjusting all components of the HSV color could look like this.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    float3 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
    float3 hsv <span style="color:#333">=</span> rgb2hsv(col);
    hsv.x <span style="color:#333">=</span> hsv.x <span style="color:#333">+</span> _HueShift;
    hsv.y <span style="color:#333">=</span> pow(hsv.y, _SaturationPower);
    hsv.z <span style="color:#333">=</span> pow(hsv.z, _ValuePower);
    col <span style="color:#333">=</span> hsv2rgb(hsv);
    <span style="color:#080;font-weight:bold">return</span> float4(col, <span style="color:#00d;font-weight:bold">1</span>);
}
</code></pre></div><h2 id="source">Source</h2>
<p>I used include files in the building of those examples, I explain how to use them more extensively in <a href="https://www.ronja-tutorials.com/post/024-white-noise/">the tutorial about random number generation</a>.</p>
<h3 id="function-library">Function Library</h3>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/041_HSV_Colorspace/HSVLibrary.cginc">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/041_HSV_Colorspace/HSVLibrary.cginc</a></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#579">#ifndef HSV_LIB</span>
<span style="color:#579">#define HSV_LIB</span>

float3 hue2rgb(<span style="color:#080;font-weight:bold">float</span> hue) {
    hue <span style="color:#333">=</span> frac(hue); <span style="color:#888">//only use fractional part</span>
    <span style="color:#080;font-weight:bold">float</span> r <span style="color:#333">=</span> abs(hue <span style="color:#333">*</span> <span style="color:#00d;font-weight:bold">6</span> <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">3</span>) <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">1</span>; <span style="color:#888">//red</span>
    <span style="color:#080;font-weight:bold">float</span> g <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span> <span style="color:#333">-</span> abs(hue <span style="color:#333">*</span> <span style="color:#00d;font-weight:bold">6</span> <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">2</span>); <span style="color:#888">//green</span>
    <span style="color:#080;font-weight:bold">float</span> b <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span> <span style="color:#333">-</span> abs(hue <span style="color:#333">*</span> <span style="color:#00d;font-weight:bold">6</span> <span style="color:#333">-</span> <span style="color:#00d;font-weight:bold">4</span>); <span style="color:#888">//blue</span>
    float3 rgb <span style="color:#333">=</span> float3(r,g,b); <span style="color:#888">//combine components</span>
    rgb <span style="color:#333">=</span> saturate(rgb); <span style="color:#888">//clamp between 0 and 1</span>
    <span style="color:#080;font-weight:bold">return</span> rgb;
}

float3 hsv2rgb(float3 hsv)
{
    float3 rgb <span style="color:#333">=</span> hue2rgb(hsv.x); <span style="color:#888">//apply hue</span>
    rgb <span style="color:#333">=</span> lerp(<span style="color:#00d;font-weight:bold">1</span>, rgb, hsv.y); <span style="color:#888">//apply saturation</span>
    rgb <span style="color:#333">=</span> rgb <span style="color:#333">*</span> hsv.z; <span style="color:#888">//apply value</span>
    <span style="color:#080;font-weight:bold">return</span> rgb;
}

float3 rgb2hsv(float3 rgb)
{
    <span style="color:#080;font-weight:bold">float</span> maxComponent <span style="color:#333">=</span> max(rgb.r, max(rgb.g, rgb.b));
    <span style="color:#080;font-weight:bold">float</span> minComponent <span style="color:#333">=</span> min(rgb.r, min(rgb.g, rgb.b));
    <span style="color:#080;font-weight:bold">float</span> diff <span style="color:#333">=</span> maxComponent <span style="color:#333">-</span> minComponent;
    <span style="color:#080;font-weight:bold">float</span> hue <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;
    <span style="color:#080;font-weight:bold">if</span>(maxComponent <span style="color:#333">==</span> rgb.r) {
        hue <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span><span style="color:#333">+</span>(rgb.g<span style="color:#333">-</span>rgb.b)<span style="color:#333">/</span>diff;
    } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span>(maxComponent <span style="color:#333">==</span> rgb.g) {
        hue <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">2</span><span style="color:#333">+</span>(rgb.b<span style="color:#333">-</span>rgb.r)<span style="color:#333">/</span>diff;
    } <span style="color:#080;font-weight:bold">else</span> <span style="color:#080;font-weight:bold">if</span>(maxComponent <span style="color:#333">==</span> rgb.b) {
        hue <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">4</span><span style="color:#333">+</span>(rgb.r<span style="color:#333">-</span>rgb.g)<span style="color:#333">/</span>diff;
    }
    hue <span style="color:#333">=</span> frac(hue <span style="color:#333">/</span> <span style="color:#00d;font-weight:bold">6</span>);
    <span style="color:#080;font-weight:bold">float</span> saturation <span style="color:#333">=</span> diff <span style="color:#333">/</span> maxComponent;
    <span style="color:#080;font-weight:bold">float</span> value <span style="color:#333">=</span> maxComponent;
    <span style="color:#080;font-weight:bold">return</span> float3(hue, saturation, value);
}

<span style="color:#579">#endif</span>
</code></pre></div><h3 id="hsv-to-rgb-test">HSV to RGB Test</h3>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/041_HSV_Colorspace/HueTest.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/041_HSV_Colorspace/HueTest.shader</a></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">041</span>_HSV<span style="color:#333">/</span>HueTest<span style="color:#f00;background-color:#faa">&#34;</span>{
    SubShader{
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        Pass{
            CGPROGRAM

            <span style="color:#888">//include useful shader functions</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>HSVLibrary.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#888">//define vertex and fragment shader</span>
            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag
            
            <span style="color:#888">//the object data that&#39;s put into the vertex shader</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the vertex shader</span>
            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
                o.uv <span style="color:#333">=</span> v.uv;
                <span style="color:#080;font-weight:bold">return</span> o;
            }

            <span style="color:#888">//the fragment shader</span>
            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                <span style="color:#080;font-weight:bold">float</span> diagonal <span style="color:#333">=</span> i.uv.x <span style="color:#333">-</span> i.uv.y;
                float3 col <span style="color:#333">=</span> hsv2rgb(float3(diagonal, i.uv.x, i.uv.y));
                <span style="color:#080;font-weight:bold">return</span> float4(col, <span style="color:#00d;font-weight:bold">1</span>);
            }

            ENDCG
        }
    }
}
</code></pre></div><h3 id="hue-cycle">Hue Cycle</h3>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/041_HSV_Colorspace/HueCycle.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/041_HSV_Colorspace/HueCycle.shader</a></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">041</span>_HSV<span style="color:#333">/</span>HueCycle<span style="color:#f00;background-color:#faa">&#34;</span>{
    <span style="color:#888">//show values to edit in inspector</span>
    Properties{
        _CycleSpeed (<span style="color:#f00;background-color:#faa">&#34;</span>Hue Cycle Speed<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
    }

    SubShader{
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        Pass{
            CGPROGRAM

            <span style="color:#888">//include useful shader functions</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>HSVLibrary.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#888">//define vertex and fragment shader</span>
            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            <span style="color:#888">//Hue cycle speed</span>
            <span style="color:#080;font-weight:bold">float</span> _CycleSpeed;

            <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
            float4 _MainTex_ST;

            <span style="color:#888">//the object data that&#39;s put into the vertex shader</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the vertex shader</span>
            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
                o.uv <span style="color:#333">=</span> v.uv;
                <span style="color:#080;font-weight:bold">return</span> o;
            }

            <span style="color:#888">//the fragment shader</span>
            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                float3 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
                float3 hsv <span style="color:#333">=</span> rgb2hsv(col);
                hsv.x <span style="color:#333">+=</span> i.uv.y <span style="color:#333">+</span> _Time.y <span style="color:#333">*</span> _CycleSpeed;
                col <span style="color:#333">=</span> hsv2rgb(hsv);
                <span style="color:#080;font-weight:bold">return</span> float4(col, <span style="color:#00d;font-weight:bold">1</span>);
            }

            ENDCG
        }
    }
}
</code></pre></div><h3 id="hsv-adjustment">HSV Adjustment</h3>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/041_HSV_Colorspace/HSVAdjust.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/041_HSV_Colorspace/HSVAdjust.shader</a></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">041</span>_HSV<span style="color:#333">/</span>Adjust<span style="color:#f00;background-color:#faa">&#34;</span>{
    <span style="color:#888">//show values to edit in inspector</span>
    Properties{
        _HueShift(<span style="color:#f00;background-color:#faa">&#34;</span>Hue Shift<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        [PowerSlider(<span style="color:#60e;font-weight:bold">10.0</span>)]_SaturationPower(<span style="color:#f00;background-color:#faa">&#34;</span>Saturation Adjustment<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#60e;font-weight:bold">10.0</span>, <span style="color:#60e;font-weight:bold">0.1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
        [PowerSlider(<span style="color:#60e;font-weight:bold">10.0</span>)]_ValuePower(<span style="color:#f00;background-color:#faa">&#34;</span>Value Adjustment<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#60e;font-weight:bold">10.0</span>, <span style="color:#60e;font-weight:bold">0.1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
        _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
    }

    SubShader{
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        Pass{
            CGPROGRAM

            <span style="color:#888">//include useful shader functions</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>HSVLibrary.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#888">//define vertex and fragment shader</span>
            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            <span style="color:#888">//HSV modification variables</span>
            <span style="color:#080;font-weight:bold">float</span> _HueShift;
            <span style="color:#080;font-weight:bold">float</span> _SaturationPower;
            <span style="color:#080;font-weight:bold">float</span> _ValuePower;

            <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
            float4 _MainTex_ST;

            <span style="color:#888">//the object data that&#39;s put into the vertex shader</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the vertex shader</span>
            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
                o.uv <span style="color:#333">=</span> v.uv;
                <span style="color:#080;font-weight:bold">return</span> o;
            }

            <span style="color:#888">//the fragment shader</span>
            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                float3 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
                float3 hsv <span style="color:#333">=</span> rgb2hsv(col);
                hsv.x <span style="color:#333">=</span> hsv.x <span style="color:#333">+</span> _HueShift;
                hsv.y <span style="color:#333">=</span> pow(hsv.y, _SaturationPower);
                hsv.z <span style="color:#333">=</span> pow(hsv.z, _ValuePower);
                col <span style="color:#333">=</span> hsv2rgb(hsv);
                <span style="color:#080;font-weight:bold">return</span> float4(col, <span style="color:#00d;font-weight:bold">1</span>);
            }

            ENDCG
        }
    }
}
</code></pre></div><p>As always thank you so much for reading and supporting me, your messages of support mean the world to me 💖.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "disqus_vlgXjcPhg1" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
