<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>Polygon Clipping</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="Ronja Böhringer">

<meta name="description" content="Summary" />





<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="Polygon Clipping">
<meta itemprop="description" content="Summary">

  <meta itemprop="image" content="https://www.ronja-tutorials.com/assets/images/posts/014/Result.gif">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="Polygon Clipping">
<meta name="twitter:description" content="Summary">


  <meta name="twitter:creator" content="@TotallyRonja">


<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="https://www.ronja-tutorials.com/assets/images/posts/014/Result.gif">
  <meta property="twitter:image" content="https://www.ronja-tutorials.com/assets/images/posts/014/Result.gif">

<meta property="twitter:url" content="https://www.ronja-tutorials.com/2018/06/10/polygon-clipping.html">

<!-- Open Graph data -->
<meta property="og:title" content="Polygon Clipping" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/2018/06/10/polygon-clipping.html" />

  <meta property="og:image" content="https://www.ronja-tutorials.com/assets/images/posts/014/Result.gif" />

<meta property="og:description" content="Summary" />
<meta property="og:site_name" content="Ronja's Shader Tutorials" />

  <meta property="article:published_time" content="2018-06-10T00:00:00+02:00" />














  





  




    

    <link rel="canonical" href="https://www.ronja-tutorials.com/2018/06/10/polygon-clipping.html">

    

    <!-- <link rel="shortcut icon" href="https://www.ronja-tutorials.com/favicon.ico"> -->
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">Ronja&#39;s Shader Tutorials</a>
    
    <!-- SVG icons from https://iconmonstr.com -->

    <!-- Twitter icon -->
    <span class="my-span-icon">
        <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
          <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
        </a>
      </span>

      <!-- RSS icon -->
      
        <span class="my-span-icon">
          <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
          </a>
        </span>
      
      <!-- Contact icon -->
      
      
        <span class="my-span-icon">
          <a href="/about.html" aria-label="Contact" title="Contact ">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
          </a>
        </span>
      

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">Polygon Clipping</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2018-06-10T00:00:00+02:00" itemprop="datePublished">
          
          Jun 10, 2018
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ronja Böhringer</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Polygon Clipping</h1>
    <p class="post-meta">
      <time datetime="2018-06-10T00:00:00+02:00" itemprop="datePublished">
        
        Jun 10, 2018
      </time>
      </p>
  </header> -->

  
<ul>
  <li><a href="#summary">Summary</a></li>
  <li><a href="#draw-line">Draw Line</a></li>
  <li><a href="#draw-a-polygon-of-multiple-lines">Draw a Polygon of multiple lines</a>
    <ul>
      <li><a href="#filling-the-corner-array">Filling the Corner Array</a></li>
    </ul>
  </li>
  <li><a href="#clip-and-color-the-polygon">Clip and Color the Polygon</a></li>
</ul>

  <div itemprop="articleBody">
    <h2 id="summary">Summary</h2>

<p>Of course everything we render so far is made of polygons, but someone asked me how to clip a polygon shape based on a list of points in a shader so I’ll explain how to do that now. I will explain how to do that with a single shader pass in a fragment shader, a different way would be to actually generate triangles based on your polygon and use stencil buffers to clip, but I won’t explain that in this tutorial.</p>

<p>Because this tutorial explains a simple technique that doesn’t do that much with fancy graphics I will explain it in a unlit shader, but it will work the same way in surface shaders. The base for this tutorial will be my simple shader with properties, so you should know how to do that before starting <a href="/basics.html">this tutorial</a></p>

<p><img src="/assets/images/posts/014/Result.gif" alt="Result" /></p>

<h2 id="draw-line">Draw Line</h2>

<p>The first thing we have to add to our shader is the world position. Like in the other shaders (planar, triplanar and chessboard) we do that by multiplying the object position with the object to world matrix and pass that value to the fragment shader.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//the data that's used to generate fragments and can be read by the fragment shader</span>
<span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
    <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//the vertex shader</span>
<span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
    <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
    <span class="c1">//convert the vertex positions from object space to clip space so they can be rendered</span>
    <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="c1">//calculate and assign vertex position in the world</span>
    <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then we can progress to the fragment shader. here we start by calculating which side of a line a point is of. Since we will later generate our lines based on points, it’s easiest to define them as two points the line goes through.</p>

<p>To calculate which side of the line a point is on, we generate two vectors, first, a vector which goes from a arbitrary point of the line to our point and second the “line normal”. Usually the concept of a line normal doesn’t make much sense, but here we need a left and a right side of the line so we can define the line normal as a vector that points orthogonally to the left of the line direction.</p>

<p>When we have those vectors we can calculate their dot product and get the side the point is on. If the dot product is positive, the vector to the point points somewhat in the same direction as the line normal and it’s on the side the line normal points towards. If the dot product is negative the vector to the point points somewhat in the opposite direction as the line normal and the point is on th other side. If the dot product is exactly zero, the vector to the point is orthogonal to the line normal and the point is on the line.</p>

<p><img src="/assets/images/posts/014/Vectors.png" alt="The Vectors we can combine for stuff" /></p>

<p>To do this in shader code, we start by defining two points that define a line and then calculating those three vectors we need. We start by calculating the line direction. We get it by subtracting the first from the second line point (when calculating the difference between two points we always have to subtract the start from the goal if we care about the direction). Then we rotate the line point by 90 degree by switching it’s x and y components and inverting the new x part(if we inverted the y part we’d have a vector that points to the right of the line). And lastly we subtract one of the points defining the line from the point we’re checking to get the vector to the point.</p>

<p>After that we take the dot product of the line normal and the vector to the point and draw it to the screen.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float2</span> <span class="n">linePoint1</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">float2</span> <span class="n">linePoint2</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">//variables we need for our calculations</span>
<span class="n">float2</span> <span class="n">lineDirection</span> <span class="o">=</span> <span class="n">linePoint2</span> <span class="o">-</span> <span class="n">linePoint1</span><span class="p">;</span>
<span class="n">float2</span> <span class="n">lineNormal</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="n">lineDirection</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">lineDirection</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="n">float2</span> <span class="n">toPos</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span> <span class="o">-</span> <span class="n">linePoint1</span><span class="p">;</span>

<span class="c1">//which side the tested position is on</span>
<span class="kt">float</span> <span class="n">side</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">toPos</span><span class="p">,</span> <span class="n">lineNormal</span><span class="p">);</span>
<span class="n">side</span> <span class="o">=</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">side</span><span class="p">);</span>

<span class="k">return</span> <span class="n">side</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/014/Distance.png" alt="a diagonal line which is very smooth" /></p>

<p>As you can see, we actually see a small gradient at the line we defined. But we don’t really want a gradient, we want a clear differentiation. The gradient is here, because all colors below 0 (to the right of the line) are counted as black, all colors between 0 and 1 (just to the left of the line) are greyscale values and all colors of 1 and higher(way to the left of teh line) are displayed as white. A easy fix for that is the step function which takes two values and returns 0 if the value to the left is bigger and 1 otherwise. So if we give the step function a 0 and the result of our dor product it will give us a clear distinction between the two sides.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//which side the tested position is on</span>
<span class="kt">float</span> <span class="n">side</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">toPos</span><span class="p">,</span> <span class="n">lineNormal</span><span class="p">);</span>
<span class="n">side</span> <span class="o">=</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">side</span><span class="p">);</span>

<span class="k">return</span> <span class="n">side</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/014/Line.png" alt="a diagonal line" /></p>

<p>We continue by adding a new point and two new lines which should allow us to make a triangle. For that it’s best to put the calculations we made so far in a method to reuse them more easily. For that we move all of our calculations to a new method and take the information we use as arguments, so in this case we want to take the point we want to check, the first point of the line and the second point of the line as arguments.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//return 1 if a thing is left of the line, 0 if not</span>
<span class="kt">float</span> <span class="nf">isLeftOfLine</span><span class="p">(</span><span class="n">float2</span> <span class="n">pos</span><span class="p">,</span> <span class="n">float2</span> <span class="n">linePoint1</span><span class="p">,</span> <span class="n">float2</span> <span class="n">linePoint2</span><span class="p">){</span>
    <span class="c1">//variables we need for our calculations</span>
    <span class="n">float2</span> <span class="n">lineDirection</span> <span class="o">=</span> <span class="n">linePoint2</span> <span class="o">-</span> <span class="n">linePoint1</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">lineNormal</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="n">lineDirection</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">lineDirection</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">toPos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">linePoint1</span><span class="p">;</span>

    <span class="c1">//which side the tested position is on</span>
    <span class="kt">float</span> <span class="n">side</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">toPos</span><span class="p">,</span> <span class="n">lineNormal</span><span class="p">);</span>
    <span class="n">side</span> <span class="o">=</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">side</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">side</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//the fragment shader</span>
<span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="n">float2</span> <span class="n">linePoint1</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">linePoint2</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">side</span> <span class="o">=</span> <span class="n">isLeftOfLine</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">linePoint1</span><span class="p">,</span> <span class="n">linePoint2</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">side</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>

<h2 id="draw-a-polygon-of-multiple-lines">Draw a Polygon of multiple lines</h2>

<p>When we want to combine the multiple results of the lines we can do that in different ways, we can either define the result to be true if it’s to the left of all lines and false otherwise or we can say the result is true if it’s left of one or more lines and only false if it’s to the right of all lines. The triangle I defined goes clockwise, that means the left of the lines is outside, that means to differentiate between inside and outside of the polygon we have to find the union of all “left side” fragments. We do that by adding the results of the lines, the outsides will add up and have values of 1 or higher, the inside of the polygon will have a value of 0 everywhere.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//the fragment shader</span>
<span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="n">float2</span> <span class="n">linePoint1</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">linePoint2</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">linePoint3</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="kt">float</span> <span class="n">outsideTriangle</span> <span class="o">=</span> <span class="n">isLeftOfLine</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">linePoint1</span><span class="p">,</span> <span class="n">linePoint2</span><span class="p">);</span>
    <span class="n">outsideTriangle</span> <span class="o">=</span> <span class="n">outsideTriangle</span> <span class="o">+</span> <span class="n">isLeftOfLine</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">linePoint2</span><span class="p">,</span> <span class="n">linePoint3</span><span class="p">);</span>
    <span class="n">outsideTriangle</span> <span class="o">=</span> <span class="n">outsideTriangle</span> <span class="o">+</span> <span class="n">isLeftOfLine</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">linePoint3</span><span class="p">,</span> <span class="n">linePoint1</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">outsideTriangle</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/014/Triangle.png" alt="a black triangle on a white plane" /></p>

<p>Now that we can display a polygon sucessfully, I’d like to expand it so we can edit it more easily without editing the shader code. For that we add two new variables, a array of positions and how much that array is filled. The first one will hold all of the points of our polygon, the second one is there because shaders don’t support dynamic arrays, so we have to choose a length for the array and then we fill it more or less.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//the variables for the corners</span>
<span class="k">uniform</span> <span class="n">float2</span> <span class="n">_corners</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
<span class="k">uniform</span> <span class="kt">uint</span> <span class="n">_cornerCount</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="filling-the-corner-array">Filling the Corner Array</h3>

<p>There are no properties for arrays, so we have to fill them via C# code. I added two attributes to the new class, execute in edit mode to make the script update our polygon without us starting the game and require component, to make sure the script is on the same gameobject as the renderer which has the material with the shader we’re writing.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="p">[</span><span class="n">ExecuteInEditMode</span><span class="p">]</span>
<span class="p">[</span><span class="nf">RequireComponent</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Renderer</span><span class="p">))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">PolygonController</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>


<span class="p">}</span>
</code></pre></div></div>

<p>We then add two variables to the class, the material with the shader and a array of points which we will then pass to the shader. The material is private, because we’ll get it via code and it’s only used in this class. The position array is also private because we don’t need access from outside, but we give it the serialize field attribute to make unity remember the value and show it in the inspector.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
<span class="k">private</span> <span class="n">Vector2</span><span class="p">[]</span> <span class="n">corners</span><span class="p">;</span>

<span class="k">private</span> <span class="n">Material</span> <span class="n">_mat</span><span class="p">;</span>
</code></pre></div></div>

<p>Then we write the method which will pass the information to the shader. In it we first check if we already fetched the material and get the renderer on the gameobject and get it’s material if we didn’t. We use the sharedmaterial field of the renderer for this because if we used the material field we’d create a copy of the material which we don’t want hight here.</p>

<p>Then we allocate a new array of 4d vectors which can hold 1000 variables. The reason we use 4d vectors instead of the 2d vectors we need is that the unity API only allows us to pass 4d vectors and the reason for the 1000 variable length is that as I mentioned previously shaders don’t support dynamic array lengths so we have to choose a maximum of points and always choose that length, I chose 1000 pretty much randomly.</p>

<p>We then fill this array with the positions of our points, the 2d vectors will automatically be converted to 4d vectors with 0 at the 3rd and 4th position.</p>

<p>After we prepared our vector array we pass it to our material and then also pass it the amount of positions we actually use.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">UpdateMaterial</span><span class="p">(){</span>
    <span class="c1">//fetch material if we haven't already</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_mat</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="n">_mat</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Renderer</span><span class="p">&gt;().</span><span class="n">sharedMaterial</span><span class="p">;</span>

    <span class="c1">//allocate and fill array to pass</span>
    <span class="n">Vector4</span><span class="p">[]</span> <span class="n">vec4Corners</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="m">1000</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="p">&lt;</span><span class="n">corners</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span><span class="n">i</span><span class="p">++){</span>
        <span class="n">vec4Corners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">//pass array to material</span>
    <span class="n">_mat</span><span class="p">.</span><span class="nf">SetVectorArray</span><span class="p">(</span><span class="s">"_corners"</span><span class="p">,</span> <span class="n">vec4Corners</span><span class="p">);</span>
    <span class="n">_mat</span><span class="p">.</span><span class="nf">SetInt</span><span class="p">(</span><span class="s">"_cornerCount"</span><span class="p">,</span> <span class="n">corners</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The next step is to actually call this function, we do this in two methods, one which we call Start and one which we call OnValidate. The first one will automatically called by unity when the game starts and the second one will automatically be called by unity when a variable of the script changes in the inspector.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span><span class="p">(){</span>
    <span class="nf">UpdateMaterial</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">OnValidate</span><span class="p">(){</span>
    <span class="nf">UpdateMaterial</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>After writing the script we can add it to our project to do it’s job. We just add it as a component to the same gameobject the renderer with our material is on. And when we set up our script, we can set our corners easily by adding to the array in the inspector.</p>

<p><img src="/assets/images/posts/014/Inspector.png" alt="unity inspector where we can see the corner array" /></p>

<p>Next we go back to our shader to actually use the array. To do that we instantiate our outside triangle variable as zero.</p>

<p>Then we iterate over the array with a typical for loop. We start the loop at 0 because the first index of arrays in hlsl is adressed 0, the second with 1 etc… we stop when the iterator value goes over the amount of corners we specified via C# and we increase the iterator by 1 every loop. We explicitely tell hlsl to loop the for loop, the alternative would be to unroll it which means it would just copypaste the stuff happening in the for loop under each other. Unrolling is usually faster in shaders, but we don’t have a fixed length in our case so we have to use loop.</p>

<p>In the loop, we just add the return value of the side function of one line. As the points of the line we use the corner at the position of the iterator and the corner at the position of the iterator plus one. The problem that emerges when we use that plus one is that at the last point we acess the array at a point we didn’t set, but we want to go back to the first point instead. In this position modulo helps us, we add one to the iterator and then take the modulo with the length of the valid array, that way it jumps back to 0 if it would acess a invalid value otherwise.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//the fragment shader</span>
<span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>

    <span class="kt">float</span> <span class="n">outsideTriangle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="p">[</span><span class="n">loop</span><span class="p">]</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">uint</span> <span class="n">index</span><span class="p">;</span><span class="n">index</span><span class="o">&lt;</span><span class="n">_cornerCount</span><span class="p">;</span><span class="n">index</span><span class="o">++</span><span class="p">){</span>
        <span class="n">outsideTriangle</span> <span class="o">+=</span> <span class="n">isLeftOfLine</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">_corners</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">_corners</span><span class="p">[(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">_cornerCount</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">outsideTriangle</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/014/Hexagon.png" alt="a black hexagon on a white plane" /></p>

<p>And with that we have a polygon just based on a few points (if it doesn’t show for you, just nudge the values in the inspector a bit to call OnValidate).</p>

<h2 id="clip-and-color-the-polygon">Clip and Color the Polygon</h2>

<p>The person who requested this tutorial asked how to clip a polygon, so that’s the last thing we’re going to add here. In hlsl there is a function to discard polygons called clip. We pass it a value and if that value is lower than 0 the fragment won’t be rendered, otherwise the function does nothing.</p>

<p>We can pass the outsideTriangle variable into the clip function, but nothing will happen because all values of the value are 0 or higher. To actually clip everything outside of the polygon we can simply invert the value and the values inside of the polygon will stay 0 and all of the values outside will be negative and will be clipped.</p>

<p>Because we now use the outsideTriangle variable for it’s intended use, we can now stop drawing it to the screen and just print the color again.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="n">outsideTriangle</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">outsideTriangle</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/014/SuperHexagon.png" alt="super - hexagon" /></p>

<p><img src="/assets/images/posts/014/ConcaveBreaking.gif" alt="the shape not being displayed properly when trying to make a concave shape" /></p>

<p>The biggest disadvantage with this technique is that we can only render convex polygons, it breaks when we try to use concave ones.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/014_Polygon"</span>
<span class="p">{</span>
    <span class="c1">//show values to edit in inspector</span>
    <span class="n">Properties</span><span class="p">{</span>
        <span class="n">_Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">SubShader</span><span class="p">{</span>
        <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">CGPROGRAM</span>

            <span class="c1">//include useful shader functions</span>
            <span class="cp">#include "UnityCG.cginc"
</span>
            <span class="c1">//define vertex and fragment shader</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>

            <span class="c1">//the variables for the corners</span>
            <span class="k">uniform</span> <span class="n">float2</span> <span class="n">_corners</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
            <span class="k">uniform</span> <span class="kt">uint</span> <span class="n">_cornerCount</span><span class="p">;</span>

            <span class="c1">//the object data that's put into the vertex shader</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="c1">//the data that's used to generate fragments and can be read by the fragment shader</span>
            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="c1">//the vertex shader</span>
            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//convert the vertex positions from object space to clip space so they can be rendered</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//calculate and assign vertex position in the world</span>
                <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">//return 1 if a thing is left of the line, 0 if not</span>
            <span class="kt">float</span> <span class="n">isLeftOfLine</span><span class="p">(</span><span class="n">float2</span> <span class="n">pos</span><span class="p">,</span> <span class="n">float2</span> <span class="n">linePoint1</span><span class="p">,</span> <span class="n">float2</span> <span class="n">linePoint2</span><span class="p">){</span>
                <span class="c1">//variables we need for our calculations</span>
                <span class="n">float2</span> <span class="n">lineDirection</span> <span class="o">=</span> <span class="n">linePoint2</span> <span class="o">-</span> <span class="n">linePoint1</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">lineNormal</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="n">lineDirection</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">lineDirection</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
                <span class="n">float2</span> <span class="n">toPos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">linePoint1</span><span class="p">;</span>

                <span class="c1">//which side the tested position is on</span>
                <span class="kt">float</span> <span class="n">side</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">toPos</span><span class="p">,</span> <span class="n">lineNormal</span><span class="p">);</span>
                <span class="n">side</span> <span class="o">=</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">side</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">side</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">//the fragment shader</span>
            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>

                <span class="kt">float</span> <span class="n">outsideTriangle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                <span class="p">[</span><span class="n">loop</span><span class="p">]</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">uint</span> <span class="n">index</span><span class="p">;</span><span class="n">index</span><span class="o">&lt;</span><span class="n">_cornerCount</span><span class="p">;</span><span class="n">index</span><span class="o">++</span><span class="p">){</span>
                    <span class="n">outsideTriangle</span> <span class="o">+=</span> <span class="n">isLeftOfLine</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">_corners</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">_corners</span><span class="p">[(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">_cornerCount</span><span class="p">]);</span>
                <span class="p">}</span>

                <span class="n">clip</span><span class="p">(</span><span class="o">-</span><span class="n">outsideTriangle</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">_Color</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="p">[</span><span class="n">ExecuteInEditMode</span><span class="p">]</span>
<span class="p">[</span><span class="nf">RequireComponent</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Renderer</span><span class="p">))]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">PolygonController</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
	<span class="k">private</span> <span class="n">Vector2</span><span class="p">[]</span> <span class="n">corners</span><span class="p">;</span>

	<span class="k">private</span> <span class="n">Material</span> <span class="n">_mat</span><span class="p">;</span>

	<span class="k">void</span> <span class="nf">Start</span><span class="p">(){</span>
		<span class="nf">UpdateMaterial</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">void</span> <span class="nf">OnValidate</span><span class="p">(){</span>
		<span class="nf">UpdateMaterial</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">void</span> <span class="nf">UpdateMaterial</span><span class="p">(){</span>
		<span class="c1">//fetch material if we haven't already</span>
		<span class="k">if</span><span class="p">(</span><span class="n">_mat</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
			<span class="n">_mat</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Renderer</span><span class="p">&gt;().</span><span class="n">sharedMaterial</span><span class="p">;</span>

		<span class="c1">//allocate and fill array to pass</span>
		<span class="n">Vector4</span><span class="p">[]</span> <span class="n">vec4Corners</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector4</span><span class="p">[</span><span class="m">1000</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="p">&lt;</span><span class="n">corners</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span><span class="n">i</span><span class="p">++){</span>
			<span class="n">vec4Corners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">corners</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="c1">//pass array to material</span>
		<span class="n">_mat</span><span class="p">.</span><span class="nf">SetVectorArray</span><span class="p">(</span><span class="s">"_corners"</span><span class="p">,</span> <span class="n">vec4Corners</span><span class="p">);</span>
		<span class="n">_mat</span><span class="p">.</span><span class="nf">SetInt</span><span class="p">(</span><span class="s">"_cornerCount"</span><span class="p">,</span> <span class="n">corners</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>I hope you learned something about how to approach problems with multiple points and vectors. And I hope I talked about what you wanted to know, Alex.</p>

<p>You can also find the source code for this tutorial here:<br />
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/Polygon.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/Polygon.shader</a><br />
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/PolygonController.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/PolygonController.cs</a><br /></p>


    <p>
        You can also find me on twitter at <a href="https://www.twitter.com/totallyRonja">@totallyRonja</a>. If you liked my tutorial and want to support me you can do that on Patreon (<a href="https://www.patreon.com/RonjaTutorials">patreon.com/RonjaTutorials</a>) or Ko-Fi (<a href="https://ko-fi.com/RonjaTutorials">ko-fi.com/RonjaTutorials</a>).
    </p>
  </div>

  
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ronja-tutorials.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  
</article>


      <!-- SVG icons from https://iconmonstr.com -->

      <!-- Twitter icon -->
      <span class="my-span-icon">
          <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>

        <!-- RSS icon -->
        
          <span class="my-span-icon">
            <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
            </a>
          </span>
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact ">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        
    </section>

    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-124040112-1', 'auto');
        ga('send', 'pageview');
      </script>
    
  </body>
</html>
