<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>2D SDF Space Manipulation</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="Ronja Böhringer">

<meta name="description" content="When using polygon assets we can only draw one object at a time (ignoring stuff like batching and instancing), but when working with signed distance ..." />





<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="2D SDF Space Manipulation">
<meta itemprop="description" content="When using polygon assets we can only draw one object at a time (ignoring stuff like batching and instancing), but when working with signed distance ...">

  <meta itemprop="image" content="https://www.ronja-tutorials.com/assets/images/posts/036/Result.gif">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="2D SDF Space Manipulation">
<meta name="twitter:description" content="When using polygon assets we can only draw one object at a time (ignoring stuff like batching and instancing), but when working with signed distance ...">


  <meta name="twitter:creator" content="@TotallyRonja">


<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="https://www.ronja-tutorials.com/assets/images/posts/036/Result.gif">
  <meta property="twitter:image" content="https://www.ronja-tutorials.com/assets/images/posts/036/Result.gif">

<meta property="twitter:url" content="https://www.ronja-tutorials.com/2018/11/24/sdf-space-manipulation.html">

<!-- Open Graph data -->
<meta property="og:title" content="2D SDF Space Manipulation" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/2018/11/24/sdf-space-manipulation.html" />

  <meta property="og:image" content="https://www.ronja-tutorials.com/assets/images/posts/036/Result.gif" />

<meta property="og:description" content="When using polygon assets we can only draw one object at a time (ignoring stuff like batching and instancing), but when working with signed distance ..." />
<meta property="og:site_name" content="Ronja's Shader Tutorials" />

  <meta property="article:published_time" content="2018-11-24T00:00:00+01:00" />














  





  




    

    <link rel="canonical" href="https://www.ronja-tutorials.com/2018/11/24/sdf-space-manipulation.html">

    

    <!-- <link rel="shortcut icon" href="https://www.ronja-tutorials.com/favicon.ico"> -->
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">Ronja&#39;s Shader Tutorials</a>
    
    <!-- SVG icons from https://iconmonstr.com -->

    <!-- Twitter icon -->
    <span class="my-span-icon">
        <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
          <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
        </a>
      </span>

      <!-- RSS icon -->
      
        <span class="my-span-icon">
          <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
          </a>
        </span>
      
      <!-- Contact icon -->
      
      
        <span class="my-span-icon">
          <a href="/about.html" aria-label="Contact" title="Contact ">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
          </a>
        </span>
      

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">2D SDF Space Manipulation</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2018-11-24T00:00:00+01:00" itemprop="datePublished">
          
          Nov 24, 2018
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ronja Böhringer</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">2D SDF Space Manipulation</h1>
    <p class="post-meta">
      <time datetime="2018-11-24T00:00:00+01:00" itemprop="datePublished">
        
        Nov 24, 2018
      </time>
      </p>
  </header> -->

  
<ul>
  <li><a href="#setup">Setup</a></li>
  <li><a href="#space-repetition">Space Repetition</a>
    <ul>
      <li><a href="#mirror">Mirror</a></li>
    </ul>
  </li>
  <li><a href="#cells">Cells</a></li>
  <li><a href="#radial-cells">Radial Cells</a></li>
  <li><a href="#wobbly-space">Wobbly space</a></li>
  <li><a href="#sources">Sources</a>
    <ul>
      <li><a href="#2d-sdf-library">2D SDF Library</a></li>
      <li><a href="#base-demo-shader">Base Demo Shader</a></li>
    </ul>
  </li>
</ul>

  <div itemprop="articleBody">
    <p>When using polygon assets we can only draw one object at a time (ignoring stuff like batching and instancing), but when working with signed distance fields we aren’t bound by the same limitations, if two positions have the same coordinate, the signed distance functions will return the same value and you can get multiple shapes with one calculation. To learn how to transform the space we use to generate signed distance fields I recommend you understand how to <a href="/2018/11/10/2d-sdf-basics.html">create shapes with signed distance functions</a> and <a href="/2018/11/17/2d-sdf-combination.html">combine sdf shapes</a>.</p>

<p><img src="/assets/images/posts/036/Result.gif" alt="" /></p>

<h2 id="setup">Setup</h2>

<p>For this tutorial I’ll modify a union between a square and a circle, but you can use it on any shape you want. It’s similar to the setup for the <a href="/2018/11/17/2d-sdf-combination.html">previous tutorial</a>.</p>

<p>Important here is that the part we will modify is before we use the position to generate shapes.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/036_SDF_Space_Manpulation/Type"</span><span class="p">{</span>
    <span class="n">Properties</span><span class="p">{</span>
        <span class="n">_InsideColor</span><span class="p">(</span><span class="s">"Inside Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">_OutsideColor</span><span class="p">(</span><span class="s">"Outside Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">_LineDistance</span><span class="p">(</span><span class="s">"Mayor Line Distance"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">_LineThickness</span><span class="p">(</span><span class="s">"Mayor Line Thickness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span>

        <span class="p">[</span><span class="n">IntRange</span><span class="p">]</span><span class="n">_SubLines</span><span class="p">(</span><span class="s">"Lines between major lines"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">_SubLineThickness</span><span class="p">(</span><span class="s">"Thickness of inbetween lines"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">01</span>
    <span class="p">}</span>

    <span class="n">SubShader</span><span class="p">{</span>
        <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">CGPROGRAM</span>

            <span class="cp">#include "UnityCG.cginc"
</span>            <span class="cp">#include "2D_SDF.cginc"
</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//calculate the position in clip space to render the object</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//calculate world position of vertex</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="n">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>

                <span class="c1">// manipulate position with cool methods here!</span>

                <span class="n">float2</span> <span class="n">squarePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
                <span class="n">squarePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">squarePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
                <span class="n">squarePosition</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">squarePosition</span><span class="p">,</span> <span class="p">.</span><span class="mi">125</span><span class="p">);</span>
                <span class="kt">float</span> <span class="n">squareShape</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">squarePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

                <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
                <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="p">));</span>
                <span class="kt">float</span> <span class="n">circleShape</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

                <span class="kt">float</span> <span class="n">combination</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">circleShape</span><span class="p">,</span> <span class="n">squareShape</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">combination</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">float4</span> <span class="n">_InsideColor</span><span class="p">;</span>
            <span class="n">float4</span> <span class="n">_OutsideColor</span><span class="p">;</span>

            <span class="kt">float</span> <span class="n">_LineDistance</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">_LineThickness</span><span class="p">;</span>

            <span class="kt">float</span> <span class="n">_SubLines</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">_SubLineThickness</span><span class="p">;</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
                <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">_InsideColor</span><span class="p">,</span> <span class="n">_OutsideColor</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dist</span><span class="p">));</span>

                <span class="kt">float</span> <span class="n">distanceChange</span> <span class="o">=</span> <span class="n">fwidth</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">majorLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">_LineDistance</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LineDistance</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">majorLines</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">_LineThickness</span> <span class="o">-</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">_LineThickness</span> <span class="o">+</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">majorLineDistance</span><span class="p">);</span>

                <span class="kt">float</span> <span class="n">distanceBetweenSubLines</span> <span class="o">=</span> <span class="n">_LineDistance</span> <span class="o">/</span> <span class="n">_SubLines</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">subLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">distanceBetweenSubLines</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">distanceBetweenSubLines</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">subLines</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">_SubLineThickness</span> <span class="o">-</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">_SubLineThickness</span> <span class="o">+</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">subLineDistance</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">col</span> <span class="o">*</span> <span class="n">majorLines</span> <span class="o">*</span> <span class="n">subLines</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Standard"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And the 2D_SDF.cginc function in the same folder as the shader we will expand looks like this at the start:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef SDF_2D
#define SDF_2D
</span>
<span class="c1">//transforms</span>

<span class="n">float2</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rotation</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">rotation</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">sine</span><span class="p">,</span> <span class="n">cosine</span><span class="p">;</span>
    <span class="n">sincos</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">sine</span><span class="p">,</span> <span class="n">cosine</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">float2</span><span class="p">(</span><span class="n">cosine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cosine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float2</span> <span class="nf">translate</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="n">float2</span> <span class="n">offset</span><span class="p">){</span>
    <span class="c1">//move samplepoint in the opposite direction that we want to move shapes in</span>
    <span class="k">return</span> <span class="n">samplePosition</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float2</span> <span class="nf">scale</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">samplePosition</span> <span class="o">/</span> <span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//combinations</span>

<span class="c1">///basic</span>
<span class="kt">float</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">intersect</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">subtract</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">subtraction</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">intersect</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">-</span><span class="n">subtraction</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">interpolate</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">amount</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">lerp</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// round</span>
<span class="kt">float</span> <span class="nf">round_merge</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">intersectionSpace</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">shape1</span> <span class="o">-</span> <span class="n">radius</span><span class="p">,</span> <span class="n">shape2</span> <span class="o">-</span> <span class="n">radius</span><span class="p">);</span>
    <span class="n">intersectionSpace</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">intersectionSpace</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">insideDistance</span> <span class="o">=</span> <span class="o">-</span><span class="n">length</span><span class="p">(</span><span class="n">intersectionSpace</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">simpleUnion</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">outsideDistance</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">simpleUnion</span><span class="p">,</span> <span class="n">radius</span><span class="p">);</span>
    <span class="k">return</span>  <span class="n">insideDistance</span> <span class="o">+</span> <span class="n">outsideDistance</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">round_intersect</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">intersectionSpace</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">shape1</span> <span class="o">+</span> <span class="n">radius</span><span class="p">,</span> <span class="n">shape2</span> <span class="o">+</span> <span class="n">radius</span><span class="p">);</span>
    <span class="n">intersectionSpace</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">intersectionSpace</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">outsideDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">intersectionSpace</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">simpleIntersection</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">insideDistance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">simpleIntersection</span><span class="p">,</span> <span class="o">-</span><span class="n">radius</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">outsideDistance</span> <span class="o">+</span> <span class="n">insideDistance</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">round_subtract</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">subtraction</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">round_intersect</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">-</span><span class="n">subtraction</span><span class="p">,</span> <span class="n">radius</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///champfer</span>
<span class="kt">float</span> <span class="nf">champfer_merge</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">champferSize</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">SQRT_05</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">70710678118</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">simpleMerge</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">champfer</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape1</span> <span class="o">+</span> <span class="n">shape2</span><span class="p">)</span> <span class="o">*</span> <span class="n">SQRT_05</span><span class="p">;</span>
    <span class="n">champfer</span> <span class="o">=</span> <span class="n">champfer</span> <span class="o">-</span> <span class="n">champferSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">simpleMerge</span><span class="p">,</span> <span class="n">champfer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">champfer_intersect</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">champferSize</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">SQRT_05</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">70710678118</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">simpleIntersect</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">champfer</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape1</span> <span class="o">+</span> <span class="n">shape2</span><span class="p">)</span> <span class="o">*</span> <span class="n">SQRT_05</span><span class="p">;</span>
    <span class="n">champfer</span> <span class="o">=</span> <span class="n">champfer</span> <span class="o">+</span> <span class="n">champferSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">intersect</span><span class="p">(</span><span class="n">simpleIntersect</span><span class="p">,</span> <span class="n">champfer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">champfer_subtract</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">subtraction</span><span class="p">,</span> <span class="kt">float</span> <span class="n">champferSize</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">champfer_intersect</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">-</span><span class="n">subtraction</span><span class="p">,</span> <span class="n">champferSize</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// round border intersection</span>
<span class="kt">float</span> <span class="nf">round_border</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">position</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">distanceFromBorderIntersection</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">distanceFromBorderIntersection</span> <span class="o">-</span> <span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">groove_border</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">groove</span><span class="p">,</span> <span class="kt">float</span> <span class="n">width</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depth</span><span class="p">){</span>
    <span class="kt">float</span> <span class="n">circleBorder</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">groove</span><span class="p">)</span> <span class="o">-</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">grooveShape</span> <span class="o">=</span> <span class="n">subtract</span><span class="p">(</span><span class="n">circleBorder</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">grooveShape</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//shapes</span>

<span class="kt">float</span> <span class="nf">circle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="c1">//get distance from center and grow it according to radius</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">)</span> <span class="o">-</span> <span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">rectangle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="n">float2</span> <span class="n">halfSize</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">componentWiseEdgeDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">)</span> <span class="o">-</span> <span class="n">halfSize</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">outsideDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">componentWiseEdgeDistance</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">insideDistance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">componentWiseEdgeDistance</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">componentWiseEdgeDistance</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">outsideDistance</span> <span class="o">+</span> <span class="n">insideDistance</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p><img src="/assets/images/posts/036/BaseShape.png" alt="" /></p>

<h2 id="space-repetition">Space Repetition</h2>

<h3 id="mirror">Mirror</h3>

<p>One of the simplest things we can do is to mirror the world around a axis. To mirror it around the y axis we take the absolute value of the x component of our position. This way the coordinates on the right and the left of the axis are the same. <code class="language-plaintext highlighter-rouge">(-1, 1)</code> becomes <code class="language-plaintext highlighter-rouge">(1, 1)</code> and by that it’s inside a circle that uses <code class="language-plaintext highlighter-rouge">(1, 1)</code> as it’s origin with a radius greater than 0.</p>

<p>Because most of the time the code using this function would look like <code class="language-plaintext highlighter-rouge">position = mirror(position);</code> anyways, we can use a small shortcut here. We simply declare the position argument as inout. This way when we write to the argument it’ll also change the variable where we pass it into the function. The return type can then be void because we’re not using the return value anyways.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in 2D_SDF.cginc</span>

<span class="kt">void</span> <span class="nf">mirror</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">){</span>
    <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in shader function</span>

<span class="n">mirror</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/036/Mirrored.png" alt="" /></p>

<p>This is pretty nice already, but it only gives us a single axis to mirror around. We can expand that by rotating the space just like we did for rotating shapes. We first have to rotate the space, then mirror it and then rotate it back. This way we can mirror around any angle. The same is possible by translating the space and doing the inverse translation after mirroring. (If you’re doing both, remember to first translate, then rotate before mirroring and rotating first afterwards)</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in shader function</span>

<span class="kt">float</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">_Time</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="p">;</span>
<span class="n">position</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">rotation</span><span class="p">);</span>
<span class="n">mirror</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
<span class="n">position</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="o">-</span><span class="n">rotation</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/036/RotatingMirror.gif" alt="" /></p>

<h2 id="cells">Cells</h2>

<p>If you know how <a href="/noise.html">generating noise</a> works, you know that for procedural generation we often repeat the position and have small cells which are essentially the same except for a few paramters. For distance fields we can do the same.</p>

<p>Because the <code class="language-plaintext highlighter-rouge">fmod</code> function (as well as using % for the modulo) gives us the remainder instead of the definition of a modulo we want we’ll have to use some trickery. We first take the modulo with the fmod function. For positive numbers that’s what we want, for negative numbers though, it’s the result we want minus the period. The fix for this is to add the period and take the modulo again. Adding the period will give us the result we want for negative input values and a value that’s one period too high for positive input values. The second modulo will do nothing to the values for negative input values, because they’re already between 0 and the period, for positive input values, it’ll basically subtract one period.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in 2D_SDF.cginc</span>

<span class="kt">void</span> <span class="nf">cells</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">,</span> <span class="n">float2</span> <span class="n">period</span><span class="p">){</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
    <span class="c1">//negative positions lead to negative modulo</span>
    <span class="n">position</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
    <span class="c1">//negative positions now have correct cell coordinates, positive input positions too high</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
    <span class="c1">//second mod doesn't change values between 0 and period, but brings down values that are above period.</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in shader function</span>

<span class="n">cells</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/036/Cells.png" alt="" /></p>

<p>A problem with cells is that we loose the continuity we like in distance fields. It’s not that bad when the shapes are only in the middle of the cells, but in examples like the one I have here, it can lead to massive artefacts we want to avoid if we use the distance field for many things we might want to use distance fields for.</p>

<p>One solution that doesn’t work in every case, but which is great where it works is to mirror every second cell. For this we need the cell index of our pixel, but we still have no return value in our function, so we can easily use that to return the cell index.</p>

<p>To calculate the cell index we divide the position by the period. this way 0-1 is the first cell, 1-2 the second etc… and we can easily quantise this. To get the cell index we then simply floor the value and return the result. It’s important that we calculate the cell index before we do the modulo to repeat the cells, otherwise we’d get a index of 0 everywhere because the position doesn’t go above the period.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in 2D_SDF.cginc</span>

<span class="n">float2</span> <span class="nf">cells</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">,</span> <span class="n">float2</span> <span class="n">period</span><span class="p">){</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
    <span class="c1">//negative positions lead to negative modulo</span>
    <span class="n">position</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
    <span class="c1">//negative positions now have correct cell coordinates, positive input positions too high</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
    <span class="c1">//second mod doesn't change values between 0 and period, but brings down values that are above period.</span>

    <span class="n">float2</span> <span class="n">cellIndex</span> <span class="o">=</span> <span class="n">position</span> <span class="o">/</span> <span class="n">period</span><span class="p">;</span>
    <span class="n">cellIndex</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">cellIndex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">cellIndex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this information we can now flip the cells. To get whether we should or should not flip, we take the modulo of 2 with the cell index. The result of this operations changes between 0 and 1 or -1 every second cell. To make the changing more consistent, we take the sbolute value and have a value that switches between 0 and 1.</p>

<p>To use this value to flip between the normal position and the flipped one we need a function that does nothing for a value of 0 and subtracts the position from the period where flip is 1. So we do a linear interpolation from the normal position to the flipped one via the flip variable. Because the flip variable is a 2d vector the components are individually flipped.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in shader function</span>

<span class="n">float2</span> <span class="n">period</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">float2</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">cells</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
<span class="n">float2</span> <span class="n">flip</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">fmod</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="n">position</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span> <span class="o">-</span> <span class="n">position</span><span class="p">,</span> <span class="n">flip</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/036/FlippedCells.png" alt="" /></p>

<h2 id="radial-cells">Radial Cells</h2>

<p>Another cool thing is to repeat the space in a radial pattern.</p>

<p>To get that effect, we first calculate the radial position. For that we encode the angle around the center in the x axis and the distance from the center in the y axis.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float2</span> <span class="n">radialPosition</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">atan2</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">length</span><span class="p">(</span><span class="n">position</span><span class="p">));</span>
</code></pre></div></div>

<p>Then we repeat the angle. Because passing in the amount of repetitions is way easier than the angle of each slice we first calculate the size of each slice. A whole circle is 2 times pi, so to get the part we want we divide 2 times pi by the cell amount.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">cellSize</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">cells</span><span class="p">;</span>
</code></pre></div></div>

<p>With this infomation we can now repeat the x component of the radial position every cellSize units. We do the repetition via the modulo, just like before we get problems with negative numbers here which we have to mitigate by using two modulo functions.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">fmod</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);</span>
</code></pre></div></div>

<p>Then we have to transfer the new position back into normal xy coordinates. We use the sincos function with the x component of the radial position as the angle here to write the sine into the x coordinate of the position and the cosine into the y coordinate. With this step we get the normalised position. To get the correct distance from the center we then have to multiply it by the y component of the radial position, which signifies the length.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in 2D_SDF.cginc</span>

<span class="kt">void</span> <span class="nf">radial_cells</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cells</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">cellSize</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">cells</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">radialPosition</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">atan2</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">length</span><span class="p">(</span><span class="n">position</span><span class="p">));</span>
    <span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">fmod</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);</span>

    <span class="n">sincos</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">*</span> <span class="n">radialPosition</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in shader function</span>

<span class="n">float2</span> <span class="n">period</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">radial_cells</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/036/RadialSymmetry.png" alt="" /></p>

<p>Then we can also add a cell index and mirroring just like we did for the regular cells.</p>

<p>We have to calculate the cell index after calculating the radial position, but before taking it’s modulo. We get it by dividing the x component of the radial position and flooring the result. In this case the index can also be negative, that’s a problem if we have a uneven amount of cells. For example with 3 cells, we’d get 1 cell with index 0, 1 cell with a index of -1 and 2 half cells with each 1 and -2. To sidestep this problem, we add the amount of cells to the floored variable and then take a modulo with the cellsize.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in 2D_SDF.cginc</span>

<span class="kt">float</span> <span class="n">cellIndex</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">cellSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cells</span><span class="p">);</span>

<span class="c1">//at the end of the function:</span>
<span class="k">return</span> <span class="n">cellIndex</span><span class="p">;</span>
</code></pre></div></div>

<p>To mirror this, we’d like to have the coordinates as radial coordinates, so to avoid calculating the radial coordinates again outside of the function we’re going to give the option via a bool argument. Usually we really don’t like having branching (if statements) in our shaders, but in this case all pixels on the screen will take the same path, so it’s fine.</p>

<p>The mirroring has to happen after the radial coordinate was looped, but before it’s transformed back into a regular position. We get whether the current cell should be flipped or not by taking the modulo of the cell index and 2. This usually should give us zeroes and ones, but in my case I experienced some twos, which is weird, but we can work with. To fix the twos, we simply subtract one 1 from our flip variable and then take the absolute value, this way zeroes and twos become ones and the ones become zero, just like we like it, just the other way around.</p>

<p>Because the zeroes and ones are the wrong way around, we do a linear interpolation from the flipped version to the unflipped one, not the other way around that we did previously. To flip the coordinate we just subtract the position from the cell size.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in 2D_SDF.cginc</span>

<span class="kt">float</span> <span class="nf">radial_cells</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cells</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mirrorEverySecondCell</span> <span class="o">=</span> <span class="nb">false</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">cellSize</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">cells</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">radialPosition</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">atan2</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">length</span><span class="p">(</span><span class="n">position</span><span class="p">));</span>

    <span class="kt">float</span> <span class="n">cellIndex</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">cellSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cells</span><span class="p">);</span>

    <span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">fmod</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">mirrorEverySecondCell</span><span class="p">){</span>
        <span class="kt">float</span> <span class="n">flip</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">cellIndex</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">flip</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">cellSize</span> <span class="o">-</span> <span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">flip</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">sincos</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">*</span> <span class="n">radialPosition</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">cellIndex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in shader function</span>

<span class="n">float2</span> <span class="n">period</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">radial_cells</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/036/MirroredRadialSymmetry.png" alt="" /></p>

<h2 id="wobbly-space">Wobbly space</h2>

<p>But we don’t have to repeat the space to change it. In the tutorial about basics we rotate, transform and scale it for example. Another thing we can do is to move each axis based on the other one with a sine wave. This does make the distances of the signed distance funciton less precise, but as long as we don’t make it wobble too much it should be fine.</p>

<p>We first calculate the amount we change the position by flipping the x and y components and then multiplying them by the frequency of the wobble. Then we take the sine of that value and multiply it by the amount of wobble we want to add. After that we simply add that wobble factor to the position and apply the result to the position again.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in 2D_SDF.cginc</span>

<span class="kt">void</span> <span class="nf">wobble</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">,</span> <span class="n">float2</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">float2</span> <span class="n">amount</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">wobble</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">yx</span> <span class="o">*</span> <span class="n">frequency</span><span class="p">)</span> <span class="o">*</span> <span class="n">amount</span><span class="p">;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">wobble</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in shader function</span>

<span class="n">wobble</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">.</span><span class="mo">05</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/036/Wobble.png" alt="" /></p>

<p>We can also animate that wobble by changing the position, applying the wobble at the offset position and moving the space back. To avoid the float numbers from becomming too big and creating ugly artefacts, I do a modulo at pi times 2 divided by the frequency of the wobble, this lines up with the wobble (a sine wave repeats every pi times 2 units) so you won’t see the jump and prevents the offset from becoming too big.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//in shader function</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">frequency</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">_Time</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="n">offset</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">frequency</span><span class="p">);</span>
<span class="n">position</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="n">wobble</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">.</span><span class="mo">05</span><span class="p">);</span>
<span class="n">position</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/036/AnimatedWobble.gif" alt="" /></p>

<h2 id="sources">Sources</h2>

<h3 id="2d-sdf-library">2D SDF Library</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/2D_SDF.cginc">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/2D_SDF.cginc</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef SDF_2D
#define SDF_2D
</span>
<span class="c1">//transforms</span>

<span class="n">float2</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">rotation</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">rotation</span> <span class="o">*</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">sine</span><span class="p">,</span> <span class="n">cosine</span><span class="p">;</span>
    <span class="n">sincos</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">sine</span><span class="p">,</span> <span class="n">cosine</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">float2</span><span class="p">(</span><span class="n">cosine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cosine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">sine</span> <span class="o">*</span> <span class="n">samplePosition</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float2</span> <span class="nf">translate</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="n">float2</span> <span class="n">offset</span><span class="p">){</span>
    <span class="c1">//move samplepoint in the opposite direction that we want to move shapes in</span>
    <span class="k">return</span> <span class="n">samplePosition</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">float2</span> <span class="nf">scale</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">samplePosition</span> <span class="o">/</span> <span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//combinations</span>

<span class="c1">///basic</span>
<span class="kt">float</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">intersect</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">subtract</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">subtraction</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">intersect</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">-</span><span class="n">subtraction</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">interpolate</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">amount</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">lerp</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// round</span>
<span class="kt">float</span> <span class="nf">round_merge</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">intersectionSpace</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">shape1</span> <span class="o">-</span> <span class="n">radius</span><span class="p">,</span> <span class="n">shape2</span> <span class="o">-</span> <span class="n">radius</span><span class="p">);</span>
    <span class="n">intersectionSpace</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">intersectionSpace</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">insideDistance</span> <span class="o">=</span> <span class="o">-</span><span class="n">length</span><span class="p">(</span><span class="n">intersectionSpace</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">simpleUnion</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">outsideDistance</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">simpleUnion</span><span class="p">,</span> <span class="n">radius</span><span class="p">);</span>
    <span class="k">return</span>  <span class="n">insideDistance</span> <span class="o">+</span> <span class="n">outsideDistance</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">round_intersect</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">intersectionSpace</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">shape1</span> <span class="o">+</span> <span class="n">radius</span><span class="p">,</span> <span class="n">shape2</span> <span class="o">+</span> <span class="n">radius</span><span class="p">);</span>
    <span class="n">intersectionSpace</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">intersectionSpace</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">outsideDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">intersectionSpace</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">simpleIntersection</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">insideDistance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">simpleIntersection</span><span class="p">,</span> <span class="o">-</span><span class="n">radius</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">outsideDistance</span> <span class="o">+</span> <span class="n">insideDistance</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">round_subtract</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">subtraction</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">round_intersect</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">-</span><span class="n">subtraction</span><span class="p">,</span> <span class="n">radius</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">///champfer</span>
<span class="kt">float</span> <span class="nf">champfer_merge</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">champferSize</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">SQRT_05</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">70710678118</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">simpleMerge</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">champfer</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape1</span> <span class="o">+</span> <span class="n">shape2</span><span class="p">)</span> <span class="o">*</span> <span class="n">SQRT_05</span><span class="p">;</span>
    <span class="n">champfer</span> <span class="o">=</span> <span class="n">champfer</span> <span class="o">-</span> <span class="n">champferSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">simpleMerge</span><span class="p">,</span> <span class="n">champfer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">champfer_intersect</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">champferSize</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">SQRT_05</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">70710678118</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">simpleIntersect</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">champfer</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape1</span> <span class="o">+</span> <span class="n">shape2</span><span class="p">)</span> <span class="o">*</span> <span class="n">SQRT_05</span><span class="p">;</span>
    <span class="n">champfer</span> <span class="o">=</span> <span class="n">champfer</span> <span class="o">+</span> <span class="n">champferSize</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">intersect</span><span class="p">(</span><span class="n">simpleIntersect</span><span class="p">,</span> <span class="n">champfer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">champfer_subtract</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">subtraction</span><span class="p">,</span> <span class="kt">float</span> <span class="n">champferSize</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">champfer_intersect</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="o">-</span><span class="n">subtraction</span><span class="p">,</span> <span class="n">champferSize</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// round border intersection</span>
<span class="kt">float</span> <span class="nf">round_border</span><span class="p">(</span><span class="kt">float</span> <span class="n">shape1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">shape2</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">position</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">distanceFromBorderIntersection</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">distanceFromBorderIntersection</span> <span class="o">-</span> <span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">groove_border</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">groove</span><span class="p">,</span> <span class="kt">float</span> <span class="n">width</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depth</span><span class="p">){</span>
    <span class="kt">float</span> <span class="n">circleBorder</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">groove</span><span class="p">)</span> <span class="o">-</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">grooveShape</span> <span class="o">=</span> <span class="n">subtract</span><span class="p">(</span><span class="n">circleBorder</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="n">depth</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">grooveShape</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// space repetition</span>

<span class="kt">void</span> <span class="nf">mirror</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">){</span>
    <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float2</span> <span class="nf">cells</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">,</span> <span class="n">float2</span> <span class="n">period</span><span class="p">){</span>
    <span class="c1">//find cell index</span>
    <span class="n">float2</span> <span class="n">cellIndex</span> <span class="o">=</span> <span class="n">position</span> <span class="o">/</span> <span class="n">period</span><span class="p">;</span>
    <span class="n">cellIndex</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">cellIndex</span><span class="p">);</span>

    <span class="c1">//negative positions lead to negative modulo</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
    <span class="c1">//negative positions now have correct cell coordinates, positive input positions too high</span>
    <span class="n">position</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
    <span class="c1">//second mod doesn't change values between 0 and period, but brings down values that are above period.</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">cellIndex</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">radial_cells</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">,</span> <span class="kt">float</span> <span class="n">cells</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">mirrorEverySecondCell</span> <span class="o">=</span> <span class="nb">false</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">PI</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">cellSize</span> <span class="o">=</span> <span class="n">PI</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">cells</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">radialPosition</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">atan2</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">length</span><span class="p">(</span><span class="n">position</span><span class="p">));</span>

    <span class="kt">float</span> <span class="n">cellIndex</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">cellSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">cells</span><span class="p">,</span> <span class="n">cells</span><span class="p">);</span>

    <span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">fmod</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">mirrorEverySecondCell</span><span class="p">){</span>
        <span class="kt">float</span> <span class="n">flip</span> <span class="o">=</span> <span class="n">fmod</span><span class="p">(</span><span class="n">cellIndex</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">flip</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">cellSize</span> <span class="o">-</span> <span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">flip</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">sincos</span><span class="p">(</span><span class="n">radialPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">*</span> <span class="n">radialPosition</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">cellIndex</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">wobble</span><span class="p">(</span><span class="k">inout</span> <span class="n">float2</span> <span class="n">position</span><span class="p">,</span> <span class="n">float2</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">float2</span> <span class="n">amount</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">wobble</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">yx</span> <span class="o">*</span> <span class="n">frequency</span><span class="p">)</span> <span class="o">*</span> <span class="n">amount</span><span class="p">;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">position</span> <span class="o">+</span> <span class="n">wobble</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//shapes</span>

<span class="kt">float</span> <span class="nf">circle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">){</span>
    <span class="c1">//get distance from center and grow it according to radius</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">)</span> <span class="o">-</span> <span class="n">radius</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">rectangle</span><span class="p">(</span><span class="n">float2</span> <span class="n">samplePosition</span><span class="p">,</span> <span class="n">float2</span> <span class="n">halfSize</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">componentWiseEdgeDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">samplePosition</span><span class="p">)</span> <span class="o">-</span> <span class="n">halfSize</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">outsideDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">componentWiseEdgeDistance</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">insideDistance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">componentWiseEdgeDistance</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">componentWiseEdgeDistance</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">outsideDistance</span> <span class="o">+</span> <span class="n">insideDistance</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif
</span></code></pre></div></div>

<h3 id="base-demo-shader">Base Demo Shader</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_mirror.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_mirror.shader</a></li>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_cells.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_cells.shader</a></li>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_wobble.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_wobble.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/036_SDF_Space_Manpulation/Mirror"</span><span class="p">{</span>
    <span class="n">Properties</span><span class="p">{</span>
        <span class="n">_InsideColor</span><span class="p">(</span><span class="s">"Inside Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">_OutsideColor</span><span class="p">(</span><span class="s">"Outside Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">_LineDistance</span><span class="p">(</span><span class="s">"Mayor Line Distance"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">_LineThickness</span><span class="p">(</span><span class="s">"Mayor Line Thickness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span>

        <span class="p">[</span><span class="n">IntRange</span><span class="p">]</span><span class="n">_SubLines</span><span class="p">(</span><span class="s">"Lines between major lines"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">_SubLineThickness</span><span class="p">(</span><span class="s">"Thickness of inbetween lines"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mo">05</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mo">01</span>
    <span class="p">}</span>

    <span class="n">SubShader</span><span class="p">{</span>
        <span class="c1">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

        <span class="n">Pass</span><span class="p">{</span>
            <span class="n">CGPROGRAM</span>

            <span class="cp">#include "UnityCG.cginc"
</span>            <span class="cp">#include "2D_SDF.cginc"
</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
                <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="c1">//calculate the position in clip space to render the object</span>
                <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="c1">//calculate world position of vertex</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="n">scene</span><span class="p">(</span><span class="n">float2</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>

                <span class="c1">// modify position here!</span>

                <span class="n">float2</span> <span class="n">squarePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
                <span class="n">squarePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">squarePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
                <span class="n">squarePosition</span> <span class="o">=</span> <span class="n">rotate</span><span class="p">(</span><span class="n">squarePosition</span><span class="p">,</span> <span class="p">.</span><span class="mi">125</span><span class="p">);</span>
                <span class="kt">float</span> <span class="n">squareShape</span> <span class="o">=</span> <span class="n">rectangle</span><span class="p">(</span><span class="n">squarePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

                <span class="n">float2</span> <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
                <span class="n">circlePosition</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="p">));</span>
                <span class="kt">float</span> <span class="n">circleShape</span> <span class="o">=</span> <span class="n">circle</span><span class="p">(</span><span class="n">circlePosition</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

                <span class="kt">float</span> <span class="n">combination</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">circleShape</span><span class="p">,</span> <span class="n">squareShape</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">combination</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">float4</span> <span class="n">_InsideColor</span><span class="p">;</span>
            <span class="n">float4</span> <span class="n">_OutsideColor</span><span class="p">;</span>

            <span class="kt">float</span> <span class="n">_LineDistance</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">_LineThickness</span><span class="p">;</span>

            <span class="kt">float</span> <span class="n">_SubLines</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">_SubLineThickness</span><span class="p">;</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
                <span class="kt">float</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">scene</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span><span class="p">);</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">_InsideColor</span><span class="p">,</span> <span class="n">_OutsideColor</span><span class="p">,</span> <span class="n">step</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dist</span><span class="p">));</span>

                <span class="kt">float</span> <span class="n">distanceChange</span> <span class="o">=</span> <span class="n">fwidth</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">majorLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">_LineDistance</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LineDistance</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">majorLines</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">_LineThickness</span> <span class="o">-</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">_LineThickness</span> <span class="o">+</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">majorLineDistance</span><span class="p">);</span>

                <span class="kt">float</span> <span class="n">distanceBetweenSubLines</span> <span class="o">=</span> <span class="n">_LineDistance</span> <span class="o">/</span> <span class="n">_SubLines</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">subLineDistance</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">distanceBetweenSubLines</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">distanceBetweenSubLines</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">subLines</span> <span class="o">=</span> <span class="n">smoothstep</span><span class="p">(</span><span class="n">_SubLineThickness</span> <span class="o">-</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">_SubLineThickness</span> <span class="o">+</span> <span class="n">distanceChange</span><span class="p">,</span> <span class="n">subLineDistance</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">col</span> <span class="o">*</span> <span class="n">majorLines</span> <span class="o">*</span> <span class="n">subLines</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Standard"</span> <span class="c1">//fallback adds a shadow pass so we get shadows on other objects</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this you know all of the basics about signed distance functions that come to my mind off the top of my head. I’ll try to do something interresting with them in the next tutorial.</p>


    <p>
        You can also find me on twitter at <a href="https://www.twitter.com/totallyRonja">@totallyRonja</a>. If you liked my tutorial and want to support me you can do that on Patreon (<a href="https://www.patreon.com/RonjaTutorials">patreon.com/RonjaTutorials</a>) or Ko-Fi (<a href="https://ko-fi.com/RonjaTutorials">ko-fi.com/RonjaTutorials</a>).
    </p>
  </div>

  
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ronja-tutorials.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  
</article>


      <!-- SVG icons from https://iconmonstr.com -->

      <!-- Twitter icon -->
      <span class="my-span-icon">
          <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>

        <!-- RSS icon -->
        
          <span class="my-span-icon">
            <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
            </a>
          </span>
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact ">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        
    </section>

    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-124040112-1', 'auto');
        ga('send', 'pageview');
      </script>
    
  </body>
</html>
