<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Single Step Toon Light | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="I thought about how to make a toon shader and this is the result. There are obviously many different toon styles, so this is just one possiblity of many, but even if it&rsquo;s not the result you want in your game this tutorial can give you some insight in how I work and how to do stuff with shaders. The main advantage for me to use this toon shader in opposition to one that reads from ramp texures is that I can dynamically change the parameters without editing a texture first.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
		<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
		<link rel="canonical" href="https://www.ronja-tutorials.com/post/031-single-step-toon/">

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/css/main.css">
    

    
      

    

    
    
    <meta property="og:title" content="Single Step Toon Light" />
<meta property="og:description" content="I thought about how to make a toon shader and this is the result. There are obviously many different toon styles, so this is just one possiblity of many, but even if it&rsquo;s not the result you want in your game this tutorial can give you some insight in how I work and how to do stuff with shaders. The main advantage for me to use this toon shader in opposition to one that reads from ramp texures is that I can dynamically change the parameters without editing a texture first." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/031-single-step-toon/" />
<meta property="article:published_time" content="2018-10-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-10-20T00:00:00+00:00" />
<meta itemprop="name" content="Single Step Toon Light">
<meta itemprop="description" content="I thought about how to make a toon shader and this is the result. There are obviously many different toon styles, so this is just one possiblity of many, but even if it&rsquo;s not the result you want in your game this tutorial can give you some insight in how I work and how to do stuff with shaders. The main advantage for me to use this toon shader in opposition to one that reads from ramp texures is that I can dynamically change the parameters without editing a texture first.">
<meta itemprop="datePublished" content="2018-10-20T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-10-20T00:00:00+00:00" />
<meta itemprop="wordCount" content="1701">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Single Step Toon Light"/>
<meta name="twitter:description" content="I thought about how to make a toon shader and this is the result. There are obviously many different toon styles, so this is just one possiblity of many, but even if it&rsquo;s not the result you want in your game this tutorial can give you some insight in how I work and how to do stuff with shaders. The main advantage for me to use this toon shader in opposition to one that reads from ramp texures is that I can dynamically change the parameters without editing a texture first."/>

	

	

		<!-- unidentifying analytics, will not be shared with 3rd parties, I(Ronja) am just curious -->
		<script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      <h1 class="f1 athelas mt3 mb1">Single Step Toon Light</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-10-20T00:00:00Z">October 20, 2018</time>

      
      
		</header>
		
		<div style="margin-bottom: 70px;">
			<h3>Table Of Contents</h3>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#antialiased-step">Antialiased Step</a></li>
    <li><a href="#shadows">Shadows</a></li>
    <li><a href="#colors">Colors</a></li>
    <li><a href="#source">Source</a></li>
  </ul>
</nav>
		</div>

    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><div>
				
				<p>I thought about how to make a toon shader and this is the result. There are obviously many different toon styles, so this is just one possiblity of many, but even if it&rsquo;s not the result you want in your game this tutorial can give you some insight in how I work and how to do stuff with shaders. The main advantage for me to use this toon shader in opposition to one that reads from ramp texures is that I can dynamically change the parameters without editing a texture first.</p>
<p>I explain the basics of custom lighting models more indepth in <a href="https://www.ronja-tutorials.com/post/013-custom-lighting/">this tutorial</a>, but you should be fine if you know the basics of surface shaders in unity.</p>
<p><img src="/assets/images/posts/031/Result.gif" alt=""></p>
<h2 id="antialiased-step">Antialiased Step <a href="#antialiased-step" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>We start the shader by using a basic surface shader.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">CGPROGRAM

<span style="color:#888">//the shader is a surface shader, meaning that it will be extended by unity in the background to have fancy lighting and other features</span>
<span style="color:#888">//our surface shader function is called surf and we use our custom lighting model</span>
<span style="color:#888">//fullforwardshadows makes sure unity adds the shadow passes the shader might need</span>
<span style="color:#579">#pragma surface surf Standard fullforwardshadows</span>
<span style="color:#579">#pragma target 3.0</span>

<span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
fixed4 _Color;
half3 _Emission;

<span style="color:#888">//input struct which is automatically filled by unity</span>
<span style="color:#080;font-weight:bold">struct</span> Input {
    float2 uv_MainTex;
};

<span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutput o) {
    <span style="color:#888">//sample and tint albedo texture</span>
    fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
    col <span style="color:#333">*=</span> _Color;
    o.Albedo <span style="color:#333">=</span> col.rgb;

    o.Emission <span style="color:#333">=</span> _Emission;
}
ENDCG
</code></pre></div><p>Then we change the lighting model to our own and create a new function to match it. The function has to be called Lighting<code>OurLightingModelName</code>. The lighting model then has the name of the function name after <code>Lighting</code>. We&rsquo;ll take the <code>SurfaceOutput</code> of the surf function, the light direction, the view direction and the shadow attenuation as parameters for our lighing function to calculate the lighting.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#579">#pragma surface surf Stepped fullforwardshadows</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//our lighting function. Will be called once per light</span>
float4 LightingStepped(SurfaceOutput s, float3 lightDir, half3 viewDir, <span style="color:#080;font-weight:bold">float</span> shadowAttenuation){
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span>;
}
</code></pre></div><p>The most basic start to most lighting functions is to calculate how much the surface point points towards the light we&rsquo;re calculating the illumination for. For that we&rsquo;ll use use the dot function, it returns 1 when the vectors you pass it point in the same direction and -1 if they&rsquo;re opposing if they&rsquo;re both normalised. In this case the vectors are normalised when they&rsquo;re passed into the function so we don&rsquo;t have to worry about that. For the normal we simply use use normal of the surface output, it&rsquo;s also prepared by unity to already be in worldspace, just like the light and view direction.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//our lighting function. Will be called once per light</span>
float4 LightingStepped(SurfaceOutput s, float3 lightDir, half3 viewDir, <span style="color:#080;font-weight:bold">float</span> shadowAttenuation){
    <span style="color:#888">//how much surface normal points towards the light</span>
    flaot towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);
    <span style="color:#080;font-weight:bold">return</span> towardsLight;
}
</code></pre></div><p><img src="/assets/images/posts/031/Dot.png" alt=""></p>
<p>Then, to get a hard cut for the toon effect, we can use a <code>step</code> function, it&rsquo;ll return 0 if the first argument is greater, otherwise 1. The dot function returns 0 when the vectors are orthogonal which is the case at the half point of our surface. The side thats away from the light has negative values and the side towards the light positive ones. That&rsquo;s why we pass the <code>towardsLight</code> parameter as the second parameter into the step function and 0 as the first.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//our lighting function. Will be called once per light</span>
float4 LightingStepped(SurfaceOutput s, float3 lightDir, half3 viewDir, <span style="color:#080;font-weight:bold">float</span> shadowAttenuation){
    <span style="color:#888">//how much does the normal point towards the light?</span>
    <span style="color:#080;font-weight:bold">float</span> towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);
    <span style="color:#080;font-weight:bold">float</span> lightIntensity <span style="color:#333">=</span> step(<span style="color:#40e;font-weight:bold">0</span>, towardsLight);
    <span style="color:#080;font-weight:bold">return</span> lightIntensity;
}
</code></pre></div><p><img src="/assets/images/posts/031/Step.png" alt=""></p>
<p>Now we have a nice hard cut, but ironically it&rsquo;s too hard, we get pixel steps often called aliasing. We can avoid aliasing by not jumping from 0 to 1 at one point, instead we interpolate between them over the range of one pixel. For that we&rsquo;ll have to find out how much the value we&rsquo;re evaluating (<code>towardsLight</code>) changes in a single pixel. We get that value by passing the variable to fwidth. The fwidth function will compare the value to the same variable in neighboring pixels and tell us how much it changes approximately. When we know the change of the variable we can then exchange step with smoothstep, it takes 3 parameters, the first two mark the minimum(where the output value is 0) and maximum (where the output value is 1). So we pass 0 as the first value here, the value change as the second one and the value of how much the surface points at the light as the third parameter. With this we have almost the same result as previously, but the edge looks less jaggy.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//our lighting function. Will be called once per light</span>
float4 LightingStepped(SurfaceOutput s, float3 lightDir, half3 viewDir, <span style="color:#080;font-weight:bold">float</span> shadowAttenuation){
    <span style="color:#888">//how much does the normal point towards the light?</span>
    <span style="color:#080;font-weight:bold">float</span> towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);
    <span style="color:#080;font-weight:bold">float</span> towardsLightChange <span style="color:#333">=</span> fwidth(towardsLight);
    <span style="color:#080;font-weight:bold">float</span> lightIntensity <span style="color:#333">=</span> smoothstep(<span style="color:#40e;font-weight:bold">0</span>, towardsLightChange, towardsLight);
    <span style="color:#080;font-weight:bold">return</span> lightIntensity;
}
</code></pre></div><p><img src="/assets/images/posts/031/Smoothstep.png" alt=""></p>
<h2 id="shadows">Shadows <a href="#shadows" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>We use the shadowAttenuation variable to add shadows to our shader, but when we just it by itself it&rsquo;s too soft, something that clashes a bit with the style of this shader.</p>
<p><img src="/assets/images/posts/031/Atten.png" alt=""></p>
<p>We can give it the same treatment we gave the dot value. First find out how much the variable changes in the neighboring pixels and then do a smoothstep. Because we want to cut the shadow at the middle of the gradient and not just before it&rsquo;s completely black, we&rsquo;ll half the pixel change value and then use <code>0.5 - changevalue</code> as the minimum and <code>0.5 + changeValue</code> as the maximum.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> attenuationChange <span style="color:#333">=</span> fwidth(shadowAttenuation) <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>;
<span style="color:#080;font-weight:bold">float</span> shadow <span style="color:#333">=</span> smoothstep(<span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">-</span> attenuationChange, <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> attenuationChange, shadowAttenuation);

lightIntensity <span style="color:#333">=</span> lightIntensity <span style="color:#333">*</span> shadow;

<span style="color:#080;font-weight:bold">return</span> lightIntensity;
</code></pre></div><p><img src="/assets/images/posts/031/Shadow.png" alt=""></p>
<p>The problem with hardening the shadows like this is that point lights also have their falloff encoded into the shadow attenuation property. We can sidestep this by branching our shader and doing the smoothstep from 0 to the change instead of around 0.5. This will lead to some artefacts, but at least we can have shadows for point lights. We do the branching by writing compiler directives into the shader. If the flag <code>USING_DIRECTIONAL_LIGHT</code> is defined, the shader is going to put the border around 0.5, just like we did so far and if it isn&rsquo;t it&rsquo;s going to put the border at 0.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#579">#ifdef USING_DIRECTIONAL_LIGHT</span>
    <span style="color:#080;font-weight:bold">float</span> attenuationChange <span style="color:#333">=</span> fwidth(shadowAttenuation) <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>;
    <span style="color:#080;font-weight:bold">float</span> shadow <span style="color:#333">=</span> smoothstep(<span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">-</span> attenuationChange, <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> attenuationChange, shadowAttenuation);
<span style="color:#579">#else</span>
    <span style="color:#080;font-weight:bold">float</span> attenuationChange <span style="color:#333">=</span> fwidth(shadowAttenuation);
    <span style="color:#080;font-weight:bold">float</span> shadow <span style="color:#333">=</span> smoothstep(<span style="color:#40e;font-weight:bold">0</span>, attenuationChange, shadowAttenuation);
<span style="color:#579">#endif</span>
    lightIntensity <span style="color:#333">=</span> lightIntensity <span style="color:#333">*</span> shadow;
</code></pre></div><p><img src="/assets/images/posts/031/PointShadows.png" alt=""></p>
<h2 id="colors">Colors <a href="#colors" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>Now that we have a clear differentiation between shadow and light, we can add colors to the shader. The Color on the light side of the object will be the diffuse color of the object. The color on the shadowed side is the diffuse color multiplied a new shadow color, this way we can tint the shadow in any color we want. The result of the combination of light and shadow side will then we multiplied by the light color. We could also only multiply the light side color with the light color, but this can lead to the dark side being brighter than the bright side for low intensity lights which would be odd. We also get the alpha from the surface output struct to use it as the alpha channel of the output color.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Properties {
    [Header(Base Parameters)]
    _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>)
    _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
    [HDR] _Emission (<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span> ,<span style="color:#40e;font-weight:bold">0</span> ,<span style="color:#40e;font-weight:bold">0</span> , <span style="color:#00d;font-weight:bold">1</span>)
    
    [Header(Lighting Parameters)]
    _ShadowTint (<span style="color:#f00;background-color:#faa">&#34;</span>Shadow Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//global hlsl variable</span>

float3 _ShadowTint;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 shadowColor <span style="color:#333">=</span> s.Albedo <span style="color:#333">*</span> _ShadowTint;
float4 color;
color.rgb <span style="color:#333">=</span> lerp(shadowColor, s.Albedo, lightIntensity) <span style="color:#333">*</span> _LightColor0.rgb;
color.a <span style="color:#333">=</span> s.Alpha;
<span style="color:#080;font-weight:bold">return</span> color;
</code></pre></div><p>With this we have a shader with simple shading with a hard cut.</p>
<h2 id="source">Source <a href="#source" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/031_StepToon/SteppedToonLighting.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/031_StepToon/SteppedToonLighting.shader</a></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">031</span>_SteppedToon<span style="color:#f00;background-color:#faa">&#34;</span> {
    <span style="color:#888">//show values to edit in inspector</span>
    Properties {
        [Header(Base Parameters)]
        _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
        _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
        [HDR] _Emission (<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span> ,<span style="color:#40e;font-weight:bold">0</span> ,<span style="color:#40e;font-weight:bold">0</span> , <span style="color:#00d;font-weight:bold">1</span>)

        [Header(Lighting Parameters)]
        _ShadowTint (<span style="color:#f00;background-color:#faa">&#34;</span>Shadow Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#60e;font-weight:bold">0.5</span>, <span style="color:#60e;font-weight:bold">0.5</span>, <span style="color:#60e;font-weight:bold">0.5</span>, <span style="color:#00d;font-weight:bold">1</span>)
    }
    SubShader {
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        CGPROGRAM

        <span style="color:#888">//the shader is a surface shader, meaning that it will be extended by unity in the background to have fancy lighting and other features</span>
        <span style="color:#888">//our surface shader function is called surf and we use our custom lighting model</span>
        <span style="color:#888">//fullforwardshadows makes sure unity adds the shadow passes the shader might need</span>
        <span style="color:#f00;background-color:#faa">#</span>pragma surface surf Stepped fullforwardshadows
        <span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

        <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
        fixed4 _Color;
        half3 _Emission;

        float3 _ShadowTint;

        <span style="color:#888">//our lighting function. Will be called once per light</span>
        float4 LightingStepped(SurfaceOutput s, float3 lightDir, half3 viewDir, <span style="color:#080;font-weight:bold">float</span> shadowAttenuation){
            <span style="color:#888">//how much does the normal point towards the light?</span>
            <span style="color:#080;font-weight:bold">float</span> towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);
            <span style="color:#888">// make the lighting a hard cut</span>
            <span style="color:#080;font-weight:bold">float</span> towardsLightChange <span style="color:#333">=</span> fwidth(towardsLight);
            <span style="color:#080;font-weight:bold">float</span> lightIntensity <span style="color:#333">=</span> smoothstep(<span style="color:#40e;font-weight:bold">0</span>, towardsLightChange, towardsLight);

        <span style="color:#f00;background-color:#faa">#</span>ifdef USING_DIRECTIONAL_LIGHT
            <span style="color:#888">//for directional lights, get a hard vut in the middle of the shadow attenuation</span>
            <span style="color:#080;font-weight:bold">float</span> attenuationChange <span style="color:#333">=</span> fwidth(shadowAttenuation) <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>;
            <span style="color:#080;font-weight:bold">float</span> shadow <span style="color:#333">=</span> smoothstep(<span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">-</span> attenuationChange, <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> attenuationChange, shadowAttenuation);
        <span style="color:#f00;background-color:#faa">#</span><span style="color:#080;font-weight:bold">else</span>
            <span style="color:#888">//for other light types (point, spot), put the cutoff near black, so the falloff doesn&#39;t affect the range</span>
            <span style="color:#080;font-weight:bold">float</span> attenuationChange <span style="color:#333">=</span> fwidth(shadowAttenuation);
            <span style="color:#080;font-weight:bold">float</span> shadow <span style="color:#333">=</span> smoothstep(<span style="color:#40e;font-weight:bold">0</span>, attenuationChange, shadowAttenuation);
        <span style="color:#f00;background-color:#faa">#</span>endif
            lightIntensity <span style="color:#333">=</span> lightIntensity <span style="color:#333">*</span> shadow;

            <span style="color:#888">//calculate shadow color and mix light and shadow based on the light. Then taint it based on the light color</span>
            float3 shadowColor <span style="color:#333">=</span> s.Albedo <span style="color:#333">*</span> _ShadowTint;
            float4 color;
            color.rgb <span style="color:#333">=</span> lerp(shadowColor, s.Albedo, lightIntensity) <span style="color:#333">*</span> _LightColor0.rgb;
            color.a <span style="color:#333">=</span> s.Alpha;
            <span style="color:#080;font-weight:bold">return</span> color;
        }


        <span style="color:#888">//input struct which is automatically filled by unity</span>
        <span style="color:#080;font-weight:bold">struct</span> Input {
            float2 uv_MainTex;
        };

        <span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
        <span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutput o) {
            <span style="color:#888">//sample and tint albedo texture</span>
            fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
            col <span style="color:#333">*=</span> _Color;
            o.Albedo <span style="color:#333">=</span> col.rgb;

            o.Emission <span style="color:#333">=</span> _Emission;
        }
        ENDCG
    }
    FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><p>I hope it&rsquo;s interresting for you to you to see how to do simple stuff like antialiased lighting and that it&rsquo;ll help you in writing your own cool shaders. ðŸ’•</p>

			</div>I hope you enjoyed my tutorial âœ¨. If you want to support me further feel free to follow me on <a href="https://twitter.com/totallyRonja">twitter</a>, 
			throw me a one-time donation via <a href="https://ko-fi.com/ronjatutorials">ko-fi</a> 
			or support me on <a href="https://www.patreon.com/RonjaTutorials">patreon</a> 
			(I try to put updates also there, but I fail most of the time, bear with me ðŸ’–).<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
