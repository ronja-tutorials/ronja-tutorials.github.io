<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Hull Outlines | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary So far we only ever wrote a color to the screen once per shader (or let unity generate multiple passes for us via surface shaders). But we have the possibility to draw our mesh multiple times in a single shader. A great way to use this is to draw outlines. First we draw our object as usual and then we draw it again, but we change the vertices a bit so itâ€™s only visible around the original object, drawing a outline.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
		<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
		<link rel="canonical" href="https://www.ronja-tutorials.com/post/020-hull-outline/">

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/css/main.css">
    

    
      

    

    
    
    <meta property="og:title" content="Hull Outlines" />
<meta property="og:description" content="Summary So far we only ever wrote a color to the screen once per shader (or let unity generate multiple passes for us via surface shaders). But we have the possibility to draw our mesh multiple times in a single shader. A great way to use this is to draw outlines. First we draw our object as usual and then we draw it again, but we change the vertices a bit so itâ€™s only visible around the original object, drawing a outline." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/020-hull-outline/" />
<meta property="article:published_time" content="2018-07-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-07-21T00:00:00+00:00" />
<meta itemprop="name" content="Hull Outlines">
<meta itemprop="description" content="Summary So far we only ever wrote a color to the screen once per shader (or let unity generate multiple passes for us via surface shaders). But we have the possibility to draw our mesh multiple times in a single shader. A great way to use this is to draw outlines. First we draw our object as usual and then we draw it again, but we change the vertices a bit so itâ€™s only visible around the original object, drawing a outline.">
<meta itemprop="datePublished" content="2018-07-21T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-07-21T00:00:00+00:00" />
<meta itemprop="wordCount" content="1783">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Hull Outlines"/>
<meta name="twitter:description" content="Summary So far we only ever wrote a color to the screen once per shader (or let unity generate multiple passes for us via surface shaders). But we have the possibility to draw our mesh multiple times in a single shader. A great way to use this is to draw outlines. First we draw our object as usual and then we draw it again, but we change the vertices a bit so itâ€™s only visible around the original object, drawing a outline."/>

	

	

		<!-- unidentifying analytics, will not be shared with 3rd parties, I(Ronja) am just curious -->
		<script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      <h1 class="f1 athelas mt3 mb1">Hull Outlines</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-07-21T00:00:00Z">July 21, 2018</time>

      
      
		</header>
		
		<div style="margin-bottom: 70px;">
			<h3>Table Of Contents</h3>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#outlines-for-unlit-shaders">Outlines for Unlit Shaders</a>
      <ul>
        <li><a href="#source">Source</a></li>
      </ul>
    </li>
    <li><a href="#outlines-with-surface-shaders">Outlines with Surface Shaders</a>
      <ul>
        <li><a href="#source-1">Source</a></li>
      </ul>
    </li>
  </ul>
</nav>
		</div>

    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><div>
				
				<h2 id="summary">Summary <a href="#summary" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>So far we only ever wrote a color to the screen once per shader (or let unity generate multiple passes for us via surface shaders). But we have the possibility to draw our mesh multiple times in a single shader. A great way to use this is to draw outlines. First we draw our object as usual and then we draw it again, but we change the vertices a bit so itâ€™s only visible around the original object, drawing a outline.</p>
<p>To understand this Tutorial itâ€™s best if you <a href="https://www.ronja-tutorials.com/post/005-simple-surface/">understood surface shaders</a>.</p>
<p>The first version of this shader will be based on the <a href="https://www.ronja-tutorials.com/post/004-basic/">simple textured unlit shader</a>.</p>
<p><img src="/assets/images/posts/020/Result.png" alt="Result"></p>
<h2 id="outlines-for-unlit-shaders">Outlines for Unlit Shaders <a href="#outlines-for-unlit-shaders" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>We already have a shader pass in this shader, so we just duplicate that for now. Because weâ€™re writing the same information twice, this doesnâ€™t change how the shader looks though.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//The second pass where we render the outlines</span>
Pass{
    CGPROGRAM

    <span style="color:#888">//include useful shader functions</span>
    <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

    <span style="color:#888">//define vertex and fragment shader</span>
    <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
    <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

    <span style="color:#888">//texture and transforms of the texture</span>
    <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
    float4 _MainTex_ST;

    <span style="color:#888">//tint of the texture</span>
    fixed4 _Color;

    <span style="color:#888">//the object data that&#39;s put into the vertex shader</span>
    <span style="color:#080;font-weight:bold">struct</span> appdata{
        float4 vertex <span style="color:#333">:</span> POSITION;
        float2 uv <span style="color:#333">:</span> TEXCOORD0;
    };

    <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
    <span style="color:#080;font-weight:bold">struct</span> v2f{
        float4 position <span style="color:#333">:</span> SV_POSITION;
        float2 uv <span style="color:#333">:</span> TEXCOORD0;
    };

    <span style="color:#888">//the vertex shader</span>
    v2f vert(appdata v){
        v2f o;
        <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
        o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
        o.uv <span style="color:#333">=</span> TRANSFORM_TEX(v.uv, _MainTex);
        <span style="color:#080;font-weight:bold">return</span> o;
    }

    <span style="color:#888">//the fragment shader</span>
    fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
        fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
        col <span style="color:#333">*=</span> _Color;
        <span style="color:#080;font-weight:bold">return</span> col;
    }

    ENDCG
}
</code></pre></div><p>The next change is to set up our properties and variables. This second pass will only write a simple color to the screen so we donâ€™t need the texture. we just need the outline color and the outline thickness. We put the properties in the properties area at the top like usual. Itâ€™s important that we put the new variables in the second pass though.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//show values to edit in inspector</span>
Properties{
    _OutlineColor (<span style="color:#f00;background-color:#faa">&#34;</span>Outline Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
    _OutlineThickness (<span style="color:#f00;background-color:#faa">&#34;</span>Outline Thickness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#60e;font-weight:bold">.1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.03</span>

    _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
    _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//color of the outline</span>
fixed4 _OutlineColor;
<span style="color:#888">//thickness of the outline</span>
<span style="color:#080;font-weight:bold">float</span> _OutlineThickness;
</code></pre></div><p>The next step is to rewrite our fragment shader to use the new variable instead of a texture. We can simply return the color without any additional calculations in there.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#080;font-weight:bold">return</span> _OutlineColor;
}
</code></pre></div><p>Because we donâ€™t read from a texture in this pass, we can also ignore the uv coordinates, so we remove them from our input struct, our vertex to fragment struct and we stop passing them between the structs in the vertex shader.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the object data that&#39;s available to the vertex shader</span>
<span style="color:#080;font-weight:bold">struct</span> appdata{
    float4 vertex <span style="color:#333">:</span> POSITION;
};

<span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
<span style="color:#080;font-weight:bold">struct</span> v2f{
    float4 position <span style="color:#333">:</span> SV_POSITION;
};

<span style="color:#888">//the vertex shader</span>
v2f vert(appdata v){
    v2f o;
    <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
    o.position <span style="color:#333">=</span> UnityObjectToClipPos(position);
    <span style="color:#080;font-weight:bold">return</span> o;
}
</code></pre></div><p><img src="/assets/images/posts/020/DarkMonkey.png" alt=""></p>
<p>With those changes, we can see in the editor that the objects now simply have the color the outlines should have. Thatâ€™s because our second pass simply draws over everything the first pass has drawn. Thatâ€™s a thing weâ€™re going to fix later though.</p>
<p>Before that we ensure that the outlines are actually outside of the base object. For that we simply expand them along the their normals. That means we need the normals in our input struct, then we simply add them to the position of the vertices. We also normalize the normals and multiply them with the outline thickness to make the outlines as thick as we want them to be.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the object data that&#39;s available to the vertex shader</span>
<span style="color:#080;font-weight:bold">struct</span> appdata{
    float4 vertex <span style="color:#333">:</span> POSITION;
    float3 normal <span style="color:#333">:</span> NORMAL;
};
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the vertex shader</span>
v2f vert(appdata v){
    v2f o;
    <span style="color:#888">//calculate the position of the expanded object</span>
    float3 normal <span style="color:#333">=</span> normalize(v.normal);
    float3 outlineOffset <span style="color:#333">=</span> normal <span style="color:#333">*</span> _OutlineThickness;
    float3 position <span style="color:#333">=</span> v.vertex <span style="color:#333">+</span> outlineOffset;
    <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
    o.position <span style="color:#333">=</span> UnityObjectToClipPos(position);

    <span style="color:#080;font-weight:bold">return</span> o;
}
</code></pre></div><p><img src="/assets/images/posts/020/PulsatingMonkey.gif" alt=""></p>
<p>With this we can now adjust the thickness of our hull, but itâ€™s still hiding the base objects. The fix for that is that we donâ€™t draw the front of the hull. Usually when we render objects we only draw the front because of performance reasons (you might have looked inside a object before and were able to look outside, thatâ€™s why). For this we can now invert that and only draw the backside. That means we can still see the object because we can look into the hull and we can see the hull behinde the object because itâ€™s bigger than the object itself.</p>
<p>To tell unity to not render the frontsides of objects we add the Cull Front attribute to the hull pass outside of the hlsl area.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//The second pass where we render the outlines</span>
Pass{
    Cull Front
</code></pre></div><p><img src="/assets/images/posts/020/SimpleOutlines.png" alt=""></p>
<p>And with this we have the outlines how we want them.</p>
<h3 id="source">Source <a href="#source" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#00d;font-weight:bold">19</span>_InvertedHull<span style="color:#333">/</span>Unlit<span style="color:#f00;background-color:#faa">&#34;</span>{
    <span style="color:#888">//show values to edit in inspector</span>
    Properties{
        _OutlineColor (<span style="color:#f00;background-color:#faa">&#34;</span>Outline Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
        _OutlineThickness (<span style="color:#f00;background-color:#faa">&#34;</span>Outline Thickness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#60e;font-weight:bold">.1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.03</span>

        _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
        _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
    }

    SubShader{
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        <span style="color:#888">//The first pass where we render the Object itself</span>
        Pass{
            CGPROGRAM

            <span style="color:#888">//include useful shader functions</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#888">//define vertex and fragment shader</span>
            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            <span style="color:#888">//texture and transforms of the texture</span>
            <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
            float4 _MainTex_ST;

            <span style="color:#888">//tint of the texture</span>
            fixed4 _Color;

            <span style="color:#888">//the object data that&#39;s put into the vertex shader</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the vertex shader</span>
            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
                o.uv <span style="color:#333">=</span> TRANSFORM_TEX(v.uv, _MainTex);
                <span style="color:#080;font-weight:bold">return</span> o;
            }

            <span style="color:#888">//the fragment shader</span>
            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
                col <span style="color:#333">*=</span> _Color;
                <span style="color:#080;font-weight:bold">return</span> col;
            }

            ENDCG
        }

        <span style="color:#888">//The second pass where we render the outlines</span>
        Pass{
            Cull front

            CGPROGRAM

            <span style="color:#888">//include useful shader functions</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#888">//define vertex and fragment shader</span>
            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            <span style="color:#888">//color of the outline</span>
            fixed4 _OutlineColor;
            <span style="color:#888">//thickness of the outline</span>
            <span style="color:#080;font-weight:bold">float</span> _OutlineThickness;

            <span style="color:#888">//the object data that&#39;s available to the vertex shader</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
                float3 normal <span style="color:#333">:</span> NORMAL;
            };

            <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
            };

            <span style="color:#888">//the vertex shader</span>
            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//calculate the position of the expanded object</span>
                float3 normal <span style="color:#333">=</span> normalize(v.normal);
                float3 outlineOffset <span style="color:#333">=</span> normal <span style="color:#333">*</span> _OutlineThickness;
                float3 position <span style="color:#333">=</span> v.vertex <span style="color:#333">+</span> outlineOffset;
                <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(position);

                <span style="color:#080;font-weight:bold">return</span> o;
            }

            <span style="color:#888">//the fragment shader</span>
            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                <span style="color:#080;font-weight:bold">return</span> _OutlineColor;
            }

            ENDCG
        }
    }

    <span style="color:#888">//fallback which adds stuff we didn&#39;t implement like shadows and meta passes</span>
    FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><h2 id="outlines-with-surface-shaders">Outlines with Surface Shaders <a href="#outlines-with-surface-shaders" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h2>
<p>It is pretty straightforward to also apply the outlines to a surface shader. Unity does generate the passes of the surface shader for us, but we can still use our own passes too which unity wonâ€™t touch so they operate as usual.</p>
<p>This means we can simply copy the outline pass from our unlit shader into a surface shader and have it work just as we expect it to.</p>
<p><img src="/assets/images/posts/020/Result.png" alt=""></p>
<h3 id="source-1">Source <a href="#source-1" class="hanchor" ariaLabel="Anchor">ðŸ”—&#xFE0E;</a> </h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">020</span>_InvertedHull<span style="color:#333">/</span>Surface<span style="color:#f00;background-color:#faa">&#34;</span> {
    Properties {
        _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
        _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
        _Smoothness (<span style="color:#f00;background-color:#faa">&#34;</span>Smoothness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        _Metallic (<span style="color:#f00;background-color:#faa">&#34;</span>Metalness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        [HDR] _Emission (<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>)

        _OutlineColor (<span style="color:#f00;background-color:#faa">&#34;</span>Outline Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
        _OutlineThickness (<span style="color:#f00;background-color:#faa">&#34;</span>Outline Thickness<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.1</span>
    }
    SubShader {
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        CGPROGRAM
        <span style="color:#888">//the shader is a surface shader, meaning that it will be extended by unity in the background</span>
        <span style="color:#888">//to have fancy lighting and other features</span>
        <span style="color:#888">//our surface shader function is called surf and we use our custom lighting model</span>
        <span style="color:#888">//fullforwardshadows makes sure unity adds the shadow passes the shader might need</span>
        <span style="color:#888">//vertex:vert makes the shader use vert as a vertex shader function</span>
        <span style="color:#f00;background-color:#faa">#</span>pragma surface surf Standard fullforwardshadows
        <span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

        <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
        fixed4 _Color;

        <span style="color:#080;font-weight:bold">half</span> _Smoothness;
        <span style="color:#080;font-weight:bold">half</span> _Metallic;
        half3 _Emission;

        <span style="color:#888">//input struct which is automatically filled by unity</span>
        <span style="color:#080;font-weight:bold">struct</span> Input {
            float2 uv_MainTex;
        };

        <span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
        <span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
            <span style="color:#888">//read albedo color from texture and apply tint</span>
            fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
            col <span style="color:#333">*=</span> _Color;
            o.Albedo <span style="color:#333">=</span> col.rgb;
            <span style="color:#888">//just apply the values for metalness, smoothness and emission</span>
            o.Metallic <span style="color:#333">=</span> _Metallic;
            o.Smoothness <span style="color:#333">=</span> _Smoothness;
            o.Emission <span style="color:#333">=</span> _Emission;
        }
        ENDCG

        <span style="color:#888">//The second pass where we render the outlines</span>
        Pass{
            Cull Front

            CGPROGRAM

            <span style="color:#888">//include useful shader functions</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#888">//define vertex and fragment shader</span>
            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            <span style="color:#888">//tint of the texture</span>
            fixed4 _OutlineColor;
            <span style="color:#080;font-weight:bold">float</span> _OutlineThickness;

            <span style="color:#888">//the object data that&#39;s put into the vertex shader</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
                float4 normal <span style="color:#333">:</span> NORMAL;
            };

            <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
            };

            <span style="color:#888">//the vertex shader</span>
            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex <span style="color:#333">+</span> normalize(v.normal) <span style="color:#333">*</span> _OutlineThickness);
                <span style="color:#080;font-weight:bold">return</span> o;
            }

            <span style="color:#888">//the fragment shader</span>
            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                <span style="color:#080;font-weight:bold">return</span> _OutlineColor;
            }

            ENDCG
        }
    }
    FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><p>The differences of outlines via a inverted hull shader to a postprocessing effect is that you can make the outlines on a material by material basis, you donâ€™t have to apply it to all objects. Also itâ€™s a different look than choosing outlines based on depth and normals. Itâ€™s best to inform yourself about both techniques and then choose which is better for your game.</p>
<p>I hope itâ€™s now clear how shaders with multiple passes can work and how to use them to make outlines.</p>
<p>You can also find the source code for the shaders here:<!-- raw HTML omitted -->
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/020_Inverted_Hull/UnlitOutlines.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/020_Inverted_Hull/UnlitOutlines.shader</a><!-- raw HTML omitted -->
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/020_Inverted_Hull/SurfaceOutlines.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/020_Inverted_Hull/SurfaceOutlines.shader</a></p>

			</div>I hope you enjoyed my tutorial âœ¨. If you want to support me further feel free to follow me on <a href="https://twitter.com/totallyRonja">twitter</a>, 
			throw me a one-time donation via <a href="https://ko-fi.com/ronjatutorials">ko-fi</a> 
			or support me on <a href="https://www.patreon.com/RonjaTutorials">patreon</a> 
			(I try to put updates also there, but I fail most of the time, bear with me ðŸ’–).<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
