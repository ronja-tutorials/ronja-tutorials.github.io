<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Polygon Clipping | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary Of course everything we render so far is made of polygons, but someone asked me how to clip a polygon shape based on a list of points in a shader so I‚Äôll explain how to do that now. I will explain how to do that with a single shader pass in a fragment shader, a different way would be to actually generate triangles based on your polygon and use stencil buffers to clip, but I won‚Äôt explain that in this tutorial.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
		<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
		<link rel="canonical" href="https://www.ronja-tutorials.com/post/014-polygon-clipping/">

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/css/main.css">
    

    
      

    

    
    
    <meta property="og:title" content="Polygon Clipping" />
<meta property="og:description" content="Summary Of course everything we render so far is made of polygons, but someone asked me how to clip a polygon shape based on a list of points in a shader so I‚Äôll explain how to do that now. I will explain how to do that with a single shader pass in a fragment shader, a different way would be to actually generate triangles based on your polygon and use stencil buffers to clip, but I won‚Äôt explain that in this tutorial." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/014-polygon-clipping/" />
<meta property="article:published_time" content="2018-06-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-06-10T00:00:00+00:00" />
<meta itemprop="name" content="Polygon Clipping">
<meta itemprop="description" content="Summary Of course everything we render so far is made of polygons, but someone asked me how to clip a polygon shape based on a list of points in a shader so I‚Äôll explain how to do that now. I will explain how to do that with a single shader pass in a fragment shader, a different way would be to actually generate triangles based on your polygon and use stencil buffers to clip, but I won‚Äôt explain that in this tutorial.">
<meta itemprop="datePublished" content="2018-06-10T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-06-10T00:00:00+00:00" />
<meta itemprop="wordCount" content="2668">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Polygon Clipping"/>
<meta name="twitter:description" content="Summary Of course everything we render so far is made of polygons, but someone asked me how to clip a polygon shape based on a list of points in a shader so I‚Äôll explain how to do that now. I will explain how to do that with a single shader pass in a fragment shader, a different way would be to actually generate triangles based on your polygon and use stencil buffers to clip, but I won‚Äôt explain that in this tutorial."/>

	
		
		
		<script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      <h1 class="f1 athelas mt3 mb1">Polygon Clipping</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-06-10T00:00:00Z">June 10, 2018</time>

      
      
		</header>
		
		<div style="margin-bottom: 70px;">
			<h3>Table Of Contents</h3>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#draw-line">Draw Line</a></li>
    <li><a href="#draw-a-polygon-of-multiple-lines">Draw a Polygon of multiple lines</a>
      <ul>
        <li><a href="#filling-the-corner-array">Filling the Corner Array</a></li>
      </ul>
    </li>
    <li><a href="#clip-and-color-the-polygon">Clip and Color the Polygon</a></li>
  </ul>
</nav>
		</div>

    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><div>
				
				<h2 id="summary">Summary <a href="#summary" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>Of course everything we render so far is made of polygons, but someone asked me how to clip a polygon shape based on a list of points in a shader so I‚Äôll explain how to do that now. I will explain how to do that with a single shader pass in a fragment shader, a different way would be to actually generate triangles based on your polygon and use stencil buffers to clip, but I won‚Äôt explain that in this tutorial.</p>
<p>Because this tutorial explains a simple technique that doesn‚Äôt do that much with fancy graphics I will explain it in a unlit shader, but it will work the same way in surface shaders. The base for this tutorial will be my simple shader with properties, so you should know how to do that before starting <a href="/basics.html">this tutorial</a></p>
<p><img src="/assets/images/posts/014/Result.gif" alt="Result"></p>
<h2 id="draw-line">Draw Line <a href="#draw-line" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>The first thing we have to add to our shader is the world position. Like in the other shaders (planar, triplanar and chessboard) we do that by multiplying the object position with the object to world matrix and pass that value to the fragment shader.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
<span style="color:#080;font-weight:bold">struct</span> v2f{
    float4 position <span style="color:#333">:</span> SV_POSITION;
    float3 worldPos <span style="color:#333">:</span> TEXCOORD0;
};

<span style="color:#888">//the vertex shader</span>
v2f vert(appdata v){
    v2f o;
    <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
    o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
    <span style="color:#888">//calculate and assign vertex position in the world</span>
    float4 worldPos <span style="color:#333">=</span> mul(unity_ObjectToWorld, v.vertex);
    o.worldPos <span style="color:#333">=</span> worldPos.xyz;
    <span style="color:#080;font-weight:bold">return</span> o;
}
</code></pre></div><p>Then we can progress to the fragment shader. here we start by calculating which side of a line a point is of. Since we will later generate our lines based on points, it‚Äôs easiest to define them as two points the line goes through.</p>
<p>To calculate which side of the line a point is on, we generate two vectors, first, a vector which goes from a arbitrary point of the line to our point and second the ‚Äúline normal‚Äù. Usually the concept of a line normal doesn‚Äôt make much sense, but here we need a left and a right side of the line so we can define the line normal as a vector that points orthogonally to the left of the line direction.</p>
<p>When we have those vectors we can calculate their dot product and get the side the point is on. If the dot product is positive, the vector to the point points somewhat in the same direction as the line normal and it‚Äôs on the side the line normal points towards. If the dot product is negative the vector to the point points somewhat in the opposite direction as the line normal and the point is on th other side. If the dot product is exactly zero, the vector to the point is orthogonal to the line normal and the point is on the line.</p>
<p><img src="/assets/images/posts/014/Vectors.png" alt="The Vectors we can combine for stuff"></p>
<p>To do this in shader code, we start by defining two points that define a line and then calculating those three vectors we need. We start by calculating the line direction. We get it by subtracting the first from the second line point (when calculating the difference between two points we always have to subtract the start from the goal if we care about the direction). Then we rotate the line point by 90 degree by switching it‚Äôs x and y components and inverting the new x part(if we inverted the y part we‚Äôd have a vector that points to the right of the line). And lastly we subtract one of the points defining the line from the point we‚Äôre checking to get the vector to the point.</p>
<p>After that we take the dot product of the line normal and the vector to the point and draw it to the screen.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float2 linePoint1 <span style="color:#333">=</span> float2(<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>);
float2 linePoint2 <span style="color:#333">=</span> float2(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>);

<span style="color:#888">//variables we need for our calculations</span>
float2 lineDirection <span style="color:#333">=</span> linePoint2 <span style="color:#333">-</span> linePoint1;
float2 lineNormal <span style="color:#333">=</span> float2(<span style="color:#333">-</span>lineDirection.y, lineDirection.x);
float2 toPos <span style="color:#333">=</span> i.worldPos.xy <span style="color:#333">-</span> linePoint1;

<span style="color:#888">//which side the tested position is on</span>
<span style="color:#080;font-weight:bold">float</span> side <span style="color:#333">=</span> dot(toPos, lineNormal);
side <span style="color:#333">=</span> step(<span style="color:#40e;font-weight:bold">0</span>, side);

<span style="color:#080;font-weight:bold">return</span> side;
</code></pre></div><p><img src="/assets/images/posts/014/Distance.png" alt="a diagonal line which is very smooth"></p>
<p>As you can see, we actually see a small gradient at the line we defined. But we don‚Äôt really want a gradient, we want a clear differentiation. The gradient is here, because all colors below 0 (to the right of the line) are counted as black, all colors between 0 and 1 (just to the left of the line) are greyscale values and all colors of 1 and higher(way to the left of teh line) are displayed as white. A easy fix for that is the step function which takes two values and returns 0 if the value to the left is bigger and 1 otherwise. So if we give the step function a 0 and the result of our dor product it will give us a clear distinction between the two sides.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//which side the tested position is on</span>
<span style="color:#080;font-weight:bold">float</span> side <span style="color:#333">=</span> dot(toPos, lineNormal);
side <span style="color:#333">=</span> step(<span style="color:#40e;font-weight:bold">0</span>, side);

<span style="color:#080;font-weight:bold">return</span> side;
</code></pre></div><p><img src="/assets/images/posts/014/Line.png" alt="a diagonal line"></p>
<p>We continue by adding a new point and two new lines which should allow us to make a triangle. For that it‚Äôs best to put the calculations we made so far in a method to reuse them more easily. For that we move all of our calculations to a new method and take the information we use as arguments, so in this case we want to take the point we want to check, the first point of the line and the second point of the line as arguments.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//return 1 if a thing is left of the line, 0 if not</span>
<span style="color:#080;font-weight:bold">float</span> isLeftOfLine(float2 pos, float2 linePoint1, float2 linePoint2){
    <span style="color:#888">//variables we need for our calculations</span>
    float2 lineDirection <span style="color:#333">=</span> linePoint2 <span style="color:#333">-</span> linePoint1;
    float2 lineNormal <span style="color:#333">=</span> float2(<span style="color:#333">-</span>lineDirection.y, lineDirection.x);
    float2 toPos <span style="color:#333">=</span> pos <span style="color:#333">-</span> linePoint1;

    <span style="color:#888">//which side the tested position is on</span>
    <span style="color:#080;font-weight:bold">float</span> side <span style="color:#333">=</span> dot(toPos, lineNormal);
    side <span style="color:#333">=</span> step(<span style="color:#40e;font-weight:bold">0</span>, side);
    <span style="color:#080;font-weight:bold">return</span> side;
}

<span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    float2 linePoint1 <span style="color:#333">=</span> float2(<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>);
    float2 linePoint2 <span style="color:#333">=</span> float2(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>);

    side <span style="color:#333">=</span> isLeftOfLine(i.worldPos.xy, linePoint1, linePoint2);

    <span style="color:#080;font-weight:bold">return</span> side;
}
</code></pre></div><h2 id="draw-a-polygon-of-multiple-lines">Draw a Polygon of multiple lines <a href="#draw-a-polygon-of-multiple-lines" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>When we want to combine the multiple results of the lines we can do that in different ways, we can either define the result to be true if it‚Äôs to the left of all lines and false otherwise or we can say the result is true if it‚Äôs left of one or more lines and only false if it‚Äôs to the right of all lines. The triangle I defined goes clockwise, that means the left of the lines is outside, that means to differentiate between inside and outside of the polygon we have to find the union of all ‚Äúleft side‚Äù fragments. We do that by adding the results of the lines, the outsides will add up and have values of 1 or higher, the inside of the polygon will have a value of 0 everywhere.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    float2 linePoint1 <span style="color:#333">=</span> float2(<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>);
    float2 linePoint2 <span style="color:#333">=</span> float2(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">1</span>);
    float2 linePoint3 <span style="color:#333">=</span> float2(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>);

    <span style="color:#080;font-weight:bold">float</span> outsideTriangle <span style="color:#333">=</span> isLeftOfLine(i.worldPos.xy, linePoint1, linePoint2);
    outsideTriangle <span style="color:#333">=</span> outsideTriangle <span style="color:#333">+</span> isLeftOfLine(i.worldPos.xy, linePoint2, linePoint3);
    outsideTriangle <span style="color:#333">=</span> outsideTriangle <span style="color:#333">+</span> isLeftOfLine(i.worldPos.xy, linePoint3, linePoint1);

    <span style="color:#080;font-weight:bold">return</span> outsideTriangle;
}
</code></pre></div><p><img src="/assets/images/posts/014/Triangle.png" alt="a black triangle on a white plane"></p>
<p>Now that we can display a polygon sucessfully, I‚Äôd like to expand it so we can edit it more easily without editing the shader code. For that we add two new variables, a array of positions and how much that array is filled. The first one will hold all of the points of our polygon, the second one is there because shaders don‚Äôt support dynamic arrays, so we have to choose a length for the array and then we fill it more or less.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the variables for the corners</span>
<span style="color:#080;font-weight:bold">uniform</span> float2 _corners[<span style="color:#00d;font-weight:bold">1000</span>];
<span style="color:#080;font-weight:bold">uniform</span> uint _cornerCount;
</code></pre></div><h3 id="filling-the-corner-array">Filling the Corner Array <a href="#filling-the-corner-array" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h3>
<p>There are no properties for arrays, so we have to fill them via C# code. I added two attributes to the new class, execute in edit mode to make the script update our polygon without us starting the game and require component, to make sure the script is on the same gameobject as the renderer which has the material with the shader we‚Äôre writing.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cs" data-lang="cs"><span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">System.Collections</span>;
<span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">System.Collections.Generic</span>;
<span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">UnityEngine</span>;
<span style="color:#00c">
</span><span style="color:#00c">[ExecuteInEditMode]</span>
<span style="color:#00c">[RequireComponent(typeof(Renderer))]</span>
<span style="color:#080;font-weight:bold">public</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">PolygonController</span> : MonoBehaviour {


}
</code></pre></div><p>We then add two variables to the class, the material with the shader and a array of points which we will then pass to the shader. The material is private, because we‚Äôll get it via code and it‚Äôs only used in this class. The position array is also private because we don‚Äôt need access from outside, but we give it the serialize field attribute to make unity remember the value and show it in the inspector.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cs" data-lang="cs"><span style="color:#00c">[SerializeField]</span>
<span style="color:#080;font-weight:bold">private</span> Vector2[] corners;

<span style="color:#080;font-weight:bold">private</span> Material _mat;
</code></pre></div><p>Then we write the method which will pass the information to the shader. In it we first check if we already fetched the material and get the renderer on the gameobject and get it‚Äôs material if we didn‚Äôt. We use the sharedmaterial field of the renderer for this because if we used the material field we‚Äôd create a copy of the material which we don‚Äôt want hight here.</p>
<p>Then we allocate a new array of 4d vectors which can hold 1000 variables. The reason we use 4d vectors instead of the 2d vectors we need is that the unity API only allows us to pass 4d vectors and the reason for the 1000 variable length is that as I mentioned previously shaders don‚Äôt support dynamic array lengths so we have to choose a maximum of points and always choose that length, I chose 1000 pretty much randomly.</p>
<p>We then fill this array with the positions of our points, the 2d vectors will automatically be converted to 4d vectors with 0 at the 3rd and 4th position.</p>
<p>After we prepared our vector array we pass it to our material and then also pass it the amount of positions we actually use.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cs" data-lang="cs"><span style="color:#080;font-weight:bold">void</span> UpdateMaterial(){
    <span style="color:#888">//fetch material if we haven&#39;t already
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span>(_mat == <span style="color:#080;font-weight:bold">null</span>)
        _mat = GetComponent&lt;Renderer&gt;().sharedMaterial;

    <span style="color:#888">//allocate and fill array to pass
</span><span style="color:#888"></span>    Vector4[] vec4Corners = <span style="color:#080;font-weight:bold">new</span> Vector4[<span style="color:#60e;font-weight:bold">1000</span>];
    <span style="color:#080;font-weight:bold">for</span>(<span style="color:#339;font-weight:bold">int</span> i=<span style="color:#60e;font-weight:bold">0</span>;i&lt;corners.Length;i++){
        vec4Corners[i] = corners[i];
    }

    <span style="color:#888">//pass array to material
</span><span style="color:#888"></span>    _mat.SetVectorArray(<span style="background-color:#fff0f0">&#34;_corners&#34;</span>, vec4Corners);
    _mat.SetInt(<span style="background-color:#fff0f0">&#34;_cornerCount&#34;</span>, corners.Length);
}
</code></pre></div><p>The next step is to actually call this function, we do this in two methods, one which we call Start and one which we call OnValidate. The first one will automatically called by unity when the game starts and the second one will automatically be called by unity when a variable of the script changes in the inspector.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cs" data-lang="cs"><span style="color:#080;font-weight:bold">void</span> Start(){
    UpdateMaterial();
}

<span style="color:#080;font-weight:bold">void</span> OnValidate(){
    UpdateMaterial();
}
</code></pre></div><p>After writing the script we can add it to our project to do it‚Äôs job. We just add it as a component to the same gameobject the renderer with our material is on. And when we set up our script, we can set our corners easily by adding to the array in the inspector.</p>
<p><img src="/assets/images/posts/014/Inspector.png" alt="unity inspector where we can see the corner array"></p>
<p>Next we go back to our shader to actually use the array. To do that we instantiate our outside triangle variable as zero.</p>
<p>Then we iterate over the array with a typical for loop. We start the loop at 0 because the first index of arrays in hlsl is adressed 0, the second with 1 etc‚Ä¶ we stop when the iterator value goes over the amount of corners we specified via C# and we increase the iterator by 1 every loop. We explicitely tell hlsl to loop the for loop, the alternative would be to unroll it which means it would just copypaste the stuff happening in the for loop under each other. Unrolling is usually faster in shaders, but we don‚Äôt have a fixed length in our case so we have to use loop.</p>
<p>In the loop, we just add the return value of the side function of one line. As the points of the line we use the corner at the position of the iterator and the corner at the position of the iterator plus one. The problem that emerges when we use that plus one is that at the last point we acess the array at a point we didn‚Äôt set, but we want to go back to the first point instead. In this position modulo helps us, we add one to the iterator and then take the modulo with the length of the valid array, that way it jumps back to 0 if it would acess a invalid value otherwise.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{

    <span style="color:#080;font-weight:bold">float</span> outsideTriangle <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;

    [loop]
    <span style="color:#080;font-weight:bold">for</span>(uint index;index<span style="color:#333">&lt;</span>_cornerCount;index<span style="color:#333">++</span>){
        outsideTriangle <span style="color:#333">+=</span> isLeftOfLine(i.worldPos.xy, _corners[index], _corners[(index<span style="color:#333">+</span><span style="color:#00d;font-weight:bold">1</span>) <span style="color:#333">%</span> _cornerCount]);
    }

    <span style="color:#080;font-weight:bold">return</span> outsideTriangle;
}
</code></pre></div><p><img src="/assets/images/posts/014/Hexagon.png" alt="a black hexagon on a white plane"></p>
<p>And with that we have a polygon just based on a few points (if it doesn‚Äôt show for you, just nudge the values in the inspector a bit to call OnValidate).</p>
<h2 id="clip-and-color-the-polygon">Clip and Color the Polygon <a href="#clip-and-color-the-polygon" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>The person who requested this tutorial asked how to clip a polygon, so that‚Äôs the last thing we‚Äôre going to add here. In hlsl there is a function to discard polygons called clip. We pass it a value and if that value is lower than 0 the fragment won‚Äôt be rendered, otherwise the function does nothing.</p>
<p>We can pass the outsideTriangle variable into the clip function, but nothing will happen because all values of the value are 0 or higher. To actually clip everything outside of the polygon we can simply invert the value and the values inside of the polygon will stay 0 and all of the values outside will be negative and will be clipped.</p>
<p>Because we now use the outsideTriangle variable for it‚Äôs intended use, we can now stop drawing it to the screen and just print the color again.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">    clip(<span style="color:#333">-</span>outsideTriangle);
    <span style="color:#080;font-weight:bold">return</span> outsideTriangle;
}
</code></pre></div><p><img src="/assets/images/posts/014/SuperHexagon.png" alt="super - hexagon"></p>
<p><img src="/assets/images/posts/014/ConcaveBreaking.gif" alt="the shape not being displayed properly when trying to make a concave shape"></p>
<p>The biggest disadvantage with this technique is that we can only render convex polygons, it breaks when we try to use concave ones.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">014</span>_Polygon<span style="color:#f00;background-color:#faa">&#34;</span>
{
    <span style="color:#888">//show values to edit in inspector</span>
    Properties{
        _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
    }

    SubShader{
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

        Pass{
            CGPROGRAM

            <span style="color:#888">//include useful shader functions</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#888">//define vertex and fragment shader</span>
            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            fixed4 _Color;

            <span style="color:#888">//the variables for the corners</span>
            <span style="color:#080;font-weight:bold">uniform</span> float2 _corners[<span style="color:#00d;font-weight:bold">1000</span>];
            <span style="color:#080;font-weight:bold">uniform</span> uint _cornerCount;

            <span style="color:#888">//the object data that&#39;s put into the vertex shader</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
            };

            <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
                float3 worldPos <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the vertex shader</span>
            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
                <span style="color:#888">//calculate and assign vertex position in the world</span>
                float4 worldPos <span style="color:#333">=</span> mul(unity_ObjectToWorld, v.vertex);
                o.worldPos <span style="color:#333">=</span> worldPos.xyz;
                <span style="color:#080;font-weight:bold">return</span> o;
            }

            <span style="color:#888">//return 1 if a thing is left of the line, 0 if not</span>
            <span style="color:#080;font-weight:bold">float</span> isLeftOfLine(float2 pos, float2 linePoint1, float2 linePoint2){
                <span style="color:#888">//variables we need for our calculations</span>
                float2 lineDirection <span style="color:#333">=</span> linePoint2 <span style="color:#333">-</span> linePoint1;
                float2 lineNormal <span style="color:#333">=</span> float2(<span style="color:#333">-</span>lineDirection.y, lineDirection.x);
                float2 toPos <span style="color:#333">=</span> pos <span style="color:#333">-</span> linePoint1;

                <span style="color:#888">//which side the tested position is on</span>
                <span style="color:#080;font-weight:bold">float</span> side <span style="color:#333">=</span> dot(toPos, lineNormal);
                side <span style="color:#333">=</span> step(<span style="color:#40e;font-weight:bold">0</span>, side);
                <span style="color:#080;font-weight:bold">return</span> side;
            }

            <span style="color:#888">//the fragment shader</span>
            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{

                <span style="color:#080;font-weight:bold">float</span> outsideTriangle <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;

                [loop]
                <span style="color:#080;font-weight:bold">for</span>(uint index;index<span style="color:#333">&lt;</span>_cornerCount;index<span style="color:#333">++</span>){
                    outsideTriangle <span style="color:#333">+=</span> isLeftOfLine(i.worldPos.xy, _corners[index], _corners[(index<span style="color:#333">+</span><span style="color:#00d;font-weight:bold">1</span>) <span style="color:#333">%</span> _cornerCount]);
                }

                clip(<span style="color:#333">-</span>outsideTriangle);
                <span style="color:#080;font-weight:bold">return</span> _Color;
            }

            ENDCG
        }
    }
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cs" data-lang="cs"><span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">System.Collections</span>;
<span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">System.Collections.Generic</span>;
<span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">UnityEngine</span>;
<span style="color:#00c">
</span><span style="color:#00c">[ExecuteInEditMode]</span>
<span style="color:#00c">[RequireComponent(typeof(Renderer))]</span>
<span style="color:#080;font-weight:bold">public</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">PolygonController</span> : MonoBehaviour {
<span style="color:#00c">	[SerializeField]</span>
	<span style="color:#080;font-weight:bold">private</span> Vector2[] corners;

	<span style="color:#080;font-weight:bold">private</span> Material _mat;

	<span style="color:#080;font-weight:bold">void</span> Start(){
		UpdateMaterial();
	}

	<span style="color:#080;font-weight:bold">void</span> OnValidate(){
		UpdateMaterial();
	}

	<span style="color:#080;font-weight:bold">void</span> UpdateMaterial(){
		<span style="color:#888">//fetch material if we haven&#39;t already
</span><span style="color:#888"></span>		<span style="color:#080;font-weight:bold">if</span>(_mat == <span style="color:#080;font-weight:bold">null</span>)
			_mat = GetComponent&lt;Renderer&gt;().sharedMaterial;

		<span style="color:#888">//allocate and fill array to pass
</span><span style="color:#888"></span>		Vector4[] vec4Corners = <span style="color:#080;font-weight:bold">new</span> Vector4[<span style="color:#60e;font-weight:bold">1000</span>];
		<span style="color:#080;font-weight:bold">for</span>(<span style="color:#339;font-weight:bold">int</span> i=<span style="color:#60e;font-weight:bold">0</span>;i&lt;corners.Length;i++){
			vec4Corners[i] = corners[i];
		}

		<span style="color:#888">//pass array to material
</span><span style="color:#888"></span>		_mat.SetVectorArray(<span style="background-color:#fff0f0">&#34;_corners&#34;</span>, vec4Corners);
		_mat.SetInt(<span style="background-color:#fff0f0">&#34;_cornerCount&#34;</span>, corners.Length);
	}

}
</code></pre></div><p>I hope you learned something about how to approach problems with multiple points and vectors. And I hope I talked about what you wanted to know, Alex.</p>
<p>You can also find the source code for this tutorial here:<!-- raw HTML omitted -->
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/Polygon.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/Polygon.shader</a><!-- raw HTML omitted -->
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/PolygonController.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/PolygonController.cs</a><!-- raw HTML omitted --></p>

			</div>I hope you enjoyed my tutorial ‚ú®. If you want to support me further feel free to follow me on <a href="https://twitter.com/totallyRonja">twitter</a>, 
			throw me a one-time donation via <a href="https://ko-fi.com/ronjatutorials">ko-fi</a> 
			or support me on <a href="https://www.patreon.com/RonjaTutorials">patreon</a> 
			(I try to put updates also there, but I fail most of the time, bear with me üíñ).<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
