<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Basic Shader | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary In the last three tutorials I explained some of the cornerstones of how shaders work. In this one I show you how to fill in the rest.
The main thing I didn&rsquo;t show was actual executed code. Thats because you don&rsquo;t need much code to get a shader running at first and all of the fancy code is in specialized tutorials.
What we have so far Everything here should be explained in one of the previous three tutorials.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="Basic Shader" />
<meta property="og:description" content="Summary In the last three tutorials I explained some of the cornerstones of how shaders work. In this one I show you how to fill in the rest.
The main thing I didn&rsquo;t show was actual executed code. Thats because you don&rsquo;t need much code to get a shader running at first and all of the fancy code is in specialized tutorials.
What we have so far Everything here should be explained in one of the previous three tutorials." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/004-basic/" />
<meta property="article:published_time" content="2018-03-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-03-23T00:00:00+00:00" />
<meta itemprop="name" content="Basic Shader">
<meta itemprop="description" content="Summary In the last three tutorials I explained some of the cornerstones of how shaders work. In this one I show you how to fill in the rest.
The main thing I didn&rsquo;t show was actual executed code. Thats because you don&rsquo;t need much code to get a shader running at first and all of the fancy code is in specialized tutorials.
What we have so far Everything here should be explained in one of the previous three tutorials.">
<meta itemprop="datePublished" content="2018-03-23T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-03-23T00:00:00+00:00" />
<meta itemprop="wordCount" content="961">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Basic Shader"/>
<meta name="twitter:description" content="Summary In the last three tutorials I explained some of the cornerstones of how shaders work. In this one I show you how to fill in the rest.
The main thing I didn&rsquo;t show was actual executed code. Thats because you don&rsquo;t need much code to get a shader running at first and all of the fancy code is in specialized tutorials.
What we have so far Everything here should be explained in one of the previous three tutorials."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      
      
      <h1 class="f1 athelas mt3 mb1">Basic Shader</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-03-23T00:00:00Z">March 23, 2018</time>

      
      
    </header>
    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><h2 id="summary">Summary</h2>
<p>In the last three tutorials I explained some of the cornerstones of how shaders work. In this one I show you how to fill in the rest.</p>
<p>The main thing I didn&rsquo;t show was actual executed code. Thats because you don&rsquo;t need much code to get a shader running at first and all of the fancy code is in specialized tutorials.</p>
<p><img src="/assets/images/posts/004/Result.png" alt="Result"></p>
<h2 id="what-we-have-so-far">What we have so far</h2>
<p>Everything here should be explained in one of the previous three tutorials. Feel free to tell me if you think otherwise.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">001</span><span style="color:#333">-</span><span style="color:#40e;font-weight:bold">004</span>_Basic_Unlit<span style="color:#f00;background-color:#faa">&#34;</span>{
  <span style="color:#888">//show values to edit in inspector</span>
  Properties{
    _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
    _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
  }

  SubShader{
    <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
    Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span> }

    Pass{
      CGPROGRAM

      <span style="color:#888">//texture and transforms of the texture</span>
      <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
      float4 _MainTex_ST;

      <span style="color:#888">//tint of the texture</span>
      fixed4 _Color;

      <span style="color:#888">//the mesh data thats read by the vertex shader</span>
      <span style="color:#080;font-weight:bold">struct</span> appdata{
        float4 vertex <span style="color:#333">:</span> POSITION;
        float2 uv <span style="color:#333">:</span> TEXCOORD0;
      };

      <span style="color:#888">//the data thats passed from the vertex to the fragment shader and interpolated by the rasterizer</span>
      <span style="color:#080;font-weight:bold">struct</span> v2f{
        float4 position <span style="color:#333">:</span> SV_POSITION;
        float2 uv <span style="color:#333">:</span> TEXCOORD0;
      };

      ENDCG
    }
  }
  Fallback <span style="color:#f00;background-color:#faa">&#34;</span>VertexLit<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><h2 id="setting-up-the-shader-stages">Setting up the shader stages</h2>
<p>Each of the shader stages is represented as a hlsl function. To define which function in your program represent the stages you add <code>#pragma</code> statements too your program. Important for the vertex stage is that it takes in the vertex data and returns the interpolators and important for the fragment stage is that it takes in the interpolators and returns a vector which writes into the render target. So this looks something like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//define vertex and fragment shader functions</span>
<span style="color:#579">#pragma vertex vert</span>
<span style="color:#579">#pragma fragment frag</span>

<span style="color:#888">//the vertex shader function</span>
v2f vert(appdata v){
  <span style="color:#888">//vertex stage stuff</span>
}

<span style="color:#888">//the fragment shader function</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
  <span style="color:#888">//fragment stage code</span>
}
</code></pre></div><h2 id="vertex-stage">Vertex stage</h2>
<p>At the start of the function that defines our vertex stage we create the interpolator struct we&rsquo;ll return at the end. Then we&rsquo;ll fill it with data and return it.</p>
<p>The main job of the vertex stage is to transform the vertex positions from local objectspace to clipspace where they can be rendered. This is done internally via a matrix multiplication, but we don&rsquo;t have to understand that yet since unity gives us functions do the matrix multiplication for us. To use those macros (and lots of other useful code) in our shader we import a include file via <code>#include &quot;UnityCG.cginc&quot;</code>. The function to transform a position from local to clip space is called <code>UnityObjectToClipPos</code>. The UnityCG file also has a macro (works similar to functions) that helps us transform the uv coordinates that are passed with the vertex data into uv coordinates that respect the tiling and offset that we set in the editor, it is named <code>TRANSFORM_TEX</code> and takes the base uv coordinates as well as the name of the texture as arguments.</p>
<p>With that code applied the vertex function should look something like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the vertex shader function</span>
v2f vert(appdata v){
  v2f o;
  <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered correctly</span>
  o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
  <span style="color:#888">//apply the texture transforms to the UV coordinates and pass them to the v2f struct</span>
  o.uv <span style="color:#333">=</span> TRANSFORM_TEX(v.uv, _MainTex);
  <span style="color:#080;font-weight:bold">return</span> o;
}
</code></pre></div><h2 id="fragment-stage">Fragment stage</h2>
<p>In the fragment stage we take in the interpolators and use them as well as uniform variables to figure out what color that pixel should have. The simplest version of that could just be <code>return float4(1,1,1,1);</code> for a completely white mesh, but in most cases we want to use a bit more complicated result and use textures.</p>
<p>To access textures we usually use the <code>tex2D</code> function which takes in the texture as its first argument and the uv coordinates as the second argument and then returns the color at that coordinate. In this example we&rsquo;ll save the resulting color, multiply it with a color we defined as a uniform variable and return the result.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader function</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//read the texture color at the uv coordinate</span>
  fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
  <span style="color:#888">//multiply the texture color and tint color</span>
  col <span style="color:#333">*=</span> _Color;
  <span style="color:#888">//return the final color to be drawn on screen</span>
  <span style="color:#080;font-weight:bold">return</span> col;
}
</code></pre></div><p>And with all of that you have your very first shader!</p>
<h2 id="source">Source</h2>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader</a></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">001</span><span style="color:#333">-</span><span style="color:#40e;font-weight:bold">004</span>_Basic_Unlit<span style="color:#f00;background-color:#faa">&#34;</span>{
  <span style="color:#888">//show values to edit in inspector</span>
  Properties{
    _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
    _MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
  }

  SubShader{
    <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
    Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span> }

    Pass{
      CGPROGRAM

      <span style="color:#888">//include useful shader functions</span>
      <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

      <span style="color:#888">//define vertex and fragment shader functions</span>
      <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
      <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

      <span style="color:#888">//texture and transforms of the texture</span>
      <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
      float4 _MainTex_ST;

      <span style="color:#888">//tint of the texture</span>
      fixed4 _Color;

      <span style="color:#888">//the mesh data thats read by the vertex shader</span>
      <span style="color:#080;font-weight:bold">struct</span> appdata{
        float4 vertex <span style="color:#333">:</span> POSITION;
        float2 uv <span style="color:#333">:</span> TEXCOORD0;
      };

      <span style="color:#888">//the data thats passed from the vertex to the fragment shader and interpolated by the rasterizer</span>
      <span style="color:#080;font-weight:bold">struct</span> v2f{
        float4 position <span style="color:#333">:</span> SV_POSITION;
        float2 uv <span style="color:#333">:</span> TEXCOORD0;
      };

      <span style="color:#888">//the vertex shader function</span>
      v2f vert(appdata v){
        v2f o;
        <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered correctly</span>
        o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
        <span style="color:#888">//apply the texture transforms to the UV coordinates and pass them to the v2f struct</span>
        o.uv <span style="color:#333">=</span> TRANSFORM_TEX(v.uv, _MainTex);
        <span style="color:#080;font-weight:bold">return</span> o;
      }

      <span style="color:#888">//the fragment shader function</span>
      fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
          <span style="color:#888">//read the texture color at the uv coordinate</span>
        fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
        <span style="color:#888">//multiply the texture color and tint color</span>
        col <span style="color:#333">*=</span> _Color;
        <span style="color:#888">//return the final color to be drawn on screen</span>
        <span style="color:#080;font-weight:bold">return</span> col;
      }

      ENDCG
    }
  }
  Fallback <span style="color:#f00;background-color:#faa">&#34;</span>VertexLit<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
