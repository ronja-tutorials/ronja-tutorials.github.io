<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Postprocessing with Normal Texture | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary Another piece of information we can easily get our hands on thats very useful for postprocessing is the normals of the scene. They show in which direction the surface at any given pixel is pointing.
To understand how to get and use the normals of the scene it’s best to know how to access the scene depth first, I made a tutorial on how to do that here.
Read Depth and Normals We start this tutorials with the files from the depth postprocessing tutorial and expand them as we need.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="Postprocessing with Normal Texture" />
<meta property="og:description" content="Summary Another piece of information we can easily get our hands on thats very useful for postprocessing is the normals of the scene. They show in which direction the surface at any given pixel is pointing.
To understand how to get and use the normals of the scene it’s best to know how to access the scene depth first, I made a tutorial on how to do that here.
Read Depth and Normals We start this tutorials with the files from the depth postprocessing tutorial and expand them as we need." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/018-postprocessing-normal/" />
<meta property="article:published_time" content="2018-07-08T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-07-08T00:00:00+00:00" />
<meta itemprop="name" content="Postprocessing with Normal Texture">
<meta itemprop="description" content="Summary Another piece of information we can easily get our hands on thats very useful for postprocessing is the normals of the scene. They show in which direction the surface at any given pixel is pointing.
To understand how to get and use the normals of the scene it’s best to know how to access the scene depth first, I made a tutorial on how to do that here.
Read Depth and Normals We start this tutorials with the files from the depth postprocessing tutorial and expand them as we need.">
<meta itemprop="datePublished" content="2018-07-08T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-07-08T00:00:00+00:00" />
<meta itemprop="wordCount" content="1690">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Postprocessing with Normal Texture"/>
<meta name="twitter:description" content="Summary Another piece of information we can easily get our hands on thats very useful for postprocessing is the normals of the scene. They show in which direction the surface at any given pixel is pointing.
To understand how to get and use the normals of the scene it’s best to know how to access the scene depth first, I made a tutorial on how to do that here.
Read Depth and Normals We start this tutorials with the files from the depth postprocessing tutorial and expand them as we need."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      
      
      <h1 class="f1 athelas mt3 mb1">Postprocessing with Normal Texture</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-07-08T00:00:00Z">July 8, 2018</time>

      
      
    </header>
    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><h2 id="summary">Summary</h2>
<p>Another piece of information we can easily get our hands on thats very useful for postprocessing is the normals of the scene. They show in which direction the surface at any given pixel is pointing.</p>
<p>To understand how to get and use the normals of the scene it’s best to know how to access the scene depth first, I made a tutorial on how to do that <a href="https://www.ronja-tutorials.com/post/018-postprocessing-normal/">here</a>.</p>
<p><img src="/assets/images/posts/018/Result.png" alt="Result"></p>
<h2 id="read-depth-and-normals">Read Depth and Normals</h2>
<p>We start this tutorials with the files from the depth postprocessing tutorial and expand them as we need.</p>
<p>The first change is to remove all of the code from the c# script which we used to drive the wave in the previous tutorial.
Then, we don‘t tell the camera to render the depth of objects anymore - instead we tell it to render a texture which includes the depth as well as the normals.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cs" data-lang="cs"><span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">void</span> Start(){
    <span style="color:#888">//get the camera and tell it to render a depthnormals texture
</span><span style="color:#888"></span>    cam = GetComponent&lt;Camera&gt;();
    cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.DepthNormals;
}
</code></pre></div><p>And that’s already all of the setup we need to access the normals. Next we edit our shader.</p>
<p>We also remove the all of the code used for the wave function here. Then we rename the _CameraDepthTexture to _CameraDepthNormalsTexture, so it’s written in by unity.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//show values to edit in inspector</span>
Properties{
    [HideInInspector]_MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the depth normals texture</span>
<span style="color:#080;font-weight:bold">sampler2D</span> _CameraDepthNormalsTexture;
</code></pre></div><p>With this setup we can now read from the depthnormals texture in our fragment shader. If we just do that and just draw the texture to the screen, we can already see something interresting.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//read depthnormal</span>
    float4 depthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, i.uv);

    <span style="color:#080;font-weight:bold">return</span> depthnormal;
}
</code></pre></div><p><img src="/assets/images/posts/018/EncodedNormals.png" alt="a image where we can see depth and normals, but they are encoded so it looks kinda matte"></p>
<p>But what we can see isn’t what we really want, we only see red and green values and some blue in the distance. That’s because as it’s name suggests, this texture holds the normals as well as the depth texture, so we have to decode it first. Luckily unity provides us a method that does exactly that. We have to give it the depthnormal value as well as two other values the function will write the depth and the normals in.</p>
<p>Unlike the depth texture, the depth value we have now is already linear between the camera and the far plane, so we can easily adapt the code from the previous tutorial to get the distance from the camera again.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//read depthnormal</span>
    float4 depthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, i.uv);

    <span style="color:#888">//decode depthnormal</span>
    float3 normal;
    <span style="color:#080;font-weight:bold">float</span> depth;
    DecodeDepthNormal(depthnormal, depth, normal);

    <span style="color:#888">//get depth as distance from camera in units </span>
    depth <span style="color:#333">=</span> depth <span style="color:#333">*</span> _ProjectionParams.z;

    <span style="color:#080;font-weight:bold">return</span> depth;
}
</code></pre></div><p><img src="/assets/images/posts/018/Depth.png" alt="Depth texture"></p>
<p>But let’s go back to using the normals. When we just print the normals as colors to the screen we already get a pretty good result.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//read depthnormal</span>
    float4 depthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, i.uv);

    <span style="color:#888">//decode depthnormal</span>
    float3 normal;
    <span style="color:#080;font-weight:bold">float</span> depth;
    DecodeDepthNormal(depthnormal, depth, normal);

    <span style="color:#888">//get depth as distance from camera in units </span>
    depth <span style="color:#333">=</span> depth <span style="color:#333">*</span> _ProjectionParams.z;

    <span style="color:#080;font-weight:bold">return</span> float4(normal, <span style="color:#00d;font-weight:bold">1</span>);
}
</code></pre></div><p><img src="/assets/images/posts/018/DecodedNormals.gif" alt=""></p>
<p>But if we rotate the camera, we can can see that one point on a surface doesn’t always have the same normal, that’s because the normals are stored relative to the camera. So if we want the normal in the world we have to go additional steps.</p>
<p>We can easily convert our viewspace normals to world space, but sadly unity doesn’t provide us a function for that so we have to pass it to our shader ourselves. So we go back to our C# script and implement that.</p>
<p>First we get a reference to our camera, we already get the camera in our start method, so we can directly save it to a class variable right there. Then in the OnRenderImage method we get the viewspace to worldspace matrix from the camera and then pass it to our shader. The reason we can’t pass the matrix to our shader once in the start method is that we want to move and rotate our camera after starting the effect and the matrix changes when we do that.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">using</span> UnityEngine;

<span style="color:#888">//behaviour which should lie on the same gameobject as the main camera</span>
<span style="color:#080;font-weight:bold">public</span> <span style="color:#080;font-weight:bold">class</span> NormalPostprocessing <span style="color:#333">:</span> MonoBehaviour {
	<span style="color:#888">//material that&#39;s applied when doing postprocessing</span>
	[SerializeField]
	private Material postprocessMaterial;

	private Camera cam;

	private <span style="color:#080;font-weight:bold">void</span> Start(){
		<span style="color:#888">//get the camera and tell it to render a depthnormals texture</span>
		cam <span style="color:#333">=</span> GetComponent<span style="color:#333">&lt;</span>Camera<span style="color:#333">&gt;</span>();
		cam.depthTextureMode <span style="color:#333">=</span> cam.depthTextureMode <span style="color:#333">|</span> DepthTextureMode.DepthNormals;
	}

	<span style="color:#888">//method which is automatically called by unity after the camera is done rendering</span>
	private <span style="color:#080;font-weight:bold">void</span> OnRenderImage(RenderTexture source, RenderTexture destination){
		<span style="color:#888">//get viewspace to worldspace matrix and pass it to shader</span>
		Matrix4x4 viewToWorld <span style="color:#333">=</span> cam.cameraToWorldMatrix;
		postprocessMaterial.SetMatrix(<span style="color:#f00;background-color:#faa">&#34;</span>_viewToWorld<span style="color:#f00;background-color:#faa">&#34;</span>, viewToWorld);
		<span style="color:#888">//draws the pixels from the source texture to the destination texture</span>
		Graphics.Blit(source, destination, postprocessMaterial);
	}
}
</code></pre></div><p>Next we can use that matrix in our shader. we add a new variable for it and then multiply it with the normal before using it. We cast it to a 3x3 matrix before the multiplication so the position change doesn’t get applied only the rotation, that’s all we need for normals.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//matrix to convert from view space to world space</span>
float4x4 _viewToWorld;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">    normal <span style="color:#333">=</span> normal <span style="color:#333">=</span> mul((float3x3)_viewToWorld, normal);
    <span style="color:#080;font-weight:bold">return</span> float4(normal, <span style="color:#00d;font-weight:bold">1</span>);
}
</code></pre></div><p><img src="/assets/images/posts/018/WorldspaceNormals.gif" alt=""></p>
<h2 id="color-the-top">Color the Top</h2>
<p>Now that we have the worldspace normals, we can do a simple effect to get comfortable with them. We can color the top of all objects in the scene in a color.</p>
<p>To do this, we simply compare the normal to the up vector. We do this via a dot product which returns 1 when both normalized vectors point in the same direction(when the surface is flat), 0 when they’re orthogonal (in our case on walls) and -1 when they’re opposite to each other(in our case that would mean a roof over the camera).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">    <span style="color:#080;font-weight:bold">float</span> up <span style="color:#333">=</span> dot(float3(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#40e;font-weight:bold">0</span>), normal);
    <span style="color:#080;font-weight:bold">return</span> up;
}
</code></pre></div><p><img src="/assets/images/posts/018/Topness.png" alt=""></p>
<p>To make it more obvious what’s on top and what doesn’t count as on top, we can now take this smooth value and do a step to differentiate between top and not on top. If the second value is smaller, it will return 0 and we will see black, if it’s bigger, we will see white.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> up <span style="color:#333">=</span> dot(float3(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#40e;font-weight:bold">0</span>), normal);
up <span style="color:#333">=</span> step(<span style="color:#60e;font-weight:bold">0.5</span>, up);
<span style="color:#080;font-weight:bold">return</span> up;
</code></pre></div><p><img src="/assets/images/posts/018/TopCutoff.png" alt=""></p>
<p>The next step is to bring back the original colors where we don’t define the surface to be on top. For that we just read from the main texture and then do a linear interpolation between that color and the color we define to be on top (white at the moment).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> up <span style="color:#333">=</span> dot(float3(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#40e;font-weight:bold">0</span>), normal);
up <span style="color:#333">=</span> step(<span style="color:#60e;font-weight:bold">0.5</span>, up);
float4 source <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
float4 col <span style="color:#333">=</span> lerp(source, float4(<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>), up);
<span style="color:#080;font-weight:bold">return</span> col;
</code></pre></div><p><img src="/assets/images/posts/018/WhiteTop.png" alt=""></p>
<p>And as a last step we’re going to add some customizability. So we add a property and a global variable for the up cutoff value and the top color.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">_upCutoff (<span style="color:#f00;background-color:#faa">&#34;</span>up cutoff<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.7</span>
_topColor (<span style="color:#f00;background-color:#faa">&#34;</span>top color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>)
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//effect customisation</span>
<span style="color:#080;font-weight:bold">float</span> _upCutoff;
float4 _topColor;
</code></pre></div><p>Then we replace the fixed 0.5 we used previously for our cutoff value with the new cutoff variable and linearly interpolate to the top color instead of the fix white color. We can then also multiply the up color with the alpha value of the top color, that way when we lower the alpha value the top will let some of the original color through.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">    <span style="color:#080;font-weight:bold">float</span> up <span style="color:#333">=</span> dot(float3(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#40e;font-weight:bold">0</span>), normal);
    up <span style="color:#333">=</span> step(_upCutoff, up);
    float4 source <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
    float4 col <span style="color:#333">=</span> lerp(source, _topColor, up <span style="color:#333">*</span> _topColor.a);
    <span style="color:#080;font-weight:bold">return</span> col;
}
</code></pre></div><p><img src="/assets/images/posts/018/Result.png" alt=""></p>
<p>This effect was mainly made to show how the depthnormals texture works. If you want a snow effect it’s probably better to just do it in the shader for the object the snow is on instead of a postprocessing effect. I’m sorry I didn’t come up with a better example.</p>
<h2 id="source">Source</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">using</span> UnityEngine;

<span style="color:#888">//behaviour which should lie on the same gameobject as the main camera</span>
<span style="color:#080;font-weight:bold">public</span> <span style="color:#080;font-weight:bold">class</span> NormalPostprocessing <span style="color:#333">:</span> MonoBehaviour {
    <span style="color:#888">//material that&#39;s applied when doing postprocessing</span>
    [SerializeField]
    private Material postprocessMaterial;

    private Camera cam;

    private <span style="color:#080;font-weight:bold">void</span> Start(){
        <span style="color:#888">//get the camera and tell it to render a depthnormals texture</span>
        cam <span style="color:#333">=</span> GetComponent<span style="color:#333">&lt;</span>Camera<span style="color:#333">&gt;</span>();
        cam.depthTextureMode <span style="color:#333">=</span> cam.depthTextureMode <span style="color:#333">|</span> DepthTextureMode.DepthNormals;
    }

    <span style="color:#888">//method which is automatically called by unity after the camera is done rendering</span>
    private <span style="color:#080;font-weight:bold">void</span> OnRenderImage(RenderTexture source, RenderTexture destination){
        <span style="color:#888">//get viewspace to worldspace matrix and pass it to shader</span>
        Matrix4x4 viewToWorld <span style="color:#333">=</span> cam.cameraToWorldMatrix;
        postprocessMaterial.SetMatrix(<span style="color:#f00;background-color:#faa">&#34;</span>_viewToWorld<span style="color:#f00;background-color:#faa">&#34;</span>, viewToWorld);
        <span style="color:#888">//draws the pixels from the source texture to the destination texture</span>
        Graphics.Blit(source, destination, postprocessMaterial);
    }
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">01</span><span style="color:#00d;font-weight:bold">8</span>_Normal_Postprocessing<span style="color:#f00;background-color:#faa">&#34;</span>{
    <span style="color:#888">//show values to edit in inspector</span>
    Properties{
        [HideInInspector]_MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
        _upCutoff (<span style="color:#f00;background-color:#faa">&#34;</span>up cutoff<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#60e;font-weight:bold">0.7</span>
        _topColor (<span style="color:#f00;background-color:#faa">&#34;</span>top color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">1</span>)
    }

    SubShader{
        <span style="color:#888">// markers that specify that we don&#39;t need culling </span>
        <span style="color:#888">// or comparing/writing to the depth buffer</span>
        Cull Off
        ZWrite Off 
        ZTest Always

        Pass{
            CGPROGRAM
            <span style="color:#888">//include useful shader functions</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#888">//define vertex and fragment shader</span>
            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            <span style="color:#888">//the rendered screen so far</span>
            <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
            <span style="color:#888">//matrix to convert from view space to world space</span>
            float4x4 _viewToWorld;
            <span style="color:#888">//the depth normals texture</span>
            <span style="color:#080;font-weight:bold">sampler2D</span> _CameraDepthNormalsTexture;

            <span style="color:#888">//effect customisation</span>
            <span style="color:#080;font-weight:bold">float</span> _upCutoff;
            float4 _topColor;


            <span style="color:#888">//the object data that&#39;s put into the vertex shader</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the vertex shader</span>
            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
                o.uv <span style="color:#333">=</span> v.uv;
                <span style="color:#080;font-weight:bold">return</span> o;
            }

            <span style="color:#888">//the fragment shader</span>
            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                <span style="color:#888">//read depthnormal</span>
                float4 depthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, i.uv);

                <span style="color:#888">//decode depthnormal</span>
                float3 normal;
                <span style="color:#080;font-weight:bold">float</span> depth;
                DecodeDepthNormal(depthnormal, depth, normal);

                <span style="color:#888">//get depth as distance from camera in units </span>
                depth <span style="color:#333">=</span> depth <span style="color:#333">*</span> _ProjectionParams.z;

                normal <span style="color:#333">=</span> mul((float3x3)_viewToWorld, normal);

                <span style="color:#080;font-weight:bold">float</span> up <span style="color:#333">=</span> dot(float3(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#40e;font-weight:bold">0</span>), normal);
                up <span style="color:#333">=</span> step(_upCutoff, up);
                float4 source <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
                float4 col <span style="color:#333">=</span> lerp(source, _topColor, up <span style="color:#333">*</span> _topColor.a);
                <span style="color:#080;font-weight:bold">return</span> col;
            }
            ENDCG
        }
    }
}
</code></pre></div><p>You can also find the source here:<!-- raw HTML omitted -->
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/018_NormalPostprocessing/NormalPostprocessing.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/018_NormalPostprocessing/NormalPostprocessing.cs</a>
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/018_NormalPostprocessing/NormalPostprocessing.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/018_NormalPostprocessing/NormalPostprocessing.shader</a></p>
<p>I hope that I was able to convey how to access normal textures and that this will be a solid foundation for future effects.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "disqus_vlgXjcPhg1" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
