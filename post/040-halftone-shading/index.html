<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Halftone Shading | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="This tutorial is on another common toon shading technique called halftone shading, unlike normal shading it only uses full lit or full unlit as colors, but it doesn&rsquo;t create a hard cut either. Instead it uses a pattern to decide which pixels are lit and which aren&rsquo;t and the chance of a pixel being lit gets higher the brighter the pixel would be with a normal lighting method. To understand this tutorial I recommend reading and understanding the tutorial about custom lighting methods and the tutorial about generating screenspace texture coordinates.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="Halftone Shading" />
<meta property="og:description" content="This tutorial is on another common toon shading technique called halftone shading, unlike normal shading it only uses full lit or full unlit as colors, but it doesn&rsquo;t create a hard cut either. Instead it uses a pattern to decide which pixels are lit and which aren&rsquo;t and the chance of a pixel being lit gets higher the brighter the pixel would be with a normal lighting method. To understand this tutorial I recommend reading and understanding the tutorial about custom lighting methods and the tutorial about generating screenspace texture coordinates." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/040-halftone-shading/" />
<meta property="article:published_time" content="2019-03-02T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-03-02T00:00:00+00:00" />
<meta itemprop="name" content="Halftone Shading">
<meta itemprop="description" content="This tutorial is on another common toon shading technique called halftone shading, unlike normal shading it only uses full lit or full unlit as colors, but it doesn&rsquo;t create a hard cut either. Instead it uses a pattern to decide which pixels are lit and which aren&rsquo;t and the chance of a pixel being lit gets higher the brighter the pixel would be with a normal lighting method. To understand this tutorial I recommend reading and understanding the tutorial about custom lighting methods and the tutorial about generating screenspace texture coordinates.">
<meta itemprop="datePublished" content="2019-03-02T00:00:00+00:00" />
<meta itemprop="dateModified" content="2019-03-02T00:00:00+00:00" />
<meta itemprop="wordCount" content="2317">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Halftone Shading"/>
<meta name="twitter:description" content="This tutorial is on another common toon shading technique called halftone shading, unlike normal shading it only uses full lit or full unlit as colors, but it doesn&rsquo;t create a hard cut either. Instead it uses a pattern to decide which pixels are lit and which aren&rsquo;t and the chance of a pixel being lit gets higher the brighter the pixel would be with a normal lighting method. To understand this tutorial I recommend reading and understanding the tutorial about custom lighting methods and the tutorial about generating screenspace texture coordinates."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      
      
      <h1 class="f1 athelas mt3 mb1">Halftone Shading</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-03-02T00:00:00Z">March 2, 2019</time>

      
      
    </header>
    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><p>This tutorial is on another common toon shading technique called halftone shading, unlike normal shading it only uses full lit or full unlit as colors, but it doesn&rsquo;t create a hard cut either. Instead it uses a pattern to decide which pixels are lit and which aren&rsquo;t and the chance of a pixel being lit gets higher the brighter the pixel would be with a normal lighting method. To understand this tutorial I recommend reading and understanding <a href="https://www.ronja-tutorials.com/post/013-custom-lighting/">the tutorial about custom lighting methods</a> and <a href="https://www.ronja-tutorials.com/post/039-screenspace-texture/">the tutorial about generating screenspace texture coordinates</a>.</p>
<p><img src="/assets/images/posts/040/Result.png" alt=""></p>
<h2 id="hard-step-halftone-shading">Hard Step Halftone Shading</h2>
<p>For the first simplest implementation we use the result of the <a href="https://www.ronja-tutorials.com/post/013-custom-lighting/">custom surface lighting tutorial</a> as the base shader and start to modify that. First we make it simpler by removing the part where the shader reads the value of the toon ramp. Instead we multiply the shadow attenuation earlier with the <code>towardsLight</code> variable and pass it to the <code>saturate</code> function to clamp it between 0 and 1. Additionally the light intensity is now only saved as a one-dimensional float since we don&rsquo;t read from a texture with colors anymore.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#00d;font-weight:bold">40</span>_DitheredLighting<span style="color:#f00;background-color:#faa">&#34;</span> {
	<span style="color:#888">//show values to edit in inspector</span>
	Properties {
		_Color (<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
		_MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
		[HDR] _Emission (<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>)
	}
	SubShader {
		<span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
		Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

		CGPROGRAM

		<span style="color:#888">//the shader is a surface shader, meaning that it will be extended by unity in the background to have fancy lighting and other features</span>
		<span style="color:#888">//our surface shader function is called surf and we use our custom lighting model</span>
		<span style="color:#888">//fullforwardshadows makes sure unity adds the shadow passes the shader might need</span>
		<span style="color:#f00;background-color:#faa">#</span>pragma surface surf Custom fullforwardshadows
		<span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

		<span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
		fixed4 _Color;
		half3 _Emission;

		<span style="color:#888">//our lighting function. Will be called once per light</span>
		float4 LightingCustom(SurfaceOutput s, float3 lightDir, <span style="color:#080;font-weight:bold">float</span> atten){
			<span style="color:#888">//how much does the normal point towards the light?</span>
			<span style="color:#080;font-weight:bold">float</span> towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);
			<span style="color:#888">//remap the value from -1 to 1 to between 0 and 1</span>
			towardsLight <span style="color:#333">=</span> towardsLight <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> <span style="color:#60e;font-weight:bold">0.5</span>;

			<span style="color:#888">//combine shadow and light and clamp the result between 0 and 1</span>
			<span style="color:#080;font-weight:bold">float</span> lightIntensity <span style="color:#333">=</span> saturate(atten <span style="color:#333">*</span> towardsLight);

			<span style="color:#888">//combine the color</span>
			float4 col;
			<span style="color:#888">//intensity we calculated previously, diffuse color, light falloff and shadowcasting, color of the light</span>
			col.rgb <span style="color:#333">=</span> lightIntensity <span style="color:#333">*</span> s.Albedo <span style="color:#333">*</span> _LightColor0.rgb;
			<span style="color:#888">//in case we want to make the shader transparent in the future - irrelevant right now</span>
			col.a <span style="color:#333">=</span> s.Alpha;

			<span style="color:#080;font-weight:bold">return</span> col;
		}

		<span style="color:#888">//input struct which is automatically filled by unity</span>
		<span style="color:#080;font-weight:bold">struct</span> Input {
			float2 uv_MainTex;
		};

		<span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
		<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutput o) {
			<span style="color:#888">//sample and tint albedo texture</span>
			fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
			col <span style="color:#333">*=</span> _Color;
			o.Albedo <span style="color:#333">=</span> col.rgb;

			o.Emission <span style="color:#333">=</span> _Emission;
		}
		ENDCG
	}
	FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><p><img src="/assets/images/posts/040/BasicShading.png" alt=""></p>
<p>With this done, we already have a value that represents how much a given pixel is lit, the next step is to change it from a gradient to a binary one or zero value. To do this we have to compare the value to another value. For this tutorial, we&rsquo;re getting this other value by sampling a texture via screenspace texture coordinates. You can also use other texture coordinates like the normal UV coordinates, triplanar coordinates or even completely procedural shapes for this that don&rsquo;t rely on textures at all, but I&rsquo;ve found screenspace coordinates to be robust and versatile so I&rsquo;m gonna use them as a example for this tutorial.</p>
<p>In the <a href="https://www.ronja-tutorials.com/post/039-screenspace-texture/">tutorial about screenspace coordinates</a> I explain how to get the screenspace coordinates. As soon as we created them, we have to get them from our surface function to our lighting function. For that purpose we have to create a new surface output struct with all of the data we need. This data includes the base color of the shader, the screenspace texture coordinate, the emission of the material, the alpha transparency and the normal. Not all of those values might seem important to us right now, but the alpha and emission variables for example are needed for unity to be able to successfully generate the final shader.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">sampler2D</span> _HalftonePattern;
float4 _HalftonePattern_ST;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">struct</span> HalftoneSurfaceOutput {
    fixed3 Albedo;
    float2 ScreenPos;
    half3 Emission;
    <span style="color:#080;font-weight:bold">fixed</span> Alpha;
    fixed3 Normal;
};
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//input struct which is automatically filled by unity</span>
<span style="color:#080;font-weight:bold">struct</span> Input {
    float2 uv_MainTex;
    float4 screenPos;
};
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
<span style="color:#080;font-weight:bold">void</span> surf(Input i, <span style="color:#080;font-weight:bold">inout</span> HalftoneSurfaceOutput o) {
    <span style="color:#888">//sample and tint albedo texture</span>
    fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
    col <span style="color:#333">*=</span> _Color;
    o.Albedo <span style="color:#333">=</span> col.rgb;

    o.Emission <span style="color:#333">=</span> _Emission;

    <span style="color:#080;font-weight:bold">float</span> aspect <span style="color:#333">=</span> _ScreenParams.x <span style="color:#333">/</span> _ScreenParams.y;
    o.ScreenPos <span style="color:#333">=</span> i.screenPos.xy <span style="color:#333">/</span> i.screenPos.w;
    o.ScreenPos <span style="color:#333">=</span> TRANSFORM_TEX(o.ScreenPos, _HalftonePattern);
    o.ScreenPos.x <span style="color:#333">=</span> o.ScreenPos.x <span style="color:#333">*</span> aspect;
}
</code></pre></div><p>After transmitting those values to the lighting function we can use them to read from the new texture and write the texture values to the screen. I used a texture with several circular gradients which I generated with shadron, but you can use any tiling gradient (I also use a heart shaped signed distance field in the examples which I generated using <a href="https://assetstore.unity.com/packages/tools/utilities/sdf-toolkit-free-50191">catlikecodings signed distance field generator: https://assetstore.unity.com/packages/tools/utilities/sdf-toolkit-free-50191</a>).</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//our lighting function. Will be called once per light</span>
float4 LightingHalftone(HalftoneSurfaceOutput s, float3 lightDir, <span style="color:#080;font-weight:bold">float</span> atten){

    <span style="color:#888">//get halftone comparison value</span>
    <span style="color:#080;font-weight:bold">float</span> halftoneValue <span style="color:#333">=</span> tex2D(_HalftonePattern, s.ScreenPos).r;

    <span style="color:#080;font-weight:bold">return</span> halftoneValue;
}
</code></pre></div><p><img src="/assets/images/posts/040/HalftoneCompare.png" alt=""></p>
<p>Now that we have both the light intensity and the halftone comparison value we can compare them with the step function to get a binary 0 or 1 value based on the pattern of our texture. The first argument of the step function is the halftone value we just sampled from the texture and the second argument is the lightness value. If the lightness is brighter than the halftone texture value, the shader sets to pixel to be fully lit and if it&rsquo;s less it&rsquo;s treated as shadowed. The result of the step value is put back into the <code>lightIntensity</code> value.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//our lighting function. Will be called once per light</span>
float4 LightingHalftone(HalftoneSurfaceOutput s, float3 lightDir, <span style="color:#080;font-weight:bold">float</span> atten){
    <span style="color:#888">//how much does the normal point towards the light?</span>
    <span style="color:#080;font-weight:bold">float</span> towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);
    <span style="color:#888">//remap the value from -1 to 1 to between 0 and 1</span>
    towardsLight <span style="color:#333">=</span> towardsLight <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> <span style="color:#60e;font-weight:bold">0.5</span>;

    <span style="color:#888">//combine shadow and light and clamp the result between 0 and 1 to get light intensity</span>
    <span style="color:#080;font-weight:bold">float</span> lightIntensity <span style="color:#333">=</span> saturate(atten <span style="color:#333">*</span> towardsLight);

    <span style="color:#888">//get halftone comparison value</span>
    <span style="color:#080;font-weight:bold">float</span> halftoneValue <span style="color:#333">=</span> tex2D(_HalftonePattern, s.ScreenPos).r;

    <span style="color:#888">//make lightness binary between hully lit and fully shadow based on halftone pattern.</span>
    lightIntensity <span style="color:#333">=</span> step(halftoneValue, lightIntensity);

    <span style="color:#888">//combine the color</span>
    float4 col;
    <span style="color:#888">//intensity we calculated previously, diffuse color, light falloff and shadowcasting, color of the light</span>
    col.rgb <span style="color:#333">=</span> lightIntensity <span style="color:#333">*</span> s.Albedo <span style="color:#333">*</span> _LightColor0.rgb;
    <span style="color:#888">//in case we want to make the shader transparent in the future - irrelevant right now</span>
    col.a <span style="color:#333">=</span> s.Alpha;

    <span style="color:#080;font-weight:bold">return</span> col;
}
</code></pre></div><p><img src="/assets/images/posts/040/SimpleHalftone.png" alt=""></p>
<h2 id="antialiased-halftone-pattern">Antialiased Halftone Pattern</h2>
<p>This works well, but we&rsquo;re not actually limited by binary colors in our shaders. That means we can preserve the appearance of the halftone binary values while still using greyscale values between them to make the result look less choppy. For this we replace our <code>step</code> function with a <code>smoothstep</code> function and interpolate the colors over a single pixel. The first task is to figure out how much the value we compare to changes over a single pixel. Luckily shaders provide us with the <code>fwidth</code> function which returns a approximation of exactly that value. We divide the value of a halftone by two and then do the smoothstep from the comparison value minus half of the change where the result will be zero to the comparison value plus half of the change where the result will be one. The value we use to step between those values is the light intensity, just like previously.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//make lightness binary between fully lit and fully shadow based on halftone pattern (with a bit of antialiasing between)</span>
<span style="color:#080;font-weight:bold">float</span> halftoneChange <span style="color:#333">=</span> fwidth(halftoneValue) <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>;
lightIntensity <span style="color:#333">=</span> smoothstep(halftoneValue <span style="color:#333">-</span> halftoneChange, halftoneValue <span style="color:#333">+</span> halftoneChange, lightIntensity);
</code></pre></div><p><img src="/assets/images/posts/040/AntiAliasing.png" alt=""></p>
<h2 id="remapping-comparison-values">Remapping Comparison Values</h2>
<p>If we want to change how much of the shading is shadowed and how much is illuminated we can change our texture, but this is a slow and indirect process. For quick prototyping we can also remap the values of the texture via a few uniform variables we can expose. In image manipulation programs, this process is often referred to as adjusting levels. We&rsquo;re going to write a external function for this which will take the halftone comparison value as a argument as well as the input minimum value, the input maximum value, the output minimum value and the output maximum value. Apart from the first value all additional arguments are new properties we add to the shader. The minimum and maximum values don&rsquo;t mean that we&rsquo;re not allowed to pass values to the function that are outside of those ranges, it merely means that for input value that is the same value as the minimum input value the function will generate a output value that&rsquo;s equal to the minimum output value and similarly for the maxmimum values. Values that are not those fixed values are interpolated linearly, so a input value thats exactly in the middle between the min and max input values leads to a output value thats exactly between the output minimum and maximum values.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">_RemapInputMin (<span style="color:#f00;background-color:#faa">&#34;</span>Remap <span style="color:#080;font-weight:bold">input</span> min value<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
_RemapInputMax (<span style="color:#f00;background-color:#faa">&#34;</span>Remap <span style="color:#080;font-weight:bold">input</span> max value<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
_RemapOutputMin (<span style="color:#f00;background-color:#faa">&#34;</span>Remap <span style="color:#080;font-weight:bold">output</span> min value<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
_RemapOutputMax (<span style="color:#f00;background-color:#faa">&#34;</span>Remap <span style="color:#080;font-weight:bold">output</span> max value<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> _RemapInputMin;
<span style="color:#080;font-weight:bold">float</span> _RemapInputMax;
<span style="color:#080;font-weight:bold">float</span> _RemapOutputMin;
<span style="color:#080;font-weight:bold">float</span> _RemapOutputMax;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//make lightness binary between fully lit and fully shadow based on halftone pattern (with a bit of antialiasing between)</span>
halftoneValue <span style="color:#333">=</span> map(halftoneValue, _RemapInputMin, _RemapInputMax, _RemapOutputMin, _RemapOutputMax);
<span style="color:#080;font-weight:bold">float</span> halftoneChange <span style="color:#333">=</span> fwidth(halftoneValue) <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>;
lightIntensity <span style="color:#333">=</span> smoothstep(halftoneValue <span style="color:#333">-</span> halftoneChange, halftoneValue <span style="color:#333">+</span> halftoneChange, lightIntensity);
</code></pre></div><p>Then we write the remapping function. The function consists of two parts, first we get the relative position of the input value by first subtracting the input minimum to make the value based on zero and then we divide it by the range of the input values which we can calculate by subtracting the minimum from the maximum. This relative value will be between 0 and 1 if the input value is between the minumum and maximum values, but is also able to represent values outside of that range. With this value we can then do a linear interpolation from the output minimum to the output maximum values and return the result of that.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> map(<span style="color:#080;font-weight:bold">float</span> <span style="color:#080;font-weight:bold">input</span>, <span style="color:#080;font-weight:bold">float</span> inMin, <span style="color:#080;font-weight:bold">float</span> inMax, <span style="color:#080;font-weight:bold">float</span> outMin,  <span style="color:#080;font-weight:bold">float</span> outMax){
    <span style="color:#080;font-weight:bold">float</span> relativeValue <span style="color:#333">=</span> (<span style="color:#080;font-weight:bold">input</span> <span style="color:#333">-</span> inMin) <span style="color:#333">/</span> (inMax <span style="color:#333">-</span> inMin);
    <span style="color:#080;font-weight:bold">return</span> lerp(outMin, outMax, relativeValue);
}
</code></pre></div><p><img src="/assets/images/posts/040/Remap.gif" alt=""></p>
<p>This now allows us to change which parts are counted as shadowed and which are lit in a quick and dynamic manner.</p>
<h2 id="source">Source</h2>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/040_Halftone_Lighting/HalftoneShading.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/040_Halftone_Lighting/HalftoneShading.shader</a></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#00d;font-weight:bold">40</span>_DitheredLighting<span style="color:#f00;background-color:#faa">&#34;</span> {
	<span style="color:#888">//show values to edit in inspector</span>
	Properties{
		_Color(<span style="color:#f00;background-color:#faa">&#34;</span>Tint<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
		_MainTex(<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
		[HDR] _Emission(<span style="color:#f00;background-color:#faa">&#34;</span>Emission<span style="color:#f00;background-color:#faa">&#34;</span>, color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>)

		_HalftonePattern(<span style="color:#f00;background-color:#faa">&#34;</span>Halftone Pattern<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}

        _RemapInputMin (<span style="color:#f00;background-color:#faa">&#34;</span>Remap <span style="color:#080;font-weight:bold">input</span> min value<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        _RemapInputMax (<span style="color:#f00;background-color:#faa">&#34;</span>Remap <span style="color:#080;font-weight:bold">input</span> max value<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
        _RemapOutputMin (<span style="color:#f00;background-color:#faa">&#34;</span>Remap <span style="color:#080;font-weight:bold">output</span> min value<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>
        _RemapOutputMax (<span style="color:#f00;background-color:#faa">&#34;</span>Remap <span style="color:#080;font-weight:bold">output</span> max value<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
	}
		SubShader{
		<span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
		Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

		CGPROGRAM

		<span style="color:#888">//the shader is a surface shader, meaning that it will be extended by unity in the background to have fancy lighting and other features</span>
		<span style="color:#888">//our surface shader function is called surf and we use our custom lighting model</span>
		<span style="color:#888">//fullforwardshadows makes sure unity adds the shadow passes the shader might need</span>
		<span style="color:#f00;background-color:#faa">#</span>pragma surface surf Halftone fullforwardshadows
		<span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

        <span style="color:#888">//basic properties</span>
		<span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
		fixed4 _Color;
		half3 _Emission;

        <span style="color:#888">//shading properties</span>
		<span style="color:#080;font-weight:bold">sampler2D</span> _HalftonePattern;
		float4 _HalftonePattern_ST;

        <span style="color:#888">///remapping values</span>
        <span style="color:#080;font-weight:bold">float</span> _RemapInputMin;
        <span style="color:#080;font-weight:bold">float</span> _RemapInputMax;
        <span style="color:#080;font-weight:bold">float</span> _RemapOutputMin;
        <span style="color:#080;font-weight:bold">float</span> _RemapOutputMax;

        <span style="color:#888">//struct that holds information that gets transferred from surface to lighting function</span>
		<span style="color:#080;font-weight:bold">struct</span> HalftoneSurfaceOutput {
			fixed3 Albedo;
			float2 ScreenPos;
			half3 Emission;
			<span style="color:#080;font-weight:bold">fixed</span> Alpha;
			fixed3 Normal;
		};

        <span style="color:#888">// This function remaps values from a input to a output range</span>
        <span style="color:#080;font-weight:bold">float</span> map(<span style="color:#080;font-weight:bold">float</span> <span style="color:#080;font-weight:bold">input</span>, <span style="color:#080;font-weight:bold">float</span> inMin, <span style="color:#080;font-weight:bold">float</span> inMax, <span style="color:#080;font-weight:bold">float</span> outMin,  <span style="color:#080;font-weight:bold">float</span> outMax)
        {
            <span style="color:#888">//inverse lerp with input range</span>
            <span style="color:#080;font-weight:bold">float</span> relativeValue <span style="color:#333">=</span> (<span style="color:#080;font-weight:bold">input</span> <span style="color:#333">-</span> inMin) <span style="color:#333">/</span> (inMax <span style="color:#333">-</span> inMin);
            <span style="color:#888">//lerp with output range</span>
            <span style="color:#080;font-weight:bold">return</span> lerp(outMin, outMax, relativeValue);
        }

		<span style="color:#888">//our lighting function. Will be called once per light</span>
		float4 LightingHalftone(HalftoneSurfaceOutput s, float3 lightDir, <span style="color:#080;font-weight:bold">float</span> atten) {
			<span style="color:#888">//how much does the normal point towards the light?</span>
			<span style="color:#080;font-weight:bold">float</span> towardsLight <span style="color:#333">=</span> dot(s.Normal, lightDir);
			<span style="color:#888">//remap the value from -1 to 1 to between 0 and 1</span>
			towardsLight <span style="color:#333">=</span> towardsLight <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span> <span style="color:#333">+</span> <span style="color:#60e;font-weight:bold">0.5</span>;
			<span style="color:#888">//combine shadow and light and clamp the result between 0 and 1</span>
			<span style="color:#080;font-weight:bold">float</span> lightIntensity <span style="color:#333">=</span> saturate(towardsLight <span style="color:#333">*</span> atten).r;

			<span style="color:#888">//get halftone comparison value</span>
            <span style="color:#080;font-weight:bold">float</span> halftoneValue <span style="color:#333">=</span> tex2D(_HalftonePattern, s.ScreenPos).r;

            <span style="color:#888">//make lightness binary between fully lit and fully shadow based on halftone pattern (with a bit of antialiasing between)</span>
            halftoneValue <span style="color:#333">=</span> map(halftoneValue, _RemapInputMin, _RemapInputMax, _RemapOutputMin, _RemapOutputMax);
            <span style="color:#080;font-weight:bold">float</span> halftoneChange <span style="color:#333">=</span> fwidth(halftoneValue) <span style="color:#333">*</span> <span style="color:#60e;font-weight:bold">0.5</span>;
			lightIntensity <span style="color:#333">=</span> smoothstep(halftoneValue <span style="color:#333">-</span> halftoneChange, halftoneValue <span style="color:#333">+</span> halftoneChange, lightIntensity);

			<span style="color:#888">//combine the color</span>
			float4 col;
			<span style="color:#888">//intensity we calculated previously, diffuse color, light falloff and shadowcasting, color of the light</span>
			col.rgb <span style="color:#333">=</span> lightIntensity <span style="color:#333">*</span> s.Albedo <span style="color:#333">*</span> _LightColor0.rgb;
			<span style="color:#888">//in case we want to make the shader transparent in the future - irrelevant right now</span>
			col.a <span style="color:#333">=</span> s.Alpha;

			<span style="color:#080;font-weight:bold">return</span> col;
		}

		<span style="color:#888">//input struct which is automatically filled by unity</span>
		<span style="color:#080;font-weight:bold">struct</span> Input {
			float2 uv_MainTex;
			float4 screenPos;
		};

		<span style="color:#888">//the surface shader function which sets parameters the lighting function then uses</span>
		<span style="color:#080;font-weight:bold">void</span> surf(Input i, <span style="color:#080;font-weight:bold">inout</span> HalftoneSurfaceOutput o) {
			<span style="color:#888">//set surface colors</span>
			fixed4 col <span style="color:#333">=</span> tex2D(_MainTex, i.uv_MainTex);
			col <span style="color:#333">*=</span> _Color;
			o.Albedo <span style="color:#333">=</span> col.rgb;

			o.Emission <span style="color:#333">=</span> _Emission;

            <span style="color:#888">//setup screenspace UVs for lighing function</span>
			<span style="color:#080;font-weight:bold">float</span> aspect <span style="color:#333">=</span> _ScreenParams.x <span style="color:#333">/</span> _ScreenParams.y;
			o.ScreenPos <span style="color:#333">=</span> i.screenPos.xy <span style="color:#333">/</span> i.screenPos.w;
			o.ScreenPos <span style="color:#333">=</span> TRANSFORM_TEX(o.ScreenPos, _HalftonePattern);
			o.ScreenPos.x <span style="color:#333">=</span> o.ScreenPos.x <span style="color:#333">*</span> aspect;
		}
		ENDCG
	}
		FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><p>As always thank you so much for reading and supporting me, your messages of support mean the world to me ðŸ’–.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "disqus_vlgXjcPhg1" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
