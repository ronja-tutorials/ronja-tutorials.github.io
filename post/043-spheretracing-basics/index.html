<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Spheretracing Basics | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance fields which I have explored in the 2d space in previous tutorials is called spheretracing. In this first tutorial we&rsquo;ll just trace the silouette of a sphere, but in future tutorials I&rsquo;ll give examples how to make more complex shapes and do lighting.
As the base of the shader we&rsquo;ll use a basic unlit shader, so you can do this tutorial when you&rsquo;re fairly new to shaders.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="Spheretracing Basics" />
<meta property="og:description" content="Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance fields which I have explored in the 2d space in previous tutorials is called spheretracing. In this first tutorial we&rsquo;ll just trace the silouette of a sphere, but in future tutorials I&rsquo;ll give examples how to make more complex shapes and do lighting.
As the base of the shader we&rsquo;ll use a basic unlit shader, so you can do this tutorial when you&rsquo;re fairly new to shaders." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/043-spheretracing-basics/" />
<meta property="article:published_time" content="2019-06-21T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-06-21T00:00:00+00:00" />
<meta itemprop="name" content="Spheretracing Basics">
<meta itemprop="description" content="Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance fields which I have explored in the 2d space in previous tutorials is called spheretracing. In this first tutorial we&rsquo;ll just trace the silouette of a sphere, but in future tutorials I&rsquo;ll give examples how to make more complex shapes and do lighting.
As the base of the shader we&rsquo;ll use a basic unlit shader, so you can do this tutorial when you&rsquo;re fairly new to shaders.">
<meta itemprop="datePublished" content="2019-06-21T00:00:00+00:00" />
<meta itemprop="dateModified" content="2019-06-21T00:00:00+00:00" />
<meta itemprop="wordCount" content="2032">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spheretracing Basics"/>
<meta name="twitter:description" content="Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance fields which I have explored in the 2d space in previous tutorials is called spheretracing. In this first tutorial we&rsquo;ll just trace the silouette of a sphere, but in future tutorials I&rsquo;ll give examples how to make more complex shapes and do lighting.
As the base of the shader we&rsquo;ll use a basic unlit shader, so you can do this tutorial when you&rsquo;re fairly new to shaders."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      
      
      <h1 class="f1 athelas mt3 mb1">Spheretracing Basics</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-06-21T00:00:00Z">June 21, 2019</time>

      
      
    </header>
    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><p>Raytracing is a huge topic and one that seems scary and unapproachable for many. One specific kind of raytracing we can do with signed distance fields which I have explored in the 2d space in previous tutorials is called spheretracing. In this first tutorial we&rsquo;ll just trace the silouette of a sphere, but in future tutorials I&rsquo;ll give examples how to make more complex shapes and do lighting.</p>
<p>As the base of the shader we&rsquo;ll use a <a href="/basics.html">basic unlit shader</a>, so you can do this tutorial when you&rsquo;re fairly new to shaders. If you do struggle with some of the concepts of signed distance fields though, have a look into <a href="https://www.ronja-tutorials.com/post/034-2d-sdf-basics/">my tutorial about 2d signed distance fields</a>.</p>
<h2 id="the-theory">The theory</h2>
<p>The central concept of raytracing is the ray. To construct a ray we need a origin and a direction. If we only do the raytracing inside of a mesh we can use the surface point of that mesh as the origin of the ray. The direction of the view ray is the vector from the camera to that surface point.</p>
<p>With this data we can take steps through our SDF scene. We&rsquo;ll advance the distance of our distance field in the direction of our ray. We can do that because the definition of a distance field is that the closest surface is as far away as the return value of the distance function. As soon as we are close enough to a surface that we consider it a hit we know that the ray does hit the silouette. If the ray travelled too far or a maximum number of steps was reached that can be interpeted as a fail state and we can assume the ray never hits a scene object.</p>
<h2 id="preparing-the-data">Preparing the data</h2>
<p>As mentioned previously what we need to define a ray for each pixel is the origin and the direction of the ray. We can do the raytracing in any &ldquo;space&rdquo; we want to. If we do it in world space we can move around the object and it moves like a window into the traced world. If we do it in object space the raytraced objects will be moved, scaled and rotated with the object that&rsquo;s moved. For this tutorial I&rsquo;ll do the spheretracing in object space because it&rsquo;s more intuitive and it&rsquo;s a bit harder to do so you might be able to figure out how to do it in worldspace yourself if you want that.</p>
<p>As the origin of the ray we&rsquo;ll use the local coordinates which is the data that&rsquo;s given to the shader via the appdata struct. The object space view direction is a bit trickier - we get it by transforming the camera world position into object space and then subtracting it from the local position. To transform the camera position into local space we have to multiply the world to object matrix with it, but before this multiplication we have to transform it from a float3 into a float4 with a &ldquo;1&rdquo; as the w component. If we don&rsquo;t do that the w component would be filled with a 0 and the movement would be ignored, only rotation and scale would be applied.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//input data</span>
<span style="color:#080;font-weight:bold">struct</span> appdata{
    float4 vertex <span style="color:#333">:</span> POSITION;
};

<span style="color:#888">//data that goes from vertex to fragment shader</span>
<span style="color:#080;font-weight:bold">struct</span> v2f{
    float4 position <span style="color:#333">:</span> SV_POSITION; <span style="color:#888">//position in clip space</span>
    float4 localPosition <span style="color:#333">:</span> TEXCOORD0; <span style="color:#888">//position in local space</span>
    float4 viewDirection <span style="color:#333">:</span> TEXCOORD1; <span style="color:#888">//view direction in local space (not normalized!)</span>
};

v2f vert(appdata v){
    v2f o;
    <span style="color:#888">//position for rendering</span>
    o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
    <span style="color:#888">//save local position for origin</span>
    o.localPosition <span style="color:#333">=</span> v.vertex;
    <span style="color:#888">//get camera position in local space</span>
    float4 objectSpaceCameraPos <span style="color:#333">=</span> mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, <span style="color:#00d;font-weight:bold">1</span>));
    <span style="color:#888">//get local view vector</span>
    o.viewDirection <span style="color:#333">=</span> v.vertex <span style="color:#333">-</span> objectSpaceCameraPos;
    <span style="color:#080;font-weight:bold">return</span> o;
}
</code></pre></div><h2 id="3d-signed-distance-functions">3d signed distance functions</h2>
<p>Signed distance functions work similarly in 3d as they do in 2d. In this tutorial I&rsquo;ll only use a sphere, but if you&rsquo;re curious about other shapes and how to combine them you can use those two sites: <a href="https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm">https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm</a>, <a href="http://mercury.sexy/hg_sdf/">http://mercury.sexy/hg_sdf/</a></p>
<p>The sphere is very similar to the circle in 2d. We first subtract the center of the sphere from the position we want to sample it at, then we calculate the length of the resulting vector and subtract the radius of the sphere to increase it&rsquo;s size. Because this is a very simple example I&rsquo;m going to place the sphere at the origin of the scene which means I don&rsquo;t have to do the subtraction of the sphere center and give it a hardcoded size of <code>0.5</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> scene(float3 pos){
    <span style="color:#080;font-weight:bold">return</span> length(pos) <span style="color:#333">-</span> <span style="color:#60e;font-weight:bold">0.5</span>;
}
</code></pre></div><h2 id="fixed-step-ray-marching">Fixed step ray marching</h2>
<p>Before we take full advantage of our signed distance field, I want to show a more simplistic way of raytracing which just going fixed steps forwards through the space until it hits something. The advantage of this is that we can use it with any function that tells us wether a given point is inside or outside of a shape.</p>
<p>To do the raytracing we first have to set up three variables. The point where the ray starts, the direction of the ray and the progress we&rsquo;ve already made on our ray. The starting point is the local position in our case which we passed via the v2f struct. The direction was also already calculated in the vertex shader, but we have to normalize it so it&rsquo;s easier to work with before using it. We normalize this vector in the fragment and not the vertex shader because it would loose it wouldn&rsquo;t have a length of 1 anymore after being interpolated between vertices. This is especially visible when the camera is close to low poly objects. Third we define the progress variable which starts at <code>0</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//ray information</span>
float3 pos <span style="color:#333">=</span> i.localPosition;
float3 dir <span style="color:#333">=</span> normalize(i.viewDirection.xyz);
<span style="color:#080;font-weight:bold">float</span> progress <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;
</code></pre></div><p>For the tracing itself we also have to decide on two more factors, how many steps we iterate through at maximum and how big the steps we will do will be. Because those are fixed, I&rsquo;m going to use define statements, but if you&rsquo;re more comfortable with variables or just writing in the numbers that&rsquo;s also fine. Because we know the size and complexity of our shape fairly well we can make a pretty good guess what would be appropriate values. I decided to define 10 steps with a distance of 0.1 each. Note that you can use the define statements anywhere, but I decided that they&rsquo;re best with the global variables that can also be manipulated by properties.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//how big steps to take when usign fixed steps</span>
<span style="color:#579">#define STEP_SIZE 0.1</span>
<span style="color:#888">//maximum amount of steps</span>
<span style="color:#579">#define MAX_STEPS 10</span>
</code></pre></div><p>And with all of this set up we can then finally write the loop that does the actual work. I used a for loop with a iterator that counts up and aborts when the iterator reaches the maximum amount of steps we defined. Inside the loop we first calculate the current point on the ray we&rsquo;re on. We get this by solving the line equation of <code>point = origin + direction * progress</code>. Putting this result into the scene function then gives us the distance to the closest shape. Right now we&rsquo;re only interrested in whether our current location is inside the shape or not so we check whether the distance smaller than <code>0</code> which would mean that it&rsquo;s inside of a shape. If that check is successful we directly return the color we set via our property. If it isn&rsquo;t inside the shape we increase our progress by the step size and the code goes into the next iteration of the loop. If the loop terminates without ever hitting a shape we assume it missed completely and return <code>0</code> for a completely black pixel.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//ray information</span>
    float3 pos <span style="color:#333">=</span> i.localPosition;
    float3 dir <span style="color:#333">=</span> normalize(i.viewDirection.xyz);
    <span style="color:#080;font-weight:bold">float</span> progress <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;

    <span style="color:#888">//tracing loop</span>
    <span style="color:#080;font-weight:bold">for</span> (uint iter <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>; iter <span style="color:#333">&lt;</span> MAX_STEPS; iter<span style="color:#333">++</span>) {
        <span style="color:#888">//get current location on ray</span>
        float3 samplePoint <span style="color:#333">=</span> pos <span style="color:#333">+</span> dir <span style="color:#333">*</span> progress;
        <span style="color:#888">//get distance to closest shape</span>
        <span style="color:#080;font-weight:bold">float</span> distance <span style="color:#333">=</span> scene(samplePoint);
        <span style="color:#888">//return color if inside shape</span>
        <span style="color:#080;font-weight:bold">if</span>(distance <span style="color:#333">&lt;</span> <span style="color:#40e;font-weight:bold">0</span>){
            <span style="color:#080;font-weight:bold">return</span> _Color;
        }
        <span style="color:#888">//go forwards</span>
        progress <span style="color:#333">=</span> progress <span style="color:#333">+</span> STEP_SIZE;
    }

    <span style="color:#888">//return black pixel if no shape was hit</span>
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#40e;font-weight:bold">0</span>;
}
</code></pre></div><p><img src="/assets/images/posts/043/TracedSphere.png" alt=""></p>
<p>The main disadvantage of fixed step raymarching is that it&rsquo;s often hard to choose a step size. With a step size that&rsquo;s too short you do a lot of samples in areas where theres no shape anywhere close and loose a lot of calculation time doing that. If you choose a step size that&rsquo;s too big it&rsquo;s possible to jump through walls and shapes that should be visible are simply missing because they are between two samples.</p>
<h2 id="spheretracing">Spheretracing</h2>
<p>With signed distance fields we have more information than just is it inside a shape or not. We can also determine how close the closest shape is. If we go the distance to the closest shape forwards we cannot skip any shapes. So instead of using a fixed step spheretracing walks forward the current distance of the SDF.</p>
<p>The changes we make to our existing code are just that we completely get rid of the step size and instead add the distance we have anyways to the progress. Because we only go the distance to the closest shape further it&rsquo;s impossible now to follow the ray inside of the surface. Instead we define a small thickness and accept it as a hit if the distance is smaller than that.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//maximum amount of steps</span>
<span style="color:#579">#define MAX_STEPS 10</span>
<span style="color:#888">//furthest distance that&#39;s accepted as inside surface</span>
<span style="color:#579">#define THICKNESS 0.01</span>
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//ray information</span>
    float3 pos <span style="color:#333">=</span> i.localPosition;
    float3 dir <span style="color:#333">=</span> normalize(i.viewDirection.xyz);
    <span style="color:#080;font-weight:bold">float</span> progress <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;

    <span style="color:#888">//tracing loop</span>
    <span style="color:#080;font-weight:bold">for</span> (uint iter <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>; iter <span style="color:#333">&lt;</span> MAX_STEPS; iter<span style="color:#333">++</span>) {
        <span style="color:#888">//get current location on ray</span>
        float3 samplePoint <span style="color:#333">=</span> pos <span style="color:#333">+</span> dir <span style="color:#333">*</span> progress;
        <span style="color:#888">//get distance to closest shape</span>
        <span style="color:#080;font-weight:bold">float</span> distance <span style="color:#333">=</span> scene(samplePoint);
        <span style="color:#888">//return color if inside shape</span>
        <span style="color:#080;font-weight:bold">if</span>(distance <span style="color:#333">&lt;</span> THICKNESS){
            <span style="color:#080;font-weight:bold">return</span> _Color;
        }
        <span style="color:#888">//go forwards</span>
        progress <span style="color:#333">=</span> progress <span style="color:#333">+</span> distance;
    }

    <span style="color:#888">//return black pixel if no shape was hit</span>
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#40e;font-weight:bold">0</span>;
}
</code></pre></div><p>Your result shouldn&rsquo;t look too different from the previous iteration, but I promise you it works way better with huge spaces as well as more delicate shapes.</p>
<p>One minor tweak I&rsquo;ll also mention in this tutorial is how to make the object have the silouette of the traced shape instead of the mesh. For that you can discard the pixels with missed rays before returning black by calling the clip function with a negative argument.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//discard pixel if no shape was hit</span>
clip(<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>);
<span style="color:#080;font-weight:bold">return</span> <span style="color:#40e;font-weight:bold">0</span>;
</code></pre></div><p><img src="/assets/images/posts/043/ClippedSphere.png" alt=""></p>
<h2 id="source">Source</h2>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/043_SphereTracingBasics/SphereTracingBasics.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/043_SphereTracingBasics/SphereTracingBasics.shader</a></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">042</span>_SphereTracingBasics<span style="color:#f00;background-color:#faa">&#34;</span>{
    <span style="color:#888">//show values to edit in inspector</span>
    Properties{
        _Color (<span style="color:#f00;background-color:#faa">&#34;</span>Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)
    }

    SubShader{
        <span style="color:#888">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry</span>
        <span style="color:#888">//also disable batching so local coordinates are always valid</span>
        Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>DisableBatching<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>True<span style="color:#f00;background-color:#faa">&#34;</span>}

        Pass{
            ZWrite Off

            CGPROGRAM
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            <span style="color:#888">//silouette color</span>
            fixed4 _Color;

            <span style="color:#888">//maximum amount of steps</span>
            <span style="color:#f00;background-color:#faa">#</span>define MAX_STEPS <span style="color:#00d;font-weight:bold">10</span>
            <span style="color:#888">//furthest distance that&#39;s accepted as inside surface</span>
            <span style="color:#f00;background-color:#faa">#</span>define THICKNESS <span style="color:#60e;font-weight:bold">0.01</span>

            <span style="color:#888">//input data</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
            };

            <span style="color:#888">//data that goes from vertex to fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION; <span style="color:#888">//position in clip space</span>
                float4 localPosition <span style="color:#333">:</span> TEXCOORD0; <span style="color:#888">//position in local space</span>
                float4 viewDirection <span style="color:#333">:</span> TEXCOORD1; <span style="color:#888">//view direction in local space (not normalized!)</span>
            };

            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//position for rendering</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
                <span style="color:#888">//save local position for origin</span>
                o.localPosition <span style="color:#333">=</span> v.vertex;
                <span style="color:#888">//get camera position in local space</span>
                float4 objectSpaceCameraPos <span style="color:#333">=</span> mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, <span style="color:#00d;font-weight:bold">1</span>));
                <span style="color:#888">//get local view vector</span>
                o.viewDirection <span style="color:#333">=</span> v.vertex <span style="color:#333">-</span> objectSpaceCameraPos;
                <span style="color:#080;font-weight:bold">return</span> o;
            }


            <span style="color:#080;font-weight:bold">float</span> scene(float3 pos){
                <span style="color:#080;font-weight:bold">return</span> length(pos) <span style="color:#333">-</span> <span style="color:#60e;font-weight:bold">0.5</span>;
            }

            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                <span style="color:#888">//ray information</span>
                float3 pos <span style="color:#333">=</span> i.localPosition;
                float3 dir <span style="color:#333">=</span> normalize(i.viewDirection.xyz);
                <span style="color:#080;font-weight:bold">float</span> progress <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;

                <span style="color:#888">//tracing loop</span>
                <span style="color:#080;font-weight:bold">for</span> (uint iter <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>; iter <span style="color:#333">&lt;</span> MAX_STEPS; iter<span style="color:#333">++</span>) {
                    <span style="color:#888">//get current location on ray</span>
                    float3 samplePoint <span style="color:#333">=</span> pos <span style="color:#333">+</span> dir <span style="color:#333">*</span> progress;
                    <span style="color:#888">//get distance to closest shape</span>
                    <span style="color:#080;font-weight:bold">float</span> distance <span style="color:#333">=</span> scene(samplePoint);
                    <span style="color:#888">//return color if inside shape</span>
                    <span style="color:#080;font-weight:bold">if</span>(distance <span style="color:#333">&lt;</span> THICKNESS){
                        <span style="color:#080;font-weight:bold">return</span> _Color;
                    }
                    <span style="color:#888">//go forwards</span>
                    progress <span style="color:#333">=</span> progress <span style="color:#333">+</span> distance;
                }
                <span style="color:#888">//discard pixel if no shape was hit</span>
                clip(<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>);
                <span style="color:#080;font-weight:bold">return</span> <span style="color:#40e;font-weight:bold">0</span>;
            }

            ENDCG
        }
    }
}
</code></pre></div><ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ronja-tutorials" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
