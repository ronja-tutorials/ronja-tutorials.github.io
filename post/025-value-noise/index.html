<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Value Noise | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary In the last tutorial we learned how to generate random numbers in a shader. In this one we&rsquo;ll go into interpolating between random numbers to generate noise that&rsquo;s smoother and gradually changes. Because we need random values to interpolate between for value noise, you should know how to generate random values in shaders before doing this tutorial. Value noise is similar to perlin noise, but different because we always interpolate between the center of the cells, perlin noise will be explained in a later tutorial.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    

    
      

    

    
    
    <meta property="og:title" content="Value Noise" />
<meta property="og:description" content="Summary In the last tutorial we learned how to generate random numbers in a shader. In this one we&rsquo;ll go into interpolating between random numbers to generate noise that&rsquo;s smoother and gradually changes. Because we need random values to interpolate between for value noise, you should know how to generate random values in shaders before doing this tutorial. Value noise is similar to perlin noise, but different because we always interpolate between the center of the cells, perlin noise will be explained in a later tutorial." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/025-value-noise/" />
<meta property="article:published_time" content="2018-09-08T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-09-08T00:00:00+00:00" />
<meta itemprop="name" content="Value Noise">
<meta itemprop="description" content="Summary In the last tutorial we learned how to generate random numbers in a shader. In this one we&rsquo;ll go into interpolating between random numbers to generate noise that&rsquo;s smoother and gradually changes. Because we need random values to interpolate between for value noise, you should know how to generate random values in shaders before doing this tutorial. Value noise is similar to perlin noise, but different because we always interpolate between the center of the cells, perlin noise will be explained in a later tutorial.">
<meta itemprop="datePublished" content="2018-09-08T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-09-08T00:00:00+00:00" />
<meta itemprop="wordCount" content="2447">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Value Noise"/>
<meta name="twitter:description" content="Summary In the last tutorial we learned how to generate random numbers in a shader. In this one we&rsquo;ll go into interpolating between random numbers to generate noise that&rsquo;s smoother and gradually changes. Because we need random values to interpolate between for value noise, you should know how to generate random values in shaders before doing this tutorial. Value noise is similar to perlin noise, but different because we always interpolate between the center of the cells, perlin noise will be explained in a later tutorial."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      
      
      <h1 class="f1 athelas mt3 mb1">Value Noise</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-09-08T00:00:00Z">September 8, 2018</time>

      
      
    </header>
    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><h2 id="summary">Summary</h2>
<p>In the last tutorial we learned how to generate random numbers in a shader. In this one we&rsquo;ll go into interpolating between random numbers to generate noise that&rsquo;s smoother and gradually changes. Because we need random values to interpolate between for value noise, you should know how to <a href="https://www.ronja-tutorials.com/post/024-white-noise/">generate random values in shaders</a> before doing this tutorial. Value noise is similar to perlin noise, but different because we always interpolate between the center of the cells, perlin noise will be explained in a later tutorial.</p>
<p><img src="/assets/images/posts/025/Result.gif" alt=""></p>
<h2 id="show-a-line">Show a Line</h2>
<p>First we will implement an easy way for us to visualize 1d noise. To do that we start with the noise with cells of the <a href="https://www.ronja-tutorials.com/post/024-white-noise/">previous tutorial</a> and expand from there. We then change the cell size to a float value because we&rsquo;ll operate in 1d for now. Then we&rsquo;ll also make the value we feed to our noise function scalar by only using the x component of the position and use the 1d to 1d random function.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Properties {
    _CellSize (<span style="color:#f00;background-color:#faa">&#34;</span>Cell Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> _CellSize;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    <span style="color:#080;font-weight:bold">float</span> value <span style="color:#333">=</span> floor(i.worldPos.x <span style="color:#333">/</span> _CellSize);
    o.Albedo <span style="color:#333">=</span> rand1dTo1d(value);
}
</code></pre></div><p><img src="/assets/images/posts/025/1dValues.png" alt=""></p>
<p>With those changes we can now see the scalar values we generate as greyscale values. But to see how the values change even better, we&rsquo;ll change that to a line. For that we first calculate the distance in the y direction of each pixel to the random value of it&rsquo;s x position. We could also try to calculate the closest point on the line in general, but that woule be way more complex and we don&rsquo;t need it for our cause. We get the distance from the line by simply subtracting our y position from the noise value and then taking the absolute value of that.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    <span style="color:#080;font-weight:bold">float</span> value <span style="color:#333">=</span> floor(i.worldPos.x <span style="color:#333">/</span> _CellSize);
    <span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> rand1dTo1d(value);
    <span style="color:#080;font-weight:bold">float</span> dist <span style="color:#333">=</span> abs(noise <span style="color:#333">-</span> i.worldPos.y);
    o.Albedo <span style="color:#333">=</span> dist;
}
</code></pre></div><p><img src="/assets/images/posts/025/CellDistance.png" alt=""></p>
<p>Then we can use this distance to cut off the value so that we get a thin line. A nice way to generate a 1px thick line is to calculate how much the value we&rsquo;re using changes in the neighboring pixels. The function to get that value is called <code>fwidth</code>, it automatically compares the neighboring pixels and returns approximately how much the value changes (also known as partial derivative magnitude), the reason that&rsquo;s possible is that in the shader the fragments are handled in tiny 2x2 units so the fragment shaders running in paralell can compare their values. In our case we care about how much the y part of our position changes in the neighboring pixels, so we just put that value in the function. Then we do a smoothstep, the first value is the value that&rsquo;s going to represent the 0(black) output value, so in our case the very center of the line, <code>0</code>, then the second value will represent at which value the function will return 1 (white) and then the third value is the value we compare the first two to. So when the third value is 0, the function will return 0 and for values of the pixel height or higher it will return white, giving us a nice thin line at all resultions.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    <span style="color:#080;font-weight:bold">float</span> value <span style="color:#333">=</span> floor(i.worldPos.x <span style="color:#333">/</span> _CellSize);
    <span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> rand1dTo1d(value);
    <span style="color:#080;font-weight:bold">float</span> dist <span style="color:#333">=</span> abs(noise <span style="color:#333">-</span> i.worldPos.y);
    <span style="color:#080;font-weight:bold">float</span> pixelHeight <span style="color:#333">=</span> fwidth(i.worldPos.y);
    <span style="color:#080;font-weight:bold">float</span> lineIntensity <span style="color:#333">=</span> smoothstep(<span style="color:#40e;font-weight:bold">0</span>, pixelHeight, dist);
    o.Albedo <span style="color:#333">=</span> lineIntensity;
}
</code></pre></div><p><img src="/assets/images/posts/025/CellLine.png" alt=""></p>
<h2 id="interpolate-cells-in-one-dimension">Interpolate Cells in one Dimension</h2>
<p>To interpolate between the cells, we first have to sample the noise twice per fragment. Once in the cell we come from, and once in the cell we&rsquo;re going to. We do this by only calculating the value with the cell size factored in at the start without flooring it. We then floor it for the &ldquo;previous cell&rdquo; value and we ceil it to get the &ldquo;next cell&rdquo; position. For the interpolation between the values we can simply use the fractional part of the value to interpolate between the cell values. 0 means we completely use the value of the previous cell, 1 means we&rsquo;ll use the value of the next cell and the values between are interpolated.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> value <span style="color:#333">=</span> i.worldPos.x <span style="color:#333">/</span> _CellSize;
<span style="color:#080;font-weight:bold">float</span> previousCellNoise <span style="color:#333">=</span> rand1dTo1d(floor(value));
<span style="color:#080;font-weight:bold">float</span> nextCellNoise <span style="color:#333">=</span> rand1dTo1d(ceil(value));
<span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> lerp(previousCellNoise, nextCellNoise, frac(value));
</code></pre></div><p><img src="/assets/images/posts/025/LinearLine.png" alt=""></p>
<p>This already gives us a connected line, but I&rsquo;d like to make it softer. For this we&rsquo;ll write a simple easing function, I&rsquo;ll get more into easing functions in a later tutorial, but a simple one will be enough for now. First we do the easing in part of the function. for that we&rsquo;ll simply use a quadratic function, that way the edge cases of our interpolation where our interpolation value has the value 0/1 are still the same value, but values closer to 0 are bumped down more that values closer to 1. Once we have that function, we simply use it on our interpolation variable once before we do the interpolation.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">inline</span> <span style="color:#080;font-weight:bold">float</span> easeIn(<span style="color:#080;font-weight:bold">float</span> interpolator){
    <span style="color:#080;font-weight:bold">return</span> interpolator <span style="color:#333">*</span> interpolator;
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> interpolator <span style="color:#333">=</span> frac(value);
interpolator <span style="color:#333">=</span> easeIn(interpolator);
<span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> lerp(previousCellNoise, nextCellNoise, interpolator);
</code></pre></div><p><img src="/assets/images/posts/025/EaseIn.png" alt=""></p>
<p>With this we can already see how the function is more horizontal just right of the cell positions. The next step is to get a function that can do the same on the left of the cell positions. We&rsquo;ll call this function EaseOut. For the ease out function we can simply reuse the easeIn function, but instead of pulling low values towards 0, we want to drag values close to 1 closer to 1. To archieve this behaviour, we flip the value, so the values close to 1 are close to 0 and the inverse, then we apply the easeIn function and flip the values again afterwards. We flip the values by simply subtracting them from 1.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> easeOut(<span style="color:#080;font-weight:bold">float</span> interpolator){
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> easeIn(<span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> interpolator);
}
</code></pre></div><p>The last step to get smooth interpolation is to combine the easing in and easing out. For that we calculate both the ease in and ease out value, then we use the ease in value as the start of the interpolation, near 0, and the ease out value as the end of the interpolation, near 1. the interpolation between the two easing values is a normal linear interpolation like usual.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> easeInOut(<span style="color:#080;font-weight:bold">float</span> interpolator){
    <span style="color:#080;font-weight:bold">float</span> easeInValue <span style="color:#333">=</span> easeIn(interpolator);
    <span style="color:#080;font-weight:bold">float</span> easeOutValue <span style="color:#333">=</span> easeOut(interpolator);
    <span style="color:#080;font-weight:bold">return</span> lerp(easeInValue, easeOutValue, interpolator);
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> interpolator <span style="color:#333">=</span> frac(value);
interpolator <span style="color:#333">=</span> easeInOut(interpolator);
<span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> lerp(previousCellNoise, nextCellNoise, interpolator);
</code></pre></div><p><img src="/assets/images/posts/025/SmoothLine.png" alt=""></p>
<p>And with this we can now smoothly interpolate between the values in 1d.</p>
<h2 id="interpolate-cells-in-two-dimensions">Interpolate Cells in two Dimensions</h2>
<p>To interpolate two dimensions we choose the 4 closest cells based on the x and y position, then interpolate the ones next to each other on the x axis based on the x fraction and then interpolate that based on the y fraction.</p>
<p><img src="/assets/images/posts/025/2dInterpolationRules.png" alt=""></p>
<p>Because this is growing into quite a bit of code, we&rsquo;ll put into it&rsquo;s own method. To get values to interpolate between in 2d, we&rsquo;ll use a <code>rand2dTo[n]d</code> function. After we generate all 4 cells we need, we generate the interpolation values in the x and y direction including smoothing. Then we generate the interpolated values between the upper and lower cells and finally generate the final value by interpolating between them.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> ValueNoise2d(float2 value){
    <span style="color:#080;font-weight:bold">float</span> upperLeftCell <span style="color:#333">=</span> rand2dTo1d(float2(floor(value.x), ceil(value.y)));
    <span style="color:#080;font-weight:bold">float</span> upperRightCell <span style="color:#333">=</span> rand2dTo1d(float2(ceil(value.x), ceil(value.y)));
    <span style="color:#080;font-weight:bold">float</span> lowerLeftCell <span style="color:#333">=</span> rand2dTo1d(float2(floor(value.x), floor(value.y)));
    <span style="color:#080;font-weight:bold">float</span> lowerRightCell <span style="color:#333">=</span> rand2dTo1d(float2(ceil(value.x), floor(value.y)));

    <span style="color:#080;font-weight:bold">float</span> interpolatorX <span style="color:#333">=</span> easeInOut(frac(value.x));
    <span style="color:#080;font-weight:bold">float</span> interpolatorY <span style="color:#333">=</span> easeInOut(frac(value.y));

    <span style="color:#080;font-weight:bold">float</span> upperCells <span style="color:#333">=</span> lerp(upperLeftCell, upperRightCell, interpolatorX);
    <span style="color:#080;font-weight:bold">float</span> lowerCells <span style="color:#333">=</span> lerp(lowerLeftCell, lowerRightCell, interpolatorX);

    <span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> lerp(lowerCells, upperCells, interpolatorY);
    <span style="color:#080;font-weight:bold">return</span> noise;
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    float2 value <span style="color:#333">=</span> i.worldPos.xy <span style="color:#333">/</span> _CellSize;
    <span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> ValueNoise2d(value);

    o.Albedo <span style="color:#333">=</span> noise;
}
</code></pre></div><p><img src="/assets/images/posts/025/Grey2dNoise.png" alt=""></p>
<h2 id="interpolate-cells-in-three-dimensions-and-loops">Interpolate Cells in three Dimensions and Loops</h2>
<p>Interpolating in 3 directions works similarly now, first we read the 8 closest cells, then we interpolate between the pairs that are next to each other on the x axis, then we interpolate between those sets along the y axes so we get 2 values we can then interpolate along the z axis yielding us a single value we can then use to do cool effects with.</p>
<p>But doing this the same way we did the 2d noise results in a lot of code that&rsquo;s pretty hard to understand and keep in your mind. So to avoid that we&rsquo;ll use loops. Each loop will only run for 2 iterations (to interpolate between 2 cells at a time). The innermost loop will just read two values which are next to each other in the x axis and save both of them in a short array. After the loop has terminated we can then interpolate between the two values. We add a <code>[unroll]</code> attribute before each for loop to make sure the compiler won&rsquo;t actually execute the code as a loop on the GPU, which can be pretty slow, but instead copies the code of each iteration behind each other.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> interpolatorX <span style="color:#333">=</span> easeInOut(frac(value.x));

<span style="color:#080;font-weight:bold">int</span> y <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>, z <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;

<span style="color:#080;font-weight:bold">float</span> cellNoiseX[<span style="color:#00d;font-weight:bold">2</span>];
[unroll]
<span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> x<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;x<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;x<span style="color:#333">++</span>){
    float3 cell <span style="color:#333">=</span> floor(value) <span style="color:#333">+</span> float3(x, y, z);
    cellNoiseX[x] <span style="color:#333">=</span> rand3dTo1d(cell);
}
<span style="color:#080;font-weight:bold">float</span> interpolatedX <span style="color:#333">=</span> lerp(cellNoiseX[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseX[<span style="color:#00d;font-weight:bold">1</span>], interpolatorX);
</code></pre></div><p>We then wrap a new loop outside of this loop, it will execute the loop which is reading the x neighbors twice and save their results in a new array. After that outer loop is done we can interpolate between the values it wrote into the array to get noise interpolated in 2 dimensions. this is similar to what we did for 2d noise.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> interpolatorX <span style="color:#333">=</span> easeInOut(frac(value.x));
<span style="color:#080;font-weight:bold">float</span> interpolatorY <span style="color:#333">=</span> easeInOut(frac(value.y));

<span style="color:#080;font-weight:bold">int</span> z <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;

<span style="color:#080;font-weight:bold">float</span> cellNoiseY[<span style="color:#00d;font-weight:bold">2</span>];
[unroll]
<span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> y<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;y<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;y<span style="color:#333">++</span>){
    <span style="color:#080;font-weight:bold">float</span> cellNoiseX[<span style="color:#00d;font-weight:bold">2</span>];
    [unroll]
    <span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> x<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;x<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;x<span style="color:#333">++</span>){
        float3 cell <span style="color:#333">=</span> floor(value) <span style="color:#333">+</span> float3(x, y, z);
        cellNoiseX[x] <span style="color:#333">=</span> rand3dTo1d(cell);
    }
    cellNoiseY[y] <span style="color:#333">=</span> lerp(cellNoiseX[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseX[<span style="color:#00d;font-weight:bold">1</span>], interpolatorX);
}
<span style="color:#080;font-weight:bold">float</span> interpolatedXY <span style="color:#333">=</span> lerp(cellNoiseY[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseY[<span style="color:#00d;font-weight:bold">1</span>], interpolatorY);
</code></pre></div><p>And finally we&rsquo;ll add a final loop around the existing ones, in this one we&rsquo;ll execute the loop reading a pair in the y direction twice (which in turn will execute the loop reading a pair in the x direction twice, executing the innermost code 8 times, once for each cell). Just like the inner loops it will also write the result into a tiny array so that after it&rsquo;s done, we can interpolate in the z direction and get our final value.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> ValueNoise3d(float3 value){
    <span style="color:#080;font-weight:bold">float</span> interpolatorX <span style="color:#333">=</span> easeInOut(frac(value.x));
    <span style="color:#080;font-weight:bold">float</span> interpolatorY <span style="color:#333">=</span> easeInOut(frac(value.y));
    <span style="color:#080;font-weight:bold">float</span> interpolatorZ <span style="color:#333">=</span> easeInOut(frac(value.z));

    <span style="color:#080;font-weight:bold">float</span> cellNoiseZ[<span style="color:#00d;font-weight:bold">2</span>];
    [unroll]
    <span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> z<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;z<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;z<span style="color:#333">++</span>){
        <span style="color:#080;font-weight:bold">float</span> cellNoiseY[<span style="color:#00d;font-weight:bold">2</span>];
        [unroll]
        <span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> y<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;y<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;y<span style="color:#333">++</span>){
            <span style="color:#080;font-weight:bold">float</span> cellNoiseX[<span style="color:#00d;font-weight:bold">2</span>];
            [unroll]
            <span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> x<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;x<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;x<span style="color:#333">++</span>){
                float3 cell <span style="color:#333">=</span> floor(value) <span style="color:#333">+</span> float3(x, y, z);
                cellNoiseX[x] <span style="color:#333">=</span> rand3dTo1d(cell);
            }
            cellNoiseY[y] <span style="color:#333">=</span> lerp(cellNoiseX[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseX[<span style="color:#00d;font-weight:bold">1</span>], interpolatorX);
        }
        cellNoiseZ[z] <span style="color:#333">=</span> lerp(cellNoiseY[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseY[<span style="color:#00d;font-weight:bold">1</span>], interpolatorY);
    }
    <span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> lerp(cellNoiseZ[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseZ[<span style="color:#00d;font-weight:bold">1</span>], interpolatorZ);
    <span style="color:#080;font-weight:bold">return</span> noise;
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    float3 value <span style="color:#333">=</span> i.worldPos.xyz <span style="color:#333">/</span> _CellSize;
    <span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> ValueNoise3d(value);

    o.Albedo <span style="color:#333">=</span> noise;
}
</code></pre></div><p><img src="/assets/images/posts/025/Grey3dNoise.png" alt=""></p>
<h2 id="3d-output-values">3d Output Values</h2>
<p>Once we have the function it&rsquo;s pretty easy to change it so it doesn&rsquo;t just return greyscale values, but colorful values instead. We simply have to use the rand3dTo3d function to get the appropriate colorful values. Then we also have to change the datatype of all of the arrays, return value and all other values where we save the noise to the datatype we want to return, so float3 in our case.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 ValueNoise3d(float3 value){
    <span style="color:#080;font-weight:bold">float</span> interpolatorX <span style="color:#333">=</span> easeInOut(frac(value.x));
    <span style="color:#080;font-weight:bold">float</span> interpolatorY <span style="color:#333">=</span> easeInOut(frac(value.y));
    <span style="color:#080;font-weight:bold">float</span> interpolatorZ <span style="color:#333">=</span> easeInOut(frac(value.z));

    float3 cellNoiseZ[<span style="color:#00d;font-weight:bold">2</span>];
    [unroll]
    <span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> z<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;z<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;z<span style="color:#333">++</span>){
        float3 cellNoiseY[<span style="color:#00d;font-weight:bold">2</span>];
        [unroll]
        <span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> y<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;y<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;y<span style="color:#333">++</span>){
            float3 cellNoiseX[<span style="color:#00d;font-weight:bold">2</span>];
            [unroll]
            <span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> x<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;x<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;x<span style="color:#333">++</span>){
                float3 cell <span style="color:#333">=</span> floor(value) <span style="color:#333">+</span> float3(x, y, z);
                cellNoiseX[x] <span style="color:#333">=</span> rand3dTo3d(cell);
            }
            cellNoiseY[y] <span style="color:#333">=</span> lerp(cellNoiseX[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseX[<span style="color:#00d;font-weight:bold">1</span>], interpolatorX);
        }
        cellNoiseZ[z] <span style="color:#333">=</span> lerp(cellNoiseY[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseY[<span style="color:#00d;font-weight:bold">1</span>], interpolatorY);
    }
    float3 noise <span style="color:#333">=</span> lerp(cellNoiseZ[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseZ[<span style="color:#00d;font-weight:bold">1</span>], interpolatorZ);
    <span style="color:#080;font-weight:bold">return</span> noise;
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
    float3 value <span style="color:#333">=</span> i.worldPos.xyz <span style="color:#333">/</span> _CellSize;
    float3 noise <span style="color:#333">=</span> ValueNoise3d(value);

    o.Albedo <span style="color:#333">=</span> noise;
}
</code></pre></div><p><img src="/assets/images/posts/025/Colorful3dNoise.png" alt=""></p>
<h2 id="source">Source</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">025</span>_value_noise<span style="color:#333">/</span><span style="color:#00d;font-weight:bold">1</span>d<span style="color:#f00;background-color:#faa">&#34;</span> {
	Properties {
		_CellSize (<span style="color:#f00;background-color:#faa">&#34;</span>Cell Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
	}
	SubShader {
		Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

		CGPROGRAM

		<span style="color:#f00;background-color:#faa">#</span>pragma surface surf Standard fullforwardshadows
		<span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

		<span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>Random.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

		<span style="color:#080;font-weight:bold">float</span> _CellSize;

		<span style="color:#080;font-weight:bold">struct</span> Input {
			float3 worldPos;
		};

		<span style="color:#080;font-weight:bold">float</span> easeIn(<span style="color:#080;font-weight:bold">float</span> interpolator){
			<span style="color:#080;font-weight:bold">return</span> interpolator <span style="color:#333">*</span> interpolator;
		}

		<span style="color:#080;font-weight:bold">float</span> easeOut(<span style="color:#080;font-weight:bold">float</span> interpolator){
			<span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> easeIn(<span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> interpolator);
		}

		<span style="color:#080;font-weight:bold">float</span> easeInOut(<span style="color:#080;font-weight:bold">float</span> interpolator){
			<span style="color:#080;font-weight:bold">float</span> easeInValue <span style="color:#333">=</span> easeIn(interpolator);
			<span style="color:#080;font-weight:bold">float</span> easeOutValue <span style="color:#333">=</span> easeOut(interpolator);
			<span style="color:#080;font-weight:bold">return</span> lerp(easeInValue, easeOutValue, interpolator);
		}

		<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
			<span style="color:#080;font-weight:bold">float</span> value <span style="color:#333">=</span> i.worldPos.x <span style="color:#333">/</span> _CellSize;
			<span style="color:#080;font-weight:bold">float</span> previousCellNoise <span style="color:#333">=</span> rand1dTo1d(floor(value));
			<span style="color:#080;font-weight:bold">float</span> nextCellNoise <span style="color:#333">=</span> rand1dTo1d(ceil(value));
			<span style="color:#080;font-weight:bold">float</span> interpolator <span style="color:#333">=</span> frac(value);
			interpolator <span style="color:#333">=</span> easeInOut(interpolator);
			<span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> lerp(previousCellNoise, nextCellNoise, interpolator);

			<span style="color:#080;font-weight:bold">float</span> dist <span style="color:#333">=</span> abs(noise <span style="color:#333">-</span> i.worldPos.y);
			<span style="color:#080;font-weight:bold">float</span> pixelHeight <span style="color:#333">=</span> fwidth(i.worldPos.y);
			<span style="color:#080;font-weight:bold">float</span> lineIntensity <span style="color:#333">=</span> smoothstep(<span style="color:#40e;font-weight:bold">0</span>, pixelHeight, dist);
			o.Albedo <span style="color:#333">=</span> lineIntensity;
		}
		ENDCG
	}
	FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">025</span>_value_noise<span style="color:#333">/</span><span style="color:#00d;font-weight:bold">2</span>d<span style="color:#f00;background-color:#faa">&#34;</span> {
	Properties {
		_CellSize (<span style="color:#f00;background-color:#faa">&#34;</span>Cell Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
	}
	SubShader {
		Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

		CGPROGRAM

		<span style="color:#f00;background-color:#faa">#</span>pragma surface surf Standard fullforwardshadows
		<span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

		<span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>Random.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

		<span style="color:#080;font-weight:bold">float</span> _CellSize;

		<span style="color:#080;font-weight:bold">struct</span> Input {
			float3 worldPos;
		};

		<span style="color:#080;font-weight:bold">float</span> easeIn(<span style="color:#080;font-weight:bold">float</span> interpolator){
			<span style="color:#080;font-weight:bold">return</span> interpolator <span style="color:#333">*</span> interpolator;
		}

		<span style="color:#080;font-weight:bold">float</span> easeOut(<span style="color:#080;font-weight:bold">float</span> interpolator){
			<span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> easeIn(<span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> interpolator);
		}

		<span style="color:#080;font-weight:bold">float</span> easeInOut(<span style="color:#080;font-weight:bold">float</span> interpolator){
			<span style="color:#080;font-weight:bold">float</span> easeInValue <span style="color:#333">=</span> easeIn(interpolator);
			<span style="color:#080;font-weight:bold">float</span> easeOutValue <span style="color:#333">=</span> easeOut(interpolator);
			<span style="color:#080;font-weight:bold">return</span> lerp(easeInValue, easeOutValue, interpolator);
		}

		<span style="color:#080;font-weight:bold">float</span> ValueNoise2d(float2 value){
			<span style="color:#080;font-weight:bold">float</span> upperLeftCell <span style="color:#333">=</span> rand2dTo1d(float2(floor(value.x), ceil(value.y)));
			<span style="color:#080;font-weight:bold">float</span> upperRightCell <span style="color:#333">=</span> rand2dTo1d(float2(ceil(value.x), ceil(value.y)));
			<span style="color:#080;font-weight:bold">float</span> lowerLeftCell <span style="color:#333">=</span> rand2dTo1d(float2(floor(value.x), floor(value.y)));
			<span style="color:#080;font-weight:bold">float</span> lowerRightCell <span style="color:#333">=</span> rand2dTo1d(float2(ceil(value.x), floor(value.y)));

			<span style="color:#080;font-weight:bold">float</span> interpolatorX <span style="color:#333">=</span> easeInOut(frac(value.x));
			<span style="color:#080;font-weight:bold">float</span> interpolatorY <span style="color:#333">=</span> easeInOut(frac(value.y));

			<span style="color:#080;font-weight:bold">float</span> upperCells <span style="color:#333">=</span> lerp(upperLeftCell, upperRightCell, interpolatorX);
			<span style="color:#080;font-weight:bold">float</span> lowerCells <span style="color:#333">=</span> lerp(lowerLeftCell, lowerRightCell, interpolatorX);

			<span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> lerp(lowerCells, upperCells, interpolatorY);
			<span style="color:#080;font-weight:bold">return</span> noise;
		}

		<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
			float2 value <span style="color:#333">=</span> i.worldPos.xy <span style="color:#333">/</span> _CellSize;
			<span style="color:#080;font-weight:bold">float</span> noise <span style="color:#333">=</span> ValueNoise2d(value);

			o.Albedo <span style="color:#333">=</span> noise;
		}
		ENDCG
	}
	FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">025</span>_value_noise<span style="color:#333">/</span><span style="color:#00d;font-weight:bold">3</span>d<span style="color:#f00;background-color:#faa">&#34;</span> {
	Properties {
		_CellSize (<span style="color:#f00;background-color:#faa">&#34;</span>Cell Size<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
	}
	SubShader {
		Tags{ <span style="color:#f00;background-color:#faa">&#34;</span>RenderType<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Opaque<span style="color:#f00;background-color:#faa">&#34;</span> <span style="color:#f00;background-color:#faa">&#34;</span>Queue<span style="color:#f00;background-color:#faa">&#34;</span><span style="color:#333">=</span><span style="color:#f00;background-color:#faa">&#34;</span>Geometry<span style="color:#f00;background-color:#faa">&#34;</span>}

		CGPROGRAM

		<span style="color:#f00;background-color:#faa">#</span>pragma surface surf Standard fullforwardshadows
		<span style="color:#f00;background-color:#faa">#</span>pragma target <span style="color:#60e;font-weight:bold">3.0</span>

		<span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>Random.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

		<span style="color:#080;font-weight:bold">float</span> _CellSize;

		<span style="color:#080;font-weight:bold">struct</span> Input {
			float3 worldPos;
		};

		<span style="color:#080;font-weight:bold">float</span> easeIn(<span style="color:#080;font-weight:bold">float</span> interpolator){
			<span style="color:#080;font-weight:bold">return</span> interpolator <span style="color:#333">*</span> interpolator;
		}

		<span style="color:#080;font-weight:bold">float</span> easeOut(<span style="color:#080;font-weight:bold">float</span> interpolator){
			<span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> easeIn(<span style="color:#00d;font-weight:bold">1</span> <span style="color:#333">-</span> interpolator);
		}

		<span style="color:#080;font-weight:bold">float</span> easeInOut(<span style="color:#080;font-weight:bold">float</span> interpolator){
			<span style="color:#080;font-weight:bold">float</span> easeInValue <span style="color:#333">=</span> easeIn(interpolator);
			<span style="color:#080;font-weight:bold">float</span> easeOutValue <span style="color:#333">=</span> easeOut(interpolator);
			<span style="color:#080;font-weight:bold">return</span> lerp(easeInValue, easeOutValue, interpolator);
		}

		float3 ValueNoise3d(float3 value){
			<span style="color:#080;font-weight:bold">float</span> interpolatorX <span style="color:#333">=</span> easeInOut(frac(value.x));
			<span style="color:#080;font-weight:bold">float</span> interpolatorY <span style="color:#333">=</span> easeInOut(frac(value.y));
			<span style="color:#080;font-weight:bold">float</span> interpolatorZ <span style="color:#333">=</span> easeInOut(frac(value.z));

			float3 cellNoiseZ[<span style="color:#00d;font-weight:bold">2</span>];
			[unroll]
			<span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> z<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;z<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;z<span style="color:#333">++</span>){
				float3 cellNoiseY[<span style="color:#00d;font-weight:bold">2</span>];
				[unroll]
				<span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> y<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;y<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;y<span style="color:#333">++</span>){
					float3 cellNoiseX[<span style="color:#00d;font-weight:bold">2</span>];
					[unroll]
					<span style="color:#080;font-weight:bold">for</span>(<span style="color:#080;font-weight:bold">int</span> x<span style="color:#333">=</span><span style="color:#40e;font-weight:bold">0</span>;x<span style="color:#333">&lt;=</span><span style="color:#00d;font-weight:bold">1</span>;x<span style="color:#333">++</span>){
						float3 cell <span style="color:#333">=</span> floor(value) <span style="color:#333">+</span> float3(x, y, z);
						cellNoiseX[x] <span style="color:#333">=</span> rand3dTo3d(cell);
					}
					cellNoiseY[y] <span style="color:#333">=</span> lerp(cellNoiseX[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseX[<span style="color:#00d;font-weight:bold">1</span>], interpolatorX);
				}
				cellNoiseZ[z] <span style="color:#333">=</span> lerp(cellNoiseY[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseY[<span style="color:#00d;font-weight:bold">1</span>], interpolatorY);
			}
			float3 noise <span style="color:#333">=</span> lerp(cellNoiseZ[<span style="color:#40e;font-weight:bold">0</span>], cellNoiseZ[<span style="color:#00d;font-weight:bold">1</span>], interpolatorZ);
			<span style="color:#080;font-weight:bold">return</span> noise;
		}

		<span style="color:#080;font-weight:bold">void</span> surf (Input i, <span style="color:#080;font-weight:bold">inout</span> SurfaceOutputStandard o) {
			float3 value <span style="color:#333">=</span> i.worldPos.xyz <span style="color:#333">/</span> _CellSize;
			float3 noise <span style="color:#333">=</span> ValueNoise3d(value);

			o.Albedo <span style="color:#333">=</span> noise;
		}
		ENDCG
	}
	FallBack <span style="color:#f00;background-color:#faa">&#34;</span>Standard<span style="color:#f00;background-color:#faa">&#34;</span>
}
</code></pre></div><p>You can also find the source on github:</p>
<ul>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_1d.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_1d.shader</a></li>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_2d.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_2d.shader</a></li>
<li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_3d.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_3d.shader</a></li>
</ul>
<p>I hope this tutorial helped you understand how to interpolate between random values to generate smoother patterns.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ronja-tutorials" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
