<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Outlines via Postprocessing | Ronja&#39;s tutorials</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Summary One of my favourite postprocessing effects are outlines. Doing outlines via postprocessing has many advantages. It‚Äôs better at detecting edges than the alternative (inverted hull outlines) and you don‚Äôt have to change all of your materials to give them the outline effect.
To understand how to create outlines via postprocessing it‚Äôs best to have understood how to get access to the depth and normals of the scene first.
Depth Outlines We start with the shader and C# script from the postprocessing with normals tutorial.">
    <meta name="generator" content="Hugo 0.76.5" />
    
    
      <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">

    
    
      <link href="/dist/css/app.d876a0cc99d23e9edadbac7fc6abde13.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/css/main.css">
    

    
      

    

    
    
    <meta property="og:title" content="Outlines via Postprocessing" />
<meta property="og:description" content="Summary One of my favourite postprocessing effects are outlines. Doing outlines via postprocessing has many advantages. It‚Äôs better at detecting edges than the alternative (inverted hull outlines) and you don‚Äôt have to change all of your materials to give them the outline effect.
To understand how to create outlines via postprocessing it‚Äôs best to have understood how to get access to the depth and normals of the scene first.
Depth Outlines We start with the shader and C# script from the postprocessing with normals tutorial." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/post/019-postprocessing-outlines/" />
<meta property="article:published_time" content="2018-07-15T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-07-15T00:00:00+00:00" />
<meta itemprop="name" content="Outlines via Postprocessing">
<meta itemprop="description" content="Summary One of my favourite postprocessing effects are outlines. Doing outlines via postprocessing has many advantages. It‚Äôs better at detecting edges than the alternative (inverted hull outlines) and you don‚Äôt have to change all of your materials to give them the outline effect.
To understand how to create outlines via postprocessing it‚Äôs best to have understood how to get access to the depth and normals of the scene first.
Depth Outlines We start with the shader and C# script from the postprocessing with normals tutorial.">
<meta itemprop="datePublished" content="2018-07-15T00:00:00+00:00" />
<meta itemprop="dateModified" content="2018-07-15T00:00:00+00:00" />
<meta itemprop="wordCount" content="2303">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Outlines via Postprocessing"/>
<meta name="twitter:description" content="Summary One of my favourite postprocessing effects are outlines. Doing outlines via postprocessing has many advantages. It‚Äôs better at detecting edges than the alternative (inverted hull outlines) and you don‚Äôt have to change all of your materials to give them the outline effect.
To understand how to create outlines via postprocessing it‚Äôs best to have understood how to get access to the depth and normals of the scene first.
Depth Outlines We start with the shader and C# script from the postprocessing with normals tutorial."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Ronja&#39;s tutorials
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw7 center ph3">
    <header class="mt5 w-100">
      <h1 class="f1 athelas mt3 mb1">Outlines via Postprocessing</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-07-15T00:00:00Z">July 15, 2018</time>

      
      
		</header>
		
		<div style="margin-bottom: 70px;">
			<h3>Table Of Contents</h3>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#depth-outlines">Depth Outlines</a></li>
    <li><a href="#normal-outlines">Normal Outlines</a></li>
    <li><a href="#customizable-outlines">Customizable Outlines</a></li>
    <li><a href="#source">Source</a></li>
  </ul>
</nav>
		</div>

    <div class="w-100 nested-copy-line-height lh-copy sans-serif f4 nested-links nested-img mid-gray pr4-l"><div>
				
				<h2 id="summary">Summary <a href="#summary" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>One of my favourite postprocessing effects are outlines. Doing outlines via postprocessing has many advantages. It‚Äôs better at detecting edges than the alternative (inverted hull outlines) and you don‚Äôt have to change all of your materials to give them the outline effect.</p>
<p>To understand how to create outlines via postprocessing it‚Äôs best to have understood how to <a href="https://www.ronja-tutorials.com/post/017-postprocessing-depth/">get access to the depth and normals of the scene</a> first.</p>
<p><img src="/assets/images/posts/019/Result.gif" alt="Result"></p>
<h2 id="depth-outlines">Depth Outlines <a href="#depth-outlines" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>We start with the shader and C# script from the postprocessing with normals tutorial.</p>
<p>The first changes we make is to remove properties and variables which were specific to the ‚Äúcolor on top‚Äù shader. So the cutoff value and the color. We also remove the view to world matrix, because we our outlines don‚Äòt have a specific rotation in the world so we can ignore it. Then we remove all of the code after the part where we calculate the depth and normals.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//show values to edit in inspector</span>
Properties{
    [HideInInspector]_MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//read depthnormal</span>
    float4 depthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, i.uv);

    <span style="color:#888">//decode depthnormal</span>
    float3 normal;
    <span style="color:#080;font-weight:bold">float</span> depth;
    DecodeDepthNormal(depthnormal, depth, normal);

    <span style="color:#888">//get depth as distance from camera in units </span>
    depth <span style="color:#333">=</span> depth <span style="color:#333">*</span> _ProjectionParams.z;


}
</code></pre></div><p>Then we remove the part where we write the camera matrix to the shader from our C# script.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//method which is automatically called by unity after the camera is done rendering</span>
private <span style="color:#080;font-weight:bold">void</span> OnRenderImage(RenderTexture source, RenderTexture destination){
    <span style="color:#888">//draws the pixels from the source texture to the destination texture</span>
    Graphics.Blit(source, destination, postprocessMaterial);
}
</code></pre></div><p>The way we‚Äôre going to calculate the outlines is that we‚Äôre going to read from several pixels around the pixel we‚Äôre rendering and calculate the difference in depth and normals to the center pixel. The more different they are, the stronger the outline is.</p>
<p>To calculate the position of the neighboring pixels we need to know how big one pixel is. Luckily we can simply add a variable with a specific name and unity tells us the size. Because technically we‚Äôre working with texture pixels, it‚Äôs called the texelsize.</p>
<p>We can simply create a variable called texturename_TexelSize for any texture and get the size.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the depth normals texture</span>
<span style="color:#080;font-weight:bold">sampler2D</span> _CameraDepthNormalsTexture;
<span style="color:#888">//texelsize of the depthnormals texture</span>
float4 _CameraDepthNormalsTexture_TexelSize;
</code></pre></div><p>Then we copy the code for accessing the depth and normals, but change the names and we access the texture slightly to the right.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//read neighbor pixel</span>
float4 neighborDepthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, 
        uv <span style="color:#333">+</span> _CameraDepthNormalsTexture_TexelSize.xy <span style="color:#333">*</span> offset);
float3 neighborNormal;
<span style="color:#080;font-weight:bold">float</span> neighborDepth;
DecodeDepthNormal(neighborDepthnormal, neighborDepth, neighborNormal);
neighborDepth <span style="color:#333">=</span> neighborDepth <span style="color:#333">*</span> _ProjectionParams.z;
</code></pre></div><p>Now that we have two samples we can calculate the difference and draw it to the screen.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> difference <span style="color:#333">=</span> depth <span style="color:#333">-</span> neightborDepth;
<span style="color:#080;font-weight:bold">return</span> difference;
</code></pre></div><p><img src="/assets/images/posts/019/LeftWhite.png" alt=""></p>
<p>With this we can already see the outlines on the left side of the objects. Before we proceed with the next sample, I‚Äôd like to put the code for reading the sample and comparing it to the center values into a separate function so we don‚Äôt have to write it 4 times. This function needs the depth of the center pixel, the uv coordinates of the center pixel and the offset as arguments. We will define the offset in pixels because that‚Äôs the easiest for us to read.</p>
<p>So we simply copy the code from our fragment function to the new method and replace the depth and uv names with the names of the fitting arguments. To use the offset, we multiply it with the x and y coordinates of the texel size and then add the result to the uv coordinates just like previously.</p>
<p>After we set up the new method we call it in the fragment method and draw the result to the screen.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> Compare(<span style="color:#080;font-weight:bold">float</span> baseDepth, float2 uv, float2 offset){
    <span style="color:#888">//read neighbor pixel</span>
    float4 neighborDepthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, 
            uv <span style="color:#333">+</span> _CameraDepthNormalsTexture_TexelSize.xy <span style="color:#333">*</span> offset);
    float3 neighborNormal;
    <span style="color:#080;font-weight:bold">float</span> neighborDepth;
    DecodeDepthNormal(neighborDepthnormal, neighborDepth, neighborNormal);
    neighborDepth <span style="color:#333">=</span> neighborDepth <span style="color:#333">*</span> _ProjectionParams.z;

    <span style="color:#080;font-weight:bold">return</span> baseDepth <span style="color:#333">-</span> neighborDepth;
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">    <span style="color:#080;font-weight:bold">float</span> depthDifference <span style="color:#333">=</span> Compare(depth, i.uv, float2(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>));

    <span style="color:#080;font-weight:bold">return</span> depthDifference;
}
</code></pre></div><p>The result should look exactly like previously, but now it‚Äôs way easier to expand the shader to read samples in multiple directions. So we sample the pixels up, right and down too and add the results of all samples together.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//the fragment shader</span>
fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
    <span style="color:#888">//read depthnormal</span>
    float4 depthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, i.uv);

    <span style="color:#888">//decode depthnormal</span>
    float3 normal;
    <span style="color:#080;font-weight:bold">float</span> depth;
    DecodeDepthNormal(depthnormal, depth, normal);

    <span style="color:#888">//get depth as distance from camera in units </span>
    depth <span style="color:#333">=</span> depth <span style="color:#333">*</span> _ProjectionParams.z;

    <span style="color:#080;font-weight:bold">float</span> depthDifference <span style="color:#333">=</span> Compare(depth, i.uv, float2(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>));
    depthDifference <span style="color:#333">=</span> depthDifference <span style="color:#333">+</span> Compare(depth, i.uv, float2(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>));
    depthDifference <span style="color:#333">=</span> depthDifference <span style="color:#333">+</span> Compare(depth, i.uv, float2(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>));
    depthDifference <span style="color:#333">=</span> depthDifference <span style="color:#333">+</span> Compare(depth, i.uv, float2(<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>));

    <span style="color:#080;font-weight:bold">return</span> depthDifference;
}
</code></pre></div><p><img src="/assets/images/posts/019/DepthOutlines.png" alt=""></p>
<h2 id="normal-outlines">Normal Outlines <a href="#normal-outlines" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>Using the depth already gives us pretty good outlines, but we can go further by also using the normals provided to us. We will also sample the normals in our compare function, but function can only return one value in hlsl so we can‚Äôt use the return value here. Instead of using the return value, we can add two new arguments with the inout keyword. With this keyword the value we pass into the function can be written to and the changes apply to the version of the variable pass in, not only the version in the function. Another thing we need to generate outlines from the normal is the outline of the center pixel, so we add that too to the list of our arguments.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> Compare(<span style="color:#080;font-weight:bold">inout</span> <span style="color:#080;font-weight:bold">float</span> depthOutline, <span style="color:#080;font-weight:bold">inout</span> <span style="color:#080;font-weight:bold">float</span> normalOutline, 
    <span style="color:#080;font-weight:bold">float</span> baseDepth, float3 baseNormal, float2 uv, float2 offset){
</code></pre></div><p>Because we now have complete control over the outline variable we can now also do the adding to the existing outline in the method. After we changed that we go back to the fragment method, create a new variable for the difference of the normals and change the way we call the compare method to fit our new arguments.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">void</span> Compare(<span style="color:#080;font-weight:bold">inout</span> <span style="color:#080;font-weight:bold">float</span> depthOutline, <span style="color:#080;font-weight:bold">inout</span> <span style="color:#080;font-weight:bold">float</span> normalOutline, 
        <span style="color:#080;font-weight:bold">float</span> baseDepth, float3 baseNormal, float2 uv, float2 offset){
    <span style="color:#888">//read neighbor pixel</span>
    float4 neighborDepthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, 
            uv <span style="color:#333">+</span> _CameraDepthNormalsTexture_TexelSize.xy <span style="color:#333">*</span> offset);
    float3 neighborNormal;
    <span style="color:#080;font-weight:bold">float</span> neighborDepth;
    DecodeDepthNormal(neighborDepthnormal, neighborDepth, neighborNormal);
    neighborDepth <span style="color:#333">=</span> neighborDepth <span style="color:#333">*</span> _ProjectionParams.z;

    <span style="color:#080;font-weight:bold">float</span> depthDifference <span style="color:#333">=</span> baseDepth <span style="color:#333">-</span> neighborDepth;
    depthOutline <span style="color:#333">=</span> depthOutline <span style="color:#333">+</span> depthDifference;
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> depthDifference <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;
<span style="color:#080;font-weight:bold">float</span> normalDifference <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;

Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>));
Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>));
Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>));
Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>));

<span style="color:#080;font-weight:bold">return</span> depthDifference;
</code></pre></div><p>This again shouldn‚Äôt change the output of the method, but the new architecture allows us to also change the difference of the normal too. A easy and fast way to compare two normalised vectors is to take the dot product. The problem about the dot product is that when the vectors point in the same direction, the dot product is 1 and when the vectors move away from each other the dot product becomes lower, the opposite of what we want. The way to fixing that is to subtract the dot product from 1. Then, when the result of the dot product is 1 the overall result is 0 and when the result of the dot product becomes lower, the overall result increases. After we calculate the normal difference, we add it to the overall difference and we change the output to show the normal difference for now.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float3 normalDifference <span style="color:#333">=</span> baseNormal <span style="color:#333">-</span> neighborNormal;
normalDifference <span style="color:#333">=</span> normalDifference.r <span style="color:#333">+</span> normalDifference.g <span style="color:#333">+</span> normalDifference.b;
normalOutline <span style="color:#333">=</span> normalOutline <span style="color:#333">+</span> normalDifference;
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">return</span> normalDifference;
</code></pre></div><p><img src="/assets/images/posts/019/NormalOutlines.png" alt=""></p>
<p>With those changes we can see outlines, but they‚Äôre different outlines than before because they‚Äôre generated from the normals instead of the depth. We can then combine the two outlines to generatecombined outline.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">return</span> depthDifference <span style="color:#333">+</span> normalDifference;
</code></pre></div><p><img src="/assets/images/posts/019/CombinedOutlines.png" alt=""></p>
<h2 id="customizable-outlines">Customizable Outlines <a href="#customizable-outlines" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<p>The next step is to make the outlines more customisable. To archieve that we add two variables for each depth and normal outlines. A multiplier to make the outlines appear stronger or weaker and a bias that can make the greyish parts of the outlines we might not want vanish.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//show values to edit in inspector</span>
Properties{
    [HideInInspector]_MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
    _NormalMult (<span style="color:#f00;background-color:#faa">&#34;</span>Normal Outline Multiplier<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">4</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
    _NormalBias (<span style="color:#f00;background-color:#faa">&#34;</span>Normal Outline Bias<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">4</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
    _DepthMult (<span style="color:#f00;background-color:#faa">&#34;</span>Depth Outline Multiplier<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">4</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
    _DepthBias (<span style="color:#f00;background-color:#faa">&#34;</span>Depth Outline Bias<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">4</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#888">//variables for customising the effect</span>
<span style="color:#080;font-weight:bold">float</span> _NormalMult;
<span style="color:#080;font-weight:bold">float</span> _NormalBias;
<span style="color:#080;font-weight:bold">float</span> _DepthMult;
<span style="color:#080;font-weight:bold">float</span> _DepthBias;
</code></pre></div><p>To use the variables, after adding all of the sample differences, we simply multiply the difference variables with the multipliers, then we clamp them between 0 and 1 and get the difference to the power of the bias. The clamping between 0 and 1 is important because otherwise getting the exponent of a negative number can lead to invalid results. HLSL has it‚Äôs own function for clamping a variable between 0 and 1 called ‚Äúsaturate‚Äù.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">depthDifference <span style="color:#333">=</span> depthDifference <span style="color:#333">*</span> _DepthMult;
depthDifference <span style="color:#333">=</span> saturate(depthDifference);
depthDifference <span style="color:#333">=</span> pow(depthDifference, _DepthBias);

normalDifference <span style="color:#333">=</span> normalDifference <span style="color:#333">*</span> _NormalMult;
normalDifference <span style="color:#333">=</span> saturate(normalDifference);
normalDifference <span style="color:#333">=</span> pow(normalDifference, _NormalBias);

<span style="color:#080;font-weight:bold">return</span> depthDifference <span style="color:#333">+</span> normalDifference;
</code></pre></div><p>With this you can now adjust your outlines a bit in the inspector - I boosted both normal and depth outlines a bit and reduced the noise by also increasing the bias, but it‚Äôs best to play around with the settings and see what fits your scene best.</p>
<p><img src="/assets/images/posts/019/Inspector.png" alt=""></p>
<p><img src="/assets/images/posts/019/TweakedOutlines.png" alt=""></p>
<p>Lastly we want to add our outlines to the scene, not just have them as a separate thing. For that we first declare a outline color as a property and shader variable.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">_OutlineColor (<span style="color:#f00;background-color:#faa">&#34;</span>Outline Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>)
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">float4 _OutlineColor;
</code></pre></div><p>To apply the outlines, at the end of  the fragment function, we read from the source texture and do a linear interpolation from the source color to our outline color via the combined outline, that way the pixels that were previously black are now the source color and the white ones have the outline color.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl"><span style="color:#080;font-weight:bold">float</span> outline <span style="color:#333">=</span> normalDifference <span style="color:#333">+</span> depthDifference;
float4 sourceColor <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
float4 color <span style="color:#333">=</span> lerp(sourceColor, _OutlineColor, outline);
<span style="color:#080;font-weight:bold">return</span> color;
</code></pre></div><p><img src="/assets/images/posts/019/Result.png" alt="Result"></p>
<p>The main disadvantages of postprocessed outlines are that you have to apply them to all object in the scene, The way the system decides what‚Äôs a outline and what isn‚Äôt might not fit the style your have in mind and you get aliasing (visible stairsteps) artefacts pretty quickly.</p>
<p>While there aren‚Äôt any easy fixes for the first two problems, you can mitigate the last one by using antialiasing in your postprocessing like FXAA or TXAA (the unity postprocessing stack provides those to you, but if you use v2 you have to redo the effect as a effect in the stack).</p>
<p>Another important point to keep in mind is that you have to use models that fit this way of doing outlines - if you put too much detail in your geometry the effect will paint most of your objects black, which is probably not the intended behaviour.</p>
<h2 id="source">Source <a href="#source" class="hanchor" ariaLabel="Anchor">üîó&#xFE0E;</a> </h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-glsl" data-lang="glsl">Shader <span style="color:#f00;background-color:#faa">&#34;</span>Tutorial<span style="color:#333">/</span><span style="color:#40e;font-weight:bold">01</span><span style="color:#00d;font-weight:bold">9</span>_OutlinesPostprocessed<span style="color:#f00;background-color:#faa">&#34;</span>
{
    <span style="color:#888">//show values to edit in inspector</span>
    Properties{
        [HideInInspector]_MainTex (<span style="color:#f00;background-color:#faa">&#34;</span>Texture<span style="color:#f00;background-color:#faa">&#34;</span>, <span style="color:#00d;font-weight:bold">2</span>D) <span style="color:#333">=</span> <span style="color:#f00;background-color:#faa">&#34;</span>white<span style="color:#f00;background-color:#faa">&#34;</span> {}
        _OutlineColor (<span style="color:#f00;background-color:#faa">&#34;</span>Outline Color<span style="color:#f00;background-color:#faa">&#34;</span>, Color) <span style="color:#333">=</span> (<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">1</span>)
        _NormalMult (<span style="color:#f00;background-color:#faa">&#34;</span>Normal Outline Multiplier<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">4</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
        _NormalBias (<span style="color:#f00;background-color:#faa">&#34;</span>Normal Outline Bias<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">4</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
        _DepthMult (<span style="color:#f00;background-color:#faa">&#34;</span>Depth Outline Multiplier<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#40e;font-weight:bold">0</span>,<span style="color:#00d;font-weight:bold">4</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
        _DepthBias (<span style="color:#f00;background-color:#faa">&#34;</span>Depth Outline Bias<span style="color:#f00;background-color:#faa">&#34;</span>, Range(<span style="color:#00d;font-weight:bold">1</span>,<span style="color:#00d;font-weight:bold">4</span>)) <span style="color:#333">=</span> <span style="color:#00d;font-weight:bold">1</span>
    }

    SubShader{
        <span style="color:#888">// markers that specify that we don&#39;t need culling </span>
        <span style="color:#888">// or comparing/writing to the depth buffer</span>
        Cull Off
        ZWrite Off 
        ZTest Always

        Pass{
            CGPROGRAM
            <span style="color:#888">//include useful shader functions</span>
            <span style="color:#f00;background-color:#faa">#</span>include <span style="color:#f00;background-color:#faa">&#34;</span>UnityCG.cginc<span style="color:#f00;background-color:#faa">&#34;</span>

            <span style="color:#888">//define vertex and fragment shader</span>
            <span style="color:#f00;background-color:#faa">#</span>pragma vertex vert
            <span style="color:#f00;background-color:#faa">#</span>pragma fragment frag

            <span style="color:#888">//the rendered screen so far</span>
            <span style="color:#080;font-weight:bold">sampler2D</span> _MainTex;
            <span style="color:#888">//the depth normals texture</span>
            <span style="color:#080;font-weight:bold">sampler2D</span> _CameraDepthNormalsTexture;
            <span style="color:#888">//texelsize of the depthnormals texture</span>
            float4 _CameraDepthNormalsTexture_TexelSize;

            <span style="color:#888">//variables for customising the effect</span>
            float4 _OutlineColor;
            <span style="color:#080;font-weight:bold">float</span> _NormalMult;
            <span style="color:#080;font-weight:bold">float</span> _NormalBias;
            <span style="color:#080;font-weight:bold">float</span> _DepthMult;
            <span style="color:#080;font-weight:bold">float</span> _DepthBias;

            <span style="color:#888">//the object data that&#39;s put into the vertex shader</span>
            <span style="color:#080;font-weight:bold">struct</span> appdata{
                float4 vertex <span style="color:#333">:</span> POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the data that&#39;s used to generate fragments and can be read by the fragment shader</span>
            <span style="color:#080;font-weight:bold">struct</span> v2f{
                float4 position <span style="color:#333">:</span> SV_POSITION;
                float2 uv <span style="color:#333">:</span> TEXCOORD0;
            };

            <span style="color:#888">//the vertex shader</span>
            v2f vert(appdata v){
                v2f o;
                <span style="color:#888">//convert the vertex positions from object space to clip space so they can be rendered</span>
                o.position <span style="color:#333">=</span> UnityObjectToClipPos(v.vertex);
                o.uv <span style="color:#333">=</span> v.uv;
                <span style="color:#080;font-weight:bold">return</span> o;
            }

            <span style="color:#080;font-weight:bold">void</span> Compare(<span style="color:#080;font-weight:bold">inout</span> <span style="color:#080;font-weight:bold">float</span> depthOutline, <span style="color:#080;font-weight:bold">inout</span> <span style="color:#080;font-weight:bold">float</span> normalOutline, 
                    <span style="color:#080;font-weight:bold">float</span> baseDepth, float3 baseNormal, float2 uv, float2 offset){
                <span style="color:#888">//read neighbor pixel</span>
                float4 neighborDepthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, 
                        uv <span style="color:#333">+</span> _CameraDepthNormalsTexture_TexelSize.xy <span style="color:#333">*</span> offset);
                float3 neighborNormal;
                <span style="color:#080;font-weight:bold">float</span> neighborDepth;
                DecodeDepthNormal(neighborDepthnormal, neighborDepth, neighborNormal);
                neighborDepth <span style="color:#333">=</span> neighborDepth <span style="color:#333">*</span> _ProjectionParams.z;

                <span style="color:#080;font-weight:bold">float</span> depthDifference <span style="color:#333">=</span> baseDepth <span style="color:#333">-</span> neighborDepth;
                depthOutline <span style="color:#333">=</span> depthOutline <span style="color:#333">+</span> depthDifference;

                float3 normalDifference <span style="color:#333">=</span> baseNormal <span style="color:#333">-</span> neighborNormal;
                normalDifference <span style="color:#333">=</span> normalDifference.r <span style="color:#333">+</span> normalDifference.g <span style="color:#333">+</span> normalDifference.b;
                normalOutline <span style="color:#333">=</span> normalOutline <span style="color:#333">+</span> normalDifference;
            }

            <span style="color:#888">//the fragment shader</span>
            fixed4 frag(v2f i) <span style="color:#333">:</span> SV_TARGET{
                <span style="color:#888">//read depthnormal</span>
                float4 depthnormal <span style="color:#333">=</span> tex2D(_CameraDepthNormalsTexture, i.uv);

                <span style="color:#888">//decode depthnormal</span>
                float3 normal;
                <span style="color:#080;font-weight:bold">float</span> depth;
                DecodeDepthNormal(depthnormal, depth, normal);

                <span style="color:#888">//get depth as distance from camera in units </span>
                depth <span style="color:#333">=</span> depth <span style="color:#333">*</span> _ProjectionParams.z;

                <span style="color:#080;font-weight:bold">float</span> depthDifference <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;
                <span style="color:#080;font-weight:bold">float</span> normalDifference <span style="color:#333">=</span> <span style="color:#40e;font-weight:bold">0</span>;

                Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>));
                Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#00d;font-weight:bold">1</span>));
                Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span style="color:#40e;font-weight:bold">0</span>, <span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>));
                Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>, <span style="color:#40e;font-weight:bold">0</span>));

                depthDifference <span style="color:#333">=</span> depthDifference <span style="color:#333">*</span> _DepthMult;
                depthDifference <span style="color:#333">=</span> saturate(depthDifference);
                depthDifference <span style="color:#333">=</span> pow(depthDifference, _DepthBias);

                normalDifference <span style="color:#333">=</span> normalDifference <span style="color:#333">*</span> _NormalMult;
                normalDifference <span style="color:#333">=</span> saturate(normalDifference);
                normalDifference <span style="color:#333">=</span> pow(normalDifference, _NormalBias);

                <span style="color:#080;font-weight:bold">float</span> outline <span style="color:#333">=</span> normalDifference <span style="color:#333">+</span> depthDifference;
                float4 sourceColor <span style="color:#333">=</span> tex2D(_MainTex, i.uv);
                float4 color <span style="color:#333">=</span> lerp(sourceColor, _OutlineColor, outline);
                <span style="color:#080;font-weight:bold">return</span> color;
            }
            ENDCG
        }
    }
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:2;-o-tab-size:2;tab-size:2"><code class="language-cs" data-lang="cs"><span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">UnityEngine</span>;
<span style="color:#080;font-weight:bold">using</span> <span style="color:#0e84b5;font-weight:bold">System</span>;

<span style="color:#888">//behaviour which should lie on the same gameobject as the main camera
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">public</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">OutlinesPostprocessed</span> : MonoBehaviour {
    <span style="color:#888">//material that&#39;s applied when doing postprocessing
</span><span style="color:#888"></span><span style="color:#00c">    [SerializeField]</span>
    <span style="color:#080;font-weight:bold">private</span> Material postprocessMaterial;

    <span style="color:#080;font-weight:bold">private</span> Camera cam;

    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">void</span> Start(){
        <span style="color:#888">//get the camera and tell it to render a depthnormals texture
</span><span style="color:#888"></span>        cam = GetComponent&lt;Camera&gt;();
        cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.DepthNormals;
    }

    <span style="color:#888">//method which is automatically called by unity after the camera is done rendering
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">void</span> OnRenderImage(RenderTexture source, RenderTexture destination){
        <span style="color:#888">//draws the pixels from the source texture to the destination texture
</span><span style="color:#888"></span>        Graphics.Blit(source, destination, postprocessMaterial);
    }
}
</code></pre></div><p>You can also find the source here:<!-- raw HTML omitted -->
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/019_OutlinesPostprocessed/OutlinesPostprocessed.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/019_OutlinesPostprocessed/OutlinesPostprocessed.shader</a><!-- raw HTML omitted -->
<a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/019_OutlinesPostprocessed/OutlinesPostprocessed.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/019_OutlinesPostprocessed/OutlinesPostprocessed.cs</a></p>
<p>I hope I was able to show you how to add nice outlines to your game and how it works.</p>

			</div>I hope you enjoyed my tutorial ‚ú®. If you want to support me further feel free to follow me on <a href="https://twitter.com/totallyRonja">twitter</a>, 
			throw me a one-time donation via <a href="https://ko-fi.com/ronjatutorials">ko-fi</a> 
			or support me on <a href="https://www.patreon.com/RonjaTutorials">patreon</a> 
			(I try to put updates also there, but I fail most of the time, bear with me üíñ).<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>


  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://www.ronja-tutorials.com" >
    &copy;  Ronja's tutorials 2021 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
