<!DOCTYPE html>
<html lang="en">

  <head>

    <!-- Non social metatags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="theme-color" content="#157878">

    

    <title>Tiling Noise</title>

    
      <!-- Update your html tag to include the itemscope and itemtype attributes. -->
<html itemscope itemtype="http://schema.org/Article">












<!-- Place this data between the <head> tags of your website -->

  <meta name="author" content="Ronja Böhringer">

<meta name="description" content="So far we generated noise that goes on forever. But in some cases we want noise that repeats itself after a certain distance though, mainly when we’r..." />





<!-- Schema.org markup for Google+ -->
<meta itemprop="name" content="Tiling Noise">
<meta itemprop="description" content="So far we generated noise that goes on forever. But in some cases we want noise that repeats itself after a certain distance though, mainly when we’r...">

  <meta itemprop="image" content="https://www.ronja-tutorials.com/assets/images/posts/029/Result.png">


<!-- Twitter Card data -->
<meta name="twitter:card" content="summary_large_image">



<meta name="twitter:title" content="Tiling Noise">
<meta name="twitter:description" content="So far we generated noise that goes on forever. But in some cases we want noise that repeats itself after a certain distance though, mainly when we’r...">


  <meta name="twitter:creator" content="@TotallyRonja">


<!-- Twitter summary card with large image must be at least 280x150px -->

  <meta name="twitter:image:src" content="https://www.ronja-tutorials.com/assets/images/posts/029/Result.png">
  <meta property="twitter:image" content="https://www.ronja-tutorials.com/assets/images/posts/029/Result.png">

<meta property="twitter:url" content="https://www.ronja-tutorials.com/2018/10/06/tiling-noise.html">

<!-- Open Graph data -->
<meta property="og:title" content="Tiling Noise" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.ronja-tutorials.com/2018/10/06/tiling-noise.html" />

  <meta property="og:image" content="https://www.ronja-tutorials.com/assets/images/posts/029/Result.png" />

<meta property="og:description" content="So far we generated noise that goes on forever. But in some cases we want noise that repeats itself after a certain distance though, mainly when we’r..." />
<meta property="og:site_name" content="Ronja's Shader Tutorials" />

  <meta property="article:published_time" content="2018-10-06T00:00:00+02:00" />














  





  




    

    <link rel="canonical" href="https://www.ronja-tutorials.com/2018/10/06/tiling-noise.html">

    

    <!-- <link rel="shortcut icon" href="https://www.ronja-tutorials.com/favicon.ico"> -->
    <meta name="robots" content="noarchive">

    <!-- <link rel="alternate" media="only screen and (max-width: 640px)" href="">
    <link rel="alternate" media="handheld" href=""> -->


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <script async defer data-website-id="fb34d410-ef67-4a3a-8fdc-01a05f5e22b2" src="https://stats.ruby0x1.ca/umami.js" ></script>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    

    
      <a class="site-title" href="/">Ronja&#39;s Shader Tutorials</a>
    
    <!-- SVG icons from https://iconmonstr.com -->

    <!-- Twitter icon -->
    <span class="my-span-icon">
        <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
          <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
        </a>
      </span>

      <!-- RSS icon -->
      
        <span class="my-span-icon">
          <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
          </a>
        </span>
      
      <!-- Contact icon -->
      
      
        <span class="my-span-icon">
          <a href="/about.html" aria-label="Contact" title="Contact ">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
          </a>
        </span>
      

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
              
            
          
            
            
          
            
            
              
                <a class="page-link" href="/about.html">About</a>
              
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
              
                <a class="page-link" href="/2018/03/20/hlsl-basics.html"></a>
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    
    
    

    <section class="page-header">
      <h1 class="project-name">Tiling Noise</h1>
      <h2 class="project-tagline"></h2>
      
      <!-- Post tagline -->
      
        <h2 class="project-date">
        <time datetime="2018-10-06T00:00:00+02:00" itemprop="datePublished">
          
          Oct 6, 2018
        </time>
        
        
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ronja Böhringer</span></span>
        
        </h2>
      
      <!-- End: Post tagline -->
    </section>

    <section class="main-content">

      <article itemscope itemtype="http://schema.org/BlogPosting">

  <!-- <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Tiling Noise</h1>
    <p class="post-meta">
      <time datetime="2018-10-06T00:00:00+02:00" itemprop="datePublished">
        
        Oct 6, 2018
      </time>
      </p>
  </header> -->

  
<ul>
  <li><a href="#tileable-noise">Tileable noise</a></li>
  <li><a href="#layered-tileable-noise">Layered tileable noise</a></li>
  <li><a href="#noise-in-unlit-uv-space">Noise in unlit UV space</a></li>
  <li><a href="#tiling-and-uv-space-noise-in-3d">Tiling and UV space noise in 3d</a></li>
  <li><a href="#source">Source</a>
    <ul>
      <li><a href="#tiling-2d-layered-perlin">Tiling 2d layered perlin</a></li>
      <li><a href="#tiling-3d-voronoi">Tiling 3d voronoi</a></li>
    </ul>
  </li>
</ul>

  <div itemprop="articleBody">
    <p>So far we generated noise that goes on forever. But in some cases we want noise that repeats itself after a certain distance though, mainly when we’re baking noise into a texture. In this tutorial I’ll show you how to make noise repeat and how to use uv coordinates instead of worldspace positions for noise generation.</p>

<p>I use the layered perlin noise and voronoi noise to show the theory behind tiling noise, but it’s possible to use those patterns with many different types of noise and other shaders as well. That being said this tutorial is part of the <a href="/noise.html">noise series</a> so if you have troubles with anything and haven’t read earlier noise tutorials yet, I recommend you read them first.</p>

<p><img src="/assets/images/posts/029/Result.png" alt="" /></p>

<h2 id="tileable-noise">Tileable noise</h2>

<p>We’ll use the layered 2d perlin noise as the first shader to modify to be tilable. We expand the perlin function to take another parameter called the period which is how often the noise tiles, counted in cells. Previously we calculated the cell positions directly before we passed them to the random function to calculate the direction of the cell, but to better be able to repeat the noise we’ll calculate the maximum and minimum of the cells before passing it and then choosing the correct parameters out of them. We still get the component minimum of the cells by using floor and get the maximum via ceil. Then we use the x or y component of the minimum vector if we previously used floor and use the x or y component of the maximum vector where we previously used ceil.</p>

<p>Then we make the cell positions wrap according to our new period variable. We do that by taking the modulo of the cell variables. The problem with the modulo implementation is that it returns the remainder. The difference between the mathematical remainder and modulo is that the modulo of will always be positive while the remainder of a negative number is negative. for example the modulo between <code class="language-plaintext highlighter-rouge">-5</code> and <code class="language-plaintext highlighter-rouge">3</code> would be <code class="language-plaintext highlighter-rouge">1</code> because if we multiply <code class="language-plaintext highlighter-rouge">3</code> by <code class="language-plaintext highlighter-rouge">-2</code> we get <code class="language-plaintext highlighter-rouge">-6</code> and the modulo is the difference, <code class="language-plaintext highlighter-rouge">1</code>. In the base of a implementation using the remainder, the result would be <code class="language-plaintext highlighter-rouge">-2</code> instead because it assumes that it’s allowed to to just use <code class="language-plaintext highlighter-rouge">-1</code> as a multiplier and then in that case the difference to our divident is <code class="language-plaintext highlighter-rouge">-1</code>. The point of this small journey into mathematics is that we have the remainder, but we want the modulo. The fix for that is to first, get the remainder, then add the divisor again and take the modulo a second time. We know that after the first remainder the value isn’t lower than our divisor times -1, so by adding the divisor again, we know the value is positive. And after ensuring we have a positive value we can apply the remainder a second time because we know it behaves exactly the same way as the modulo if we have positive values. We’ll add the modulo as a extra function to our shader. The input and output is a <code class="language-plaintext highlighter-rouge">float2</code> so we can make the x and y coodinate wrap at the same time.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float2</span> <span class="nf">modulo</span><span class="p">(</span><span class="n">float2</span> <span class="n">divident</span><span class="p">,</span> <span class="n">float2</span> <span class="n">divisor</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">positiveDivident</span> <span class="o">=</span> <span class="n">divident</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">+</span> <span class="n">divisor</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">positiveDivident</span> <span class="o">%</span> <span class="n">divisor</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now that we have this sorted out, we can use this custom modulo function to make make the cells wrap according to the period. The result will be that if we pass <code class="language-plaintext highlighter-rouge">(4, 4)</code> as a period, the noise will repeat itself every 4 cells, so in the X direction it’ll go <code class="language-plaintext highlighter-rouge">(0, 0), (1, 0), (2, 0), (3, 0), (0, 0), (1, 0), (2, 0), etc...</code> and similarly in the y direction <code class="language-plaintext highlighter-rouge">(0, 0), (0, 1), (0, 2), (0, 3), (0, 0), (0, 1), (0, 2), etc...</code>.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">perlinNoise</span><span class="p">(</span><span class="n">float2</span> <span class="n">value</span><span class="p">,</span> <span class="n">float2</span> <span class="n">period</span><span class="p">){</span>
    <span class="n">float2</span> <span class="n">cellsMimimum</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">cellsMaximum</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

    <span class="n">cellsMimimum</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">cellsMimimum</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
    <span class="n">cellsMaximum</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">cellsMaximum</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>

    <span class="c1">//generate random directions</span>
    <span class="n">float2</span> <span class="n">lowerLeftDirection</span> <span class="o">=</span> <span class="n">rand2dTo2d</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">cellsMimimum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellsMimimum</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">lowerRightDirection</span> <span class="o">=</span> <span class="n">rand2dTo2d</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">cellsMaximum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellsMimimum</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">upperLeftDirection</span> <span class="o">=</span> <span class="n">rand2dTo2d</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">cellsMimimum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellsMaximum</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">upperRightDirection</span> <span class="o">=</span> <span class="n">rand2dTo2d</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">cellsMaximum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellsMaximum</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">//rest of the function unchanged</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span> <span class="o">/</span> <span class="n">_CellSize</span><span class="p">;</span>
    <span class="c1">//get noise and adjust it to be ~0-1 range</span>
    <span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">perlinNoise</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">=</span> <span class="n">noise</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/029/RepeatingPerlin.png" alt="" /></p>

<h2 id="layered-tileable-noise">Layered tileable noise</h2>

<p>This is all we need for simple tiling noise, but it doesn’t work well for layered noise out of the box. If we double the frequency of the noise to 8 cells in the same area where there were 4 previously, but still repeat the noise every 4 cells, we have a unnessecary amount of repetition and it’ll look weird. To counteract that we have to multiply the period by the frequency in our octaves. Double the amount of cells per space means we can repeat half as frequently.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">sampleLayeredNoise</span><span class="p">(</span><span class="n">float2</span> <span class="n">value</span><span class="p">){</span>
    <span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">frequency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">OCTAVES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">+</span> <span class="n">perlinNoise</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">frequency</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">72354</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">frequency</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
        <span class="n">factor</span> <span class="o">*=</span> <span class="n">_Persistance</span><span class="p">;</span>
        <span class="n">frequency</span> <span class="o">*=</span> <span class="n">_Roughness</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">noise</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xz</span> <span class="o">/</span> <span class="n">_CellSize</span><span class="p">;</span>
    <span class="c1">//get noise and adjust it to be ~0-1 range</span>
    <span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">sampleLayeredNoise</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="o">=</span> <span class="n">noise</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally we’re going to expose the variable for adjusting the period of the noise to the inspector. The period property is of the type vector. Sadly unity doesn’t allow us to expose vectors other than 4-dimensional ones, but if we define the variable in the hlsl part as a 2d vector it’ll simply ignore the last two components of the property.</p>

<p>Another thing I’d like to change is that currently the roughness is a completely free slider, but for values with a fractional part the tiling breaks. That’s because you can’t cleanly wrap after 3.5 cells for example. To simply forbid ourselves from entering values with fractional parts, we can simply precede the property with the <code class="language-plaintext highlighter-rouge">[IntRange]</code> attribute.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Properties</span> <span class="p">{</span>
    <span class="n">_CellSize</span> <span class="p">(</span><span class="s">"Cell Size"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">_Period</span> <span class="p">(</span><span class="s">"Repeat every X cells"</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">[</span><span class="n">IntRange</span><span class="p">]</span><span class="n">_Roughness</span> <span class="p">(</span><span class="s">"Roughness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">_Persistance</span> <span class="p">(</span><span class="s">"Persistance"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">4</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//global shader variables</span>
<span class="n">float2</span> <span class="n">_Period</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//sampleLayeredNoise function</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">+</span> <span class="n">perlinNoise</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">frequency</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">72354</span><span class="p">,</span> <span class="n">_Period</span> <span class="o">*</span> <span class="n">frequency</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/029/RepeatingLayeredPerlinSettings.png" alt="" /></p>

<p><img src="/assets/images/posts/029/RepeatingLayeredPerlin.png" alt="" /></p>

<h2 id="noise-in-unlit-uv-space">Noise in unlit UV space</h2>

<p>So far we always used worldspace coordinates as base values for our noise, specifically to not have to deal with weird scaling or uv mapping on objects. Plus we used surface shaders for super easy access to worldspace coordinates and fancy lighting. But sometimes we want the noise to be in UV space and not use fancy lighting (for example to bake the noise into a texture or to use the cheaper 2d noise on a 3d object). This is how to convert our surface shader into a simpler shader that shows the noise in uv space and doesn’t calculate lighting. (To have the noise in UV space and still have a surface shader for fancy lighting it’s best to add a custom vertex function to the surface shader and pass the uv coordinates into your input struct from there.)</p>

<p>For the change to a non-surface shader, we add a shader pass just around the <code class="language-plaintext highlighter-rouge">CGPROGRAM</code> hlsl part, we explicitely import UnityCG library file, then we also define the vertex and fragment functions, add the appdata and vertex to fragment structs and lastly we change the surface function to a fragment function and add the vertex function. I copied most of those changes from the code of the <a href="/2018/03/23/basic.html">tutorial about textures</a>, so if you have any trouble understanding the changes I recommend you reread <a href="/2018/03/23/basic.html">that</a>.</p>

<p>While doing those changes we can also pass the uv coordinates to the fragment shader and replace the world coordinates with them to have noise in UV space.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SubShader</span> <span class="p">{</span>
    <span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

    <span class="n">Pass</span><span class="p">{</span>
        <span class="n">CGPROGRAM</span>

        <span class="c1">//include useful shader functions</span>
        <span class="cp">#include "UnityCG.cginc"
</span>
        <span class="c1">//define vertex and fragment shader</span>
        <span class="cp">#pragma vertex vert
</span>        <span class="cp">#pragma fragment frag
</span>
        <span class="cp">#pragma target 3.0
</span>
        <span class="cp">#include "Random.cginc"
</span>
        <span class="c1">//global shader variables</span>
        <span class="cp">#define OCTAVES 4
</span>
        <span class="kt">float</span> <span class="n">_CellSize</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">_Roughness</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">_Persistance</span><span class="p">;</span>
        <span class="n">float2</span> <span class="n">_Period</span><span class="p">;</span>

        <span class="c1">//the object data that's put into the vertex shader</span>
        <span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
            <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
            <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="c1">//the data that's used to generate fragments and can be read by the fragment shader</span>
        <span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
            <span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
            <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="c1">//easeIn function</span>

        <span class="c1">//easeOut function</span>

        <span class="c1">//easeInOut function</span>

        <span class="c1">//modulo function</span>

        <span class="c1">//perlinNoise function;</span>

        <span class="c1">//sampleLayeredNoise function</span>

        <span class="c1">//the vertex shader</span>
        <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
            <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
            <span class="c1">//convert the vertex positions from object space to clip space so they can be rendered</span>
            <span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
            <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">float4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
            <span class="n">float2</span> <span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">/</span> <span class="n">_CellSize</span><span class="p">;</span>
            <span class="c1">//get noise and adjust it to be ~0-1 range</span>
            <span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">sampleLayeredNoise</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">noise</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In my opinion, this change if space also changes the context of the size of the cells. It’s way more interresting now how many cells fit onto one texture (0 to 1 uv square) than how big one cell is. So I’ll change the cell size to a cell amount variable. With this change we also have to multiply the uvs with cell amount instead of dividing it like we did with the cell size.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//parameters</span>
<span class="n">_CellAmount</span> <span class="p">(</span><span class="s">"Cell Amount"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//global shader variables</span>
<span class="kt">float</span> <span class="n">_CellAmount</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//fragment function</span>
<span class="n">float2</span> <span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">*</span> <span class="n">_CellAmount</span><span class="p">;</span>
</code></pre></div></div>

<p>With those changes we have a shader that will show repeating noise in UV space, so we can move the object however we want and the noise will move with it. We get a pattern that will fill the 0 to 1 uv space and repeat afterwards if we use the same value for the cell amount, and the x and y component of the period (and it’s a value without a fractional part). We can also use a value twice as high as the period as the cell amount to have the noise repeat once in the 0 to 1 range etc…</p>

<p><img src="/assets/images/posts/029/UVNoiseTransformation.gif" alt="" /></p>

<h2 id="tiling-and-uv-space-noise-in-3d">Tiling and UV space noise in 3d</h2>

<p>For the example how to translate those concepts into 3d, I’m going to use voronoi noise. We start deleting the functions and properties that we used for perlin noise and don’t need anymore. That’s the roughness and persistance properties and the easing, perlin and layered noise functions. Then we add the copy in the code for voronoi noise from the <a href="/2018/09/29/voronoi-noise.html">tutorial about voronoi noise</a>.</p>

<p>Then we need to expand our shader to handle 3d vectors in a few places. First we add a new property called the “height”. We then use it as the <code class="language-plaintext highlighter-rouge">Z</code> factor of the value we pass to the voronoi function. Because we expect the uv space to go from 0 to 1, I’ll also limit the height to be between 0 and 1. Then we change the modulo function to accept and return 3d vectors, the operators work the same way on 2d vectors as on 3d vectors, so we don’t have to change anything except the types.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/029_material_baking/repeating_3d_voronoi"</span> <span class="p">{</span>
	<span class="n">Properties</span> <span class="p">{</span>
		<span class="n">_Height</span> <span class="p">(</span><span class="s">"Z coordinate (height)"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">_CellAmount</span> <span class="p">(</span><span class="s">"Cell Amount"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span> <span class="o">=</span> <span class="mi">2</span>
		<span class="n">_Period</span> <span class="p">(</span><span class="s">"Repeat every X cells"</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">SubShader</span> <span class="p">{</span>
		<span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

		<span class="n">Pass</span><span class="p">{</span>
			<span class="n">CGPROGRAM</span>

			<span class="c1">//include useful shader functions</span>
			<span class="cp">#include "UnityCG.cginc"
</span>
			<span class="c1">//define vertex and fragment shader</span>
			<span class="cp">#pragma vertex vert
</span>			<span class="cp">#pragma fragment frag
</span>
			<span class="cp">#pragma target 3.0
</span>
			<span class="cp">#include "Random.cginc"
</span>
			<span class="c1">//global shader variables</span>
			<span class="cp">#define OCTAVES 4
</span>
			<span class="kt">float</span> <span class="n">_CellAmount</span><span class="p">;</span>
			<span class="n">float3</span> <span class="n">_Period</span><span class="p">;</span>
			<span class="kt">float</span> <span class="n">_Height</span><span class="p">;</span>

			<span class="c1">//the object data that's put into the vertex shader</span>
			<span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
				<span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
				<span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
			<span class="p">};</span>

			<span class="c1">//the data that's used to generate fragments and can be read by the fragment shader</span>
			<span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
				<span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
				<span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
			<span class="p">};</span>

			<span class="n">float3</span> <span class="n">modulo</span><span class="p">(</span><span class="n">float3</span> <span class="n">divident</span><span class="p">,</span> <span class="n">float3</span> <span class="n">divisor</span><span class="p">){</span>
				<span class="n">float3</span> <span class="n">positiveDivident</span> <span class="o">=</span> <span class="n">divident</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">+</span> <span class="n">divisor</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">positiveDivident</span> <span class="o">%</span> <span class="n">divisor</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">//voronoi noise function from voronoi tutorial</span>

			<span class="c1">//the vertex function</span>
			<span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
				<span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
				<span class="c1">//convert the vertex positions from object space to clip space so they can be rendered</span>
				<span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
				<span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">float4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
				<span class="n">float3</span> <span class="n">value</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_Height</span><span class="p">)</span> <span class="o">*</span> <span class="n">_CellAmount</span><span class="p">;</span>
				<span class="c1">//get noise and adjust it to be ~0-1 range</span>
				<span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">voronoiNoise</span><span class="p">(</span><span class="n">value</span><span class="p">).</span><span class="n">z</span><span class="p">;</span>

				<span class="k">return</span> <span class="n">noise</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ENDCG</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">FallBack</span> <span class="s">"Standard"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then we also change the voronoi function to respect the tiling. Because we not only use the cell for the generation of random numbers, but also for distance calculations in voronoi noise, we can’t simply make the cell itself tile. Instead we’ll make a separate variable which is a tiled version of the cell. Then we can use the cell itself for position calculations and the tiled cell for the random number generation. It’s important that we do this for both the cell generation in the first pass as well as the second pass where we calculate the distance from the edge.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float3</span> <span class="nf">voronoiNoise</span><span class="p">(</span><span class="n">float3</span> <span class="n">value</span><span class="p">,</span> <span class="n">float3</span> <span class="n">period</span><span class="p">){</span>
    <span class="n">float3</span> <span class="n">baseCell</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

    <span class="c1">//first pass to find the closest cell</span>
    <span class="kt">float</span> <span class="n">minDistToCell</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">toClosestCell</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">closestCell</span><span class="p">;</span>
    <span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">x1</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">x1</span><span class="o">++</span><span class="p">){</span>
        <span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y1</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">y1</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">y1</span><span class="o">++</span><span class="p">){</span>
            <span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">z1</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">z1</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">z1</span><span class="o">++</span><span class="p">){</span>
                <span class="n">float3</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">baseCell</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">);</span>
                <span class="n">float3</span> <span class="n">tiledCell</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
                <span class="n">float3</span> <span class="n">cellPosition</span> <span class="o">=</span> <span class="n">cell</span> <span class="o">+</span> <span class="n">rand3dTo3d</span><span class="p">(</span><span class="n">tiledCell</span><span class="p">);</span>
                <span class="n">float3</span> <span class="n">toCell</span> <span class="o">=</span> <span class="n">cellPosition</span> <span class="o">-</span> <span class="n">value</span><span class="p">;</span>
                <span class="kt">float</span> <span class="n">distToCell</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">toCell</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">distToCell</span> <span class="o">&lt;</span> <span class="n">minDistToCell</span><span class="p">){</span>
                    <span class="n">minDistToCell</span> <span class="o">=</span> <span class="n">distToCell</span><span class="p">;</span>
                    <span class="n">closestCell</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>
                    <span class="n">toClosestCell</span> <span class="o">=</span> <span class="n">toCell</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//second pass to find the distance to the closest edge</span>
    <span class="kt">float</span> <span class="n">minEdgeDistance</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x2</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">x2</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">x2</span><span class="o">++</span><span class="p">){</span>
        <span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y2</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">y2</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">y2</span><span class="o">++</span><span class="p">){</span>
            <span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">z2</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">z2</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">z2</span><span class="o">++</span><span class="p">){</span>
                <span class="n">float3</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">baseCell</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">);</span>
                <span class="n">float3</span> <span class="n">tiledCell</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
                <span class="n">float3</span> <span class="n">cellPosition</span> <span class="o">=</span> <span class="n">cell</span> <span class="o">+</span> <span class="n">rand3dTo3d</span><span class="p">(</span><span class="n">tiledCell</span><span class="p">);</span>
                <span class="n">float3</span> <span class="n">toCell</span> <span class="o">=</span> <span class="n">cellPosition</span> <span class="o">-</span> <span class="n">value</span><span class="p">;</span>

                <span class="n">float3</span> <span class="n">diffToClosestCell</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">closestCell</span> <span class="o">-</span> <span class="n">cell</span><span class="p">);</span>
                <span class="kt">bool</span> <span class="n">isClosestCell</span> <span class="o">=</span> <span class="n">diffToClosestCell</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">diffToClosestCell</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">diffToClosestCell</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">isClosestCell</span><span class="p">){</span>
                    <span class="n">float3</span> <span class="n">toCenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">toClosestCell</span> <span class="o">+</span> <span class="n">toCell</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
                    <span class="n">float3</span> <span class="n">cellDifference</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">toCell</span> <span class="o">-</span> <span class="n">toClosestCell</span><span class="p">);</span>
                    <span class="kt">float</span> <span class="n">edgeDistance</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">toCenter</span><span class="p">,</span> <span class="n">cellDifference</span><span class="p">);</span>
                    <span class="n">minEdgeDistance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">minEdgeDistance</span><span class="p">,</span> <span class="n">edgeDistance</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">random</span> <span class="o">=</span> <span class="n">rand3dTo1d</span><span class="p">(</span><span class="n">closestCell</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">float3</span><span class="p">(</span><span class="n">minDistToCell</span><span class="p">,</span> <span class="n">random</span><span class="p">,</span> <span class="n">minEdgeDistance</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
    <span class="n">float3</span> <span class="n">value</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_Height</span><span class="p">)</span> <span class="o">*</span> <span class="n">_CellAmount</span><span class="p">;</span>
    <span class="c1">//get noise and adjust it to be ~0-1 range</span>
    <span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">voronoiNoise</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_Period</span><span class="p">).</span><span class="n">z</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">noise</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/posts/029/UVVoronoise.gif" alt="" /></p>

<h2 id="source">Source</h2>

<h3 id="tiling-2d-layered-perlin">Tiling 2d layered perlin</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/029_Tiling_Noise/2d_layered.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/029_Tiling_Noise/2d_layered.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/029_material_baking/layered_repeating_perlin"</span> <span class="p">{</span>
	<span class="n">Properties</span> <span class="p">{</span>
		<span class="n">_CellAmount</span> <span class="p">(</span><span class="s">"Cell Amount"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span> <span class="o">=</span> <span class="mi">2</span>
		<span class="n">_Period</span> <span class="p">(</span><span class="s">"Repeat every X cells"</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">[</span><span class="n">IntRange</span><span class="p">]</span><span class="n">_Roughness</span> <span class="p">(</span><span class="s">"Roughness"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="o">=</span> <span class="mi">3</span>
		<span class="n">_Persistance</span> <span class="p">(</span><span class="s">"Persistance"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">4</span>
	<span class="p">}</span>
	<span class="n">SubShader</span> <span class="p">{</span>
		<span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

		<span class="n">Pass</span><span class="p">{</span>
			<span class="n">CGPROGRAM</span>

			<span class="c1">//include useful shader functions</span>
			<span class="cp">#include "UnityCG.cginc"
</span>
			<span class="c1">//define vertex and fragment shader</span>
			<span class="cp">#pragma vertex vert
</span>			<span class="cp">#pragma fragment frag
</span>
			<span class="cp">#pragma target 3.0
</span>
			<span class="cp">#include "Random.cginc"
</span>
			<span class="c1">//global shader variables</span>
			<span class="cp">#define OCTAVES 4
</span>
			<span class="kt">float</span> <span class="n">_CellAmount</span><span class="p">;</span>
			<span class="kt">float</span> <span class="n">_Roughness</span><span class="p">;</span>
			<span class="kt">float</span> <span class="n">_Persistance</span><span class="p">;</span>
			<span class="n">float2</span> <span class="n">_Period</span><span class="p">;</span>

			<span class="c1">//the object data that's put into the vertex shader</span>
			<span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
				<span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
				<span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
			<span class="p">};</span>

			<span class="c1">//the data that's used to generate fragments and can be read by the fragment shader</span>
			<span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
				<span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
				<span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
			<span class="p">};</span>

			<span class="kt">float</span> <span class="n">easeIn</span><span class="p">(</span><span class="kt">float</span> <span class="n">interpolator</span><span class="p">){</span>
				<span class="k">return</span> <span class="n">interpolator</span> <span class="o">*</span> <span class="n">interpolator</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="kt">float</span> <span class="n">easeOut</span><span class="p">(</span><span class="kt">float</span> <span class="n">interpolator</span><span class="p">){</span>
				<span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">easeIn</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">interpolator</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="kt">float</span> <span class="n">easeInOut</span><span class="p">(</span><span class="kt">float</span> <span class="n">interpolator</span><span class="p">){</span>
				<span class="kt">float</span> <span class="n">easeInValue</span> <span class="o">=</span> <span class="n">easeIn</span><span class="p">(</span><span class="n">interpolator</span><span class="p">);</span>
				<span class="kt">float</span> <span class="n">easeOutValue</span> <span class="o">=</span> <span class="n">easeOut</span><span class="p">(</span><span class="n">interpolator</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">lerp</span><span class="p">(</span><span class="n">easeInValue</span><span class="p">,</span> <span class="n">easeOutValue</span><span class="p">,</span> <span class="n">interpolator</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">float2</span> <span class="n">modulo</span><span class="p">(</span><span class="n">float2</span> <span class="n">divident</span><span class="p">,</span> <span class="n">float2</span> <span class="n">divisor</span><span class="p">){</span>
				<span class="n">float2</span> <span class="n">positiveDivident</span> <span class="o">=</span> <span class="n">divident</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">+</span> <span class="n">divisor</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">positiveDivident</span> <span class="o">%</span> <span class="n">divisor</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="kt">float</span> <span class="n">perlinNoise</span><span class="p">(</span><span class="n">float2</span> <span class="n">value</span><span class="p">,</span> <span class="n">float2</span> <span class="n">period</span><span class="p">){</span>
				<span class="n">float2</span> <span class="n">cellsMimimum</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
				<span class="n">float2</span> <span class="n">cellsMaximum</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

				<span class="n">cellsMimimum</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">cellsMimimum</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
				<span class="n">cellsMaximum</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">cellsMaximum</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>

				<span class="c1">//generate random directions</span>
				<span class="n">float2</span> <span class="n">lowerLeftDirection</span> <span class="o">=</span> <span class="n">rand2dTo2d</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">cellsMimimum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellsMimimum</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">float2</span> <span class="n">lowerRightDirection</span> <span class="o">=</span> <span class="n">rand2dTo2d</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">cellsMaximum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellsMimimum</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">float2</span> <span class="n">upperLeftDirection</span> <span class="o">=</span> <span class="n">rand2dTo2d</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">cellsMimimum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellsMaximum</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">float2</span> <span class="n">upperRightDirection</span> <span class="o">=</span> <span class="n">rand2dTo2d</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">cellsMaximum</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cellsMaximum</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

				<span class="n">float2</span> <span class="n">fraction</span> <span class="o">=</span> <span class="n">frac</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

				<span class="c1">//get values of cells based on fraction and cell directions</span>
				<span class="kt">float</span> <span class="n">lowerLeftFunctionValue</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">lowerLeftDirection</span><span class="p">,</span> <span class="n">fraction</span> <span class="o">-</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
				<span class="kt">float</span> <span class="n">lowerRightFunctionValue</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">lowerRightDirection</span><span class="p">,</span> <span class="n">fraction</span> <span class="o">-</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
				<span class="kt">float</span> <span class="n">upperLeftFunctionValue</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">upperLeftDirection</span><span class="p">,</span> <span class="n">fraction</span> <span class="o">-</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
				<span class="kt">float</span> <span class="n">upperRightFunctionValue</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">upperRightDirection</span><span class="p">,</span> <span class="n">fraction</span> <span class="o">-</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

				<span class="kt">float</span> <span class="n">interpolatorX</span> <span class="o">=</span> <span class="n">easeInOut</span><span class="p">(</span><span class="n">fraction</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
				<span class="kt">float</span> <span class="n">interpolatorY</span> <span class="o">=</span> <span class="n">easeInOut</span><span class="p">(</span><span class="n">fraction</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

				<span class="c1">//interpolate between values</span>
				<span class="kt">float</span> <span class="n">lowerCells</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">lowerLeftFunctionValue</span><span class="p">,</span> <span class="n">lowerRightFunctionValue</span><span class="p">,</span> <span class="n">interpolatorX</span><span class="p">);</span>
				<span class="kt">float</span> <span class="n">upperCells</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">upperLeftFunctionValue</span><span class="p">,</span> <span class="n">upperRightFunctionValue</span><span class="p">,</span> <span class="n">interpolatorX</span><span class="p">);</span>

				<span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">lowerCells</span><span class="p">,</span> <span class="n">upperCells</span><span class="p">,</span> <span class="n">interpolatorY</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">noise</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="kt">float</span> <span class="n">sampleLayeredNoise</span><span class="p">(</span><span class="n">float2</span> <span class="n">value</span><span class="p">){</span>
				<span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="kt">float</span> <span class="n">frequency</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="kt">float</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

				<span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">OCTAVES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
					<span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">+</span> <span class="n">perlinNoise</span><span class="p">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">frequency</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">72354</span><span class="p">,</span> <span class="n">_Period</span> <span class="o">*</span> <span class="n">frequency</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
					<span class="n">factor</span> <span class="o">*=</span> <span class="n">_Persistance</span><span class="p">;</span>
					<span class="n">frequency</span> <span class="o">*=</span> <span class="n">_Roughness</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">return</span> <span class="n">noise</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">//the vertex shader</span>
			<span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
				<span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
				<span class="c1">//convert the vertex positions from object space to clip space so they can be rendered</span>
				<span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
				<span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">float4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
				<span class="n">float2</span> <span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span> <span class="o">*</span> <span class="n">_CellAmount</span><span class="p">;</span>
				<span class="c1">//get noise and adjust it to be ~0-1 range</span>
				<span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">sampleLayeredNoise</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

				<span class="k">return</span> <span class="n">noise</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ENDCG</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">FallBack</span> <span class="s">"Standard"</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="tiling-3d-voronoi">Tiling 3d voronoi</h3>

<ul>
  <li><a href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/029_Tiling_Noise/3d_voronoi.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/029_Tiling_Noise/3d_voronoi.shader</a></li>
</ul>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Tutorial/029_material_baking/repeating_3d_voronoi"</span> <span class="p">{</span>
	<span class="n">Properties</span> <span class="p">{</span>
		<span class="n">_Height</span> <span class="p">(</span><span class="s">"Z coordinate (height)"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">_CellAmount</span> <span class="p">(</span><span class="s">"Cell Amount"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span> <span class="o">=</span> <span class="mi">2</span>
		<span class="n">_Period</span> <span class="p">(</span><span class="s">"Repeat every X cells"</span><span class="p">,</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">SubShader</span> <span class="p">{</span>
		<span class="n">Tags</span><span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span><span class="p">}</span>

		<span class="n">Pass</span><span class="p">{</span>
			<span class="n">CGPROGRAM</span>

			<span class="c1">//include useful shader functions</span>
			<span class="cp">#include "UnityCG.cginc"
</span>
			<span class="c1">//define vertex and fragment shader</span>
			<span class="cp">#pragma vertex vert
</span>			<span class="cp">#pragma fragment frag
</span>
			<span class="cp">#pragma target 3.0
</span>
			<span class="cp">#include "Random.cginc"
</span>
			<span class="c1">//global shader variables</span>
			<span class="cp">#define OCTAVES 4
</span>
			<span class="kt">float</span> <span class="n">_CellAmount</span><span class="p">;</span>
			<span class="n">float3</span> <span class="n">_Period</span><span class="p">;</span>
			<span class="kt">float</span> <span class="n">_Height</span><span class="p">;</span>

			<span class="c1">//the object data that's put into the vertex shader</span>
			<span class="k">struct</span> <span class="n">appdata</span><span class="p">{</span>
				<span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
				<span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
			<span class="p">};</span>

			<span class="c1">//the data that's used to generate fragments and can be read by the fragment shader</span>
			<span class="k">struct</span> <span class="n">v2f</span><span class="p">{</span>
				<span class="n">float4</span> <span class="n">position</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
				<span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
			<span class="p">};</span>

			<span class="n">float3</span> <span class="n">modulo</span><span class="p">(</span><span class="n">float3</span> <span class="n">divident</span><span class="p">,</span> <span class="n">float3</span> <span class="n">divisor</span><span class="p">){</span>
				<span class="n">float3</span> <span class="n">positiveDivident</span> <span class="o">=</span> <span class="n">divident</span> <span class="o">%</span> <span class="n">divisor</span> <span class="o">+</span> <span class="n">divisor</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">positiveDivident</span> <span class="o">%</span> <span class="n">divisor</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">float3</span> <span class="n">voronoiNoise</span><span class="p">(</span><span class="n">float3</span> <span class="n">value</span><span class="p">,</span> <span class="n">float3</span> <span class="n">period</span><span class="p">){</span>
				<span class="n">float3</span> <span class="n">baseCell</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>

				<span class="c1">//first pass to find the closest cell</span>
				<span class="kt">float</span> <span class="n">minDistToCell</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
				<span class="n">float3</span> <span class="n">toClosestCell</span><span class="p">;</span>
				<span class="n">float3</span> <span class="n">closestCell</span><span class="p">;</span>
				<span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">x1</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">x1</span><span class="o">++</span><span class="p">){</span>
					<span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
					<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y1</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">y1</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">y1</span><span class="o">++</span><span class="p">){</span>
						<span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
						<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">z1</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">z1</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">z1</span><span class="o">++</span><span class="p">){</span>
							<span class="n">float3</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">baseCell</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">);</span>
							<span class="n">float3</span> <span class="n">tiledCell</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
							<span class="n">float3</span> <span class="n">cellPosition</span> <span class="o">=</span> <span class="n">cell</span> <span class="o">+</span> <span class="n">rand3dTo3d</span><span class="p">(</span><span class="n">tiledCell</span><span class="p">);</span>
							<span class="n">float3</span> <span class="n">toCell</span> <span class="o">=</span> <span class="n">cellPosition</span> <span class="o">-</span> <span class="n">value</span><span class="p">;</span>
							<span class="kt">float</span> <span class="n">distToCell</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">toCell</span><span class="p">);</span>
							<span class="k">if</span><span class="p">(</span><span class="n">distToCell</span> <span class="o">&lt;</span> <span class="n">minDistToCell</span><span class="p">){</span>
								<span class="n">minDistToCell</span> <span class="o">=</span> <span class="n">distToCell</span><span class="p">;</span>
								<span class="n">closestCell</span> <span class="o">=</span> <span class="n">cell</span><span class="p">;</span>
								<span class="n">toClosestCell</span> <span class="o">=</span> <span class="n">toCell</span><span class="p">;</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="c1">//second pass to find the distance to the closest edge</span>
				<span class="kt">float</span> <span class="n">minEdgeDistance</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
				<span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x2</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">x2</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">x2</span><span class="o">++</span><span class="p">){</span>
					<span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
					<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y2</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">y2</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">y2</span><span class="o">++</span><span class="p">){</span>
						<span class="p">[</span><span class="n">unroll</span><span class="p">]</span>
						<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">z2</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">z2</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">z2</span><span class="o">++</span><span class="p">){</span>
							<span class="n">float3</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">baseCell</span> <span class="o">+</span> <span class="n">float3</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">);</span>
							<span class="n">float3</span> <span class="n">tiledCell</span> <span class="o">=</span> <span class="n">modulo</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
							<span class="n">float3</span> <span class="n">cellPosition</span> <span class="o">=</span> <span class="n">cell</span> <span class="o">+</span> <span class="n">rand3dTo3d</span><span class="p">(</span><span class="n">tiledCell</span><span class="p">);</span>
							<span class="n">float3</span> <span class="n">toCell</span> <span class="o">=</span> <span class="n">cellPosition</span> <span class="o">-</span> <span class="n">value</span><span class="p">;</span>

							<span class="n">float3</span> <span class="n">diffToClosestCell</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">closestCell</span> <span class="o">-</span> <span class="n">cell</span><span class="p">);</span>
							<span class="kt">bool</span> <span class="n">isClosestCell</span> <span class="o">=</span> <span class="n">diffToClosestCell</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">diffToClosestCell</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">diffToClosestCell</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
							<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">isClosestCell</span><span class="p">){</span>
								<span class="n">float3</span> <span class="n">toCenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">toClosestCell</span> <span class="o">+</span> <span class="n">toCell</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
								<span class="n">float3</span> <span class="n">cellDifference</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">toCell</span> <span class="o">-</span> <span class="n">toClosestCell</span><span class="p">);</span>
								<span class="kt">float</span> <span class="n">edgeDistance</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">toCenter</span><span class="p">,</span> <span class="n">cellDifference</span><span class="p">);</span>
								<span class="n">minEdgeDistance</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">minEdgeDistance</span><span class="p">,</span> <span class="n">edgeDistance</span><span class="p">);</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="kt">float</span> <span class="n">random</span> <span class="o">=</span> <span class="n">rand3dTo1d</span><span class="p">(</span><span class="n">closestCell</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">float3</span><span class="p">(</span><span class="n">minDistToCell</span><span class="p">,</span> <span class="n">random</span><span class="p">,</span> <span class="n">minEdgeDistance</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="c1">//the vertex shader</span>
			<span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">){</span>
				<span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
				<span class="c1">//convert the vertex positions from object space to clip space so they can be rendered</span>
				<span class="n">o</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
				<span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
				<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">float4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span><span class="p">{</span>
				<span class="n">float3</span> <span class="n">value</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_Height</span><span class="p">)</span> <span class="o">*</span> <span class="n">_CellAmount</span><span class="p">;</span>
				<span class="c1">//get noise and adjust it to be ~0-1 range</span>
				<span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">voronoiNoise</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_Period</span><span class="p">).</span><span class="n">z</span><span class="p">;</span>

				<span class="k">return</span> <span class="n">noise</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ENDCG</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">FallBack</span> <span class="s">"Standard"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I hope I was able to explain how to make noise tile and that this knowledge will serve you well when you need it.</p>


    <p>
        You can also find me on twitter at <a href="https://www.twitter.com/totallyRonja">@totallyRonja</a>. If you liked my tutorial and want to support me you can do that on Patreon (<a href="https://www.patreon.com/RonjaTutorials">patreon.com/RonjaTutorials</a>) or Ko-Fi (<a href="https://ko-fi.com/RonjaTutorials">ko-fi.com/RonjaTutorials</a>).
    </p>
  </div>

  
    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ronja-tutorials.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  
</article>


      <!-- SVG icons from https://iconmonstr.com -->

      <!-- Twitter icon -->
      <span class="my-span-icon">
          <a href="https://twitter.com/TotallyRonja" aria-label="'s Twitter" title="'s Twitter">
            <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" style="margin-top: 12px;margin-left: 13px;"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z"/></svg>
          </a>
        </span>

        <!-- RSS icon -->
        
          <span class="my-span-icon">
            <a href="/feed.xml" aria-label="RSS feed" title="'s RSS feed">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-3.374 17c-.897 0-1.626-.727-1.626-1.624s.729-1.624 1.626-1.624 1.626.727 1.626 1.624-.729 1.624-1.626 1.624zm3.885 0c-.03-3.022-2.485-5.474-5.511-5.504v-2.406c4.361.03 7.889 3.555 7.92 7.91h-2.409zm4.081 0c-.016-5.297-4.303-9.571-9.592-9.594v-2.406c6.623.023 11.985 5.384 12 12h-2.408z"/></svg>
            </a>
          </span>
        
        <!-- Contact icon -->
        
        
          <span class="my-span-icon">
            <a href="/about.html" aria-label="Contact" title="Contact ">
              <svg class="my-svg-icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24"><path d="M12 .02c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.99 6.98l-6.99 5.666-6.991-5.666h13.981zm.01 10h-14v-8.505l7 5.673 7-5.672v8.504z"/></svg>
            </a>
          </span>
        
    </section>

    
      <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-124040112-1', 'auto');
        ga('send', 'pageview');
      </script>
    
  </body>
</html>
